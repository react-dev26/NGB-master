/** Miew - 3D Molecular Viewer v0.2.0-alpha.160803.112910+4d12cbc-mod Copyright (c) 2015-2016 EPAM Systems */
;(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    define(['jquery'], factory);
  } else if (typeof exports === 'object') {
    module.exports = factory(require('jquery'));
  } else {
    root.Miew = factory(root.jQuery);
  }
}(this, function(jquery) {
// File:src/Three.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
var three, dat, Spinner, utils, Stats, lodash, settings, options, utils_SelectionParser, chem_selectors, chem_AtomName, chem_AtomType, chem_Atom, chem_ResidueType, chem_Residue, chem_Chain, chem_Component, chem_Bond, chem_AtomPairs, chem_AutoBond, chem_SGroup, chem_AromaticMarker, chem_Complex, Profiler, gfx_GfxProfiler, io_Loader, io_Parser, io_FileLoader, io_MessageLoader, io_XHRLoader, chem_Helix, chem_Strand, chem_Sheet, io_PDBParser, io_MOLParser, mathjax, io_CMLParser, io_io, gfx_CSS2DObject, gfx_gfxutils, gfx_modes_buildBondLines, gfx_modes_SphereCollisionGeo, gfx_shaders_UberMaterial, gfx_modes_BufferGeometryWrapper32, gfx_modes_InstancedSphereBuilder, gfx_modes_buildCrossAtoms, gfx_modes_ChunkedLineBuilder, gfx_modes_buildALoopsLines, gfx_modes_ChunkedObjectBuilder, gfx_modes_SimpleCylinderBuilder, gfx_modes_CylinderBufferGeometry, gfx_modes_LinesBuilder, gfx_modes_LabelBuilder, gfx_modes_CrossBuilder, gfx_modes_LinesMode, gfx_modes_buildSphereAtoms, gfx_modes_buildAtomCollisionGeo, gfx_modes_buildCylinderBonds, gfx_modes_InstancedCylinderBuilder, gfx_modes_ExtrudedObjectBuilder, gfx_modes_buildALoopsTorus, gfx_modes_BufferGeometryWrapper16, gfx_modes_LicoriceMode, gfx_modes_BallsAndSticksMode, gfx_modes_VanDerWaalsMode, gfx_modes_buildTraceChain, gfx_modes_TraceMode, smooth, gfx_modes_CartoonHelper, gfx_modes_buildCartoonChains, gfx_modes_TubeMode, gfx_modes_buildNucleotideCylinders, gfx_modes_buildNucleotideSpheres, gfx_modes_CartoonMode, gfx_modes_IsoSurfaceAtomColored, gfx_modes_IsoSurfaceNormal, gfx_modes_IsoSurfaceCluster, gfx_modes_IsoSurfaceMarchCube, gfx_modes_IsoSurfaceGeo, gfx_modes_IsoSurfaceMode, gfx_modes_IsoSurfaceSASMode, gfx_modes_IsoSurfaceWMD, gfx_modes_VolumetricDataVMD, gfx_modes_buildQuickSurf, gfx_modes_QuickSufrMode, gfx_modes_IsoSurfaceSESMode, gfx_modes, gfx_palettes_Palette, gfx_palettes_JmolPalette, gfx_palettes_VmdPalette, gfx_palettes, gfx_colorers_AtomTypeColorer, gfx_colorers_ResidueTypeColorer, gfx_colorers_ResidueIdColorer, gfx_colorers_ChainColorer, gfx_colorers_SecondaryStructureColorer, gfx_colorers_UniformColorer, gfx_colorers, gfx_materials, gfx_Representation, gfx_CSS2DRenderer, text, text___menuhtml_strip, ui_Menu, ui_ObjectControls, ui_Picker, gfx_Axes, gfx_shaders_Outline, gfx_shaders_FXAA, Miew;
var THREE = { REVISION: '75' };
//
if (true) {
  three = function () {
    return typeof THREE === 'function' ? THREE() : THREE;
  }();
} else if ('undefined' !== typeof exports && 'undefined' !== typeof module) {
  module.exports = THREE;
}
//
if (Number.EPSILON === undefined) {
  Number.EPSILON = Math.pow(2, -52);
}
//
if (Math.sign === undefined) {
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
  Math.sign = function (x) {
    return x < 0 ? -1 : x > 0 ? 1 : +x;
  };
}
if (Function.prototype.name === undefined && Object.defineProperty !== undefined) {
  // Missing in IE9-11.
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
  Object.defineProperty(Function.prototype, 'name', {
    get: function () {
      return this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1];
    }
  });
}
if (Object.assign === undefined) {
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
  Object.defineProperty(Object, 'assign', {
    writable: true,
    configurable: true,
    value: function (target) {
      'use strict';
      if (target === undefined || target === null) {
        throw new TypeError('Cannot convert first argument to object');
      }
      var to = Object(target);
      for (var i = 1, n = arguments.length; i !== n; ++i) {
        var nextSource = arguments[i];
        if (nextSource === undefined || nextSource === null)
          continue;
        nextSource = Object(nextSource);
        var keysArray = Object.keys(nextSource);
        for (var nextIndex = 0, len = keysArray.length; nextIndex !== len; ++nextIndex) {
          var nextKey = keysArray[nextIndex];
          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== undefined && desc.enumerable) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
      return to;
    }
  });
}
// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button
THREE.MOUSE = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2
};
// GL STATE CONSTANTS
THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;
THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;
// SHADOWING TYPES
THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;
// MATERIAL CONSTANTS
// side
THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;
// shading
THREE.FlatShading = 1;
THREE.SmoothShading = 2;
// colors
THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;
// blending modes
THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;
// custom blending equations
// (numbers start from 100 not to clash with other
// mappings to OpenGL constants defined in Texture.js)
THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;
THREE.MinEquation = 103;
THREE.MaxEquation = 104;
// custom blending destination factors
THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;
// custom blending source factors
//THREE.ZeroFactor = 200;
//THREE.OneFactor = 201;
//THREE.SrcAlphaFactor = 204;
//THREE.OneMinusSrcAlphaFactor = 205;
//THREE.DstAlphaFactor = 206;
//THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;
// depth modes
THREE.NeverDepth = 0;
THREE.AlwaysDepth = 1;
THREE.LessDepth = 2;
THREE.LessEqualDepth = 3;
THREE.EqualDepth = 4;
THREE.GreaterEqualDepth = 5;
THREE.GreaterDepth = 6;
THREE.NotEqualDepth = 7;
// TEXTURE CONSTANTS
THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;
// Tone Mapping modes
THREE.NoToneMapping = 0;
// do not do any tone mapping, not even exposure (required for special purpose passes.)
THREE.LinearToneMapping = 1;
// only apply exposure.
THREE.ReinhardToneMapping = 2;
THREE.Uncharted2ToneMapping = 3;
// John Hable
THREE.CineonToneMapping = 4;
// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson
// Mapping modes
THREE.UVMapping = 300;
THREE.CubeReflectionMapping = 301;
THREE.CubeRefractionMapping = 302;
THREE.EquirectangularReflectionMapping = 303;
THREE.EquirectangularRefractionMapping = 304;
THREE.SphericalReflectionMapping = 305;
THREE.CubeUVReflectionMapping = 306;
THREE.CubeUVRefractionMapping = 307;
// Wrapping modes
THREE.RepeatWrapping = 1000;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;
// Filters
THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;
// Data types
THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;
THREE.HalfFloatType = 1025;
// Pixel types
//THREE.UnsignedByteType = 1009;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;
// Pixel formats
THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;
// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders
THREE.RGBEFormat = THREE.RGBAFormat;
//1024;
// DDS / ST3C Compressed texture formats
THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;
// PVRTC compressed texture formats
THREE.RGB_PVRTC_4BPPV1_Format = 2100;
THREE.RGB_PVRTC_2BPPV1_Format = 2101;
THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
THREE.RGBA_PVRTC_2BPPV1_Format = 2103;
// ETC compressed texture formats
THREE.RGB_ETC1_Format = 2151;
// Loop styles for AnimationAction
THREE.LoopOnce = 2200;
THREE.LoopRepeat = 2201;
THREE.LoopPingPong = 2202;
// Interpolation
THREE.InterpolateDiscrete = 2300;
THREE.InterpolateLinear = 2301;
THREE.InterpolateSmooth = 2302;
// Interpolant ending modes
THREE.ZeroCurvatureEnding = 2400;
THREE.ZeroSlopeEnding = 2401;
THREE.WrapAroundEnding = 2402;
// Triangle Draw modes
THREE.TrianglesDrawMode = 0;
THREE.TriangleStripDrawMode = 1;
THREE.TriangleFanDrawMode = 2;
// Texture Encodings
THREE.LinearEncoding = 3000;
// No encoding at all.
THREE.sRGBEncoding = 3001;
THREE.GammaEncoding = 3007;
// uses GAMMA_FACTOR, for backwards compatibility with WebGLRenderer.gammaInput/gammaOutput
// The following Texture Encodings are for RGB-only (no alpha) HDR light emission sources.
// These encodings should not specified as output encodings except in rare situations.
THREE.RGBEEncoding = 3002;
// AKA Radiance.
THREE.LogLuvEncoding = 3003;
THREE.RGBM7Encoding = 3004;
THREE.RGBM16Encoding = 3005;
THREE.RGBDEncoding = 3006;
// MaxRange is 256.
// File:src/math/Color.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
THREE.Color = function (color) {
  if (arguments.length === 3) {
    return this.fromArray(arguments);
  }
  return this.set(color);
};
THREE.Color.prototype = {
  constructor: THREE.Color,
  r: 1,
  g: 1,
  b: 1,
  set: function (value) {
    if (value instanceof THREE.Color) {
      this.copy(value);
    } else if (typeof value === 'number') {
      this.setHex(value);
    } else if (typeof value === 'string') {
      this.setStyle(value);
    }
    return this;
  },
  setScalar: function (scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
  },
  setHex: function (hex) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    return this;
  },
  setRGB: function (r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
    return this;
  },
  setHSL: function () {
    function hue2rgb(p, q, t) {
      if (t < 0)
        t += 1;
      if (t > 1)
        t -= 1;
      if (t < 1 / 6)
        return p + (q - p) * 6 * t;
      if (t < 1 / 2)
        return q;
      if (t < 2 / 3)
        return p + (q - p) * 6 * (2 / 3 - t);
      return p;
    }
    return function (h, s, l) {
      // h,s,l ranges are in 0.0 - 1.0
      h = THREE.Math.euclideanModulo(h, 1);
      s = THREE.Math.clamp(s, 0, 1);
      l = THREE.Math.clamp(l, 0, 1);
      if (s === 0) {
        this.r = this.g = this.b = l;
      } else {
        var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
        var q = 2 * l - p;
        this.r = hue2rgb(q, p, h + 1 / 3);
        this.g = hue2rgb(q, p, h);
        this.b = hue2rgb(q, p, h - 1 / 3);
      }
      return this;
    };
  }(),
  setStyle: function (style) {
    function handleAlpha(string) {
      if (string === undefined)
        return;
      if (parseFloat(string) < 1) {
        console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
      }
    }
    var m;
    if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
      // rgb / hsl
      var color;
      var name = m[1];
      var components = m[2];
      switch (name) {
      case 'rgb':
      case 'rgba':
        if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
          // rgb(255,0,0) rgba(255,0,0,0.5)
          this.r = Math.min(255, parseInt(color[1], 10)) / 255;
          this.g = Math.min(255, parseInt(color[2], 10)) / 255;
          this.b = Math.min(255, parseInt(color[3], 10)) / 255;
          handleAlpha(color[5]);
          return this;
        }
        if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
          // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
          this.r = Math.min(100, parseInt(color[1], 10)) / 100;
          this.g = Math.min(100, parseInt(color[2], 10)) / 100;
          this.b = Math.min(100, parseInt(color[3], 10)) / 100;
          handleAlpha(color[5]);
          return this;
        }
        break;
      case 'hsl':
      case 'hsla':
        if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
          // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
          var h = parseFloat(color[1]) / 360;
          var s = parseInt(color[2], 10) / 100;
          var l = parseInt(color[3], 10) / 100;
          handleAlpha(color[5]);
          return this.setHSL(h, s, l);
        }
        break;
      }
    } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
      // hex color
      var hex = m[1];
      var size = hex.length;
      if (size === 3) {
        // #ff0
        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
        return this;
      } else if (size === 6) {
        // #ff0000
        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
        return this;
      }
    }
    if (style && style.length > 0) {
      // color keywords
      var hex = THREE.ColorKeywords[style];
      if (hex !== undefined) {
        // red
        this.setHex(hex);
      } else {
        // unknown color
        console.warn('THREE.Color: Unknown color ' + style);
      }
    }
    return this;
  },
  clone: function () {
    return new this.constructor(this.r, this.g, this.b);
  },
  copy: function (color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  },
  copyGammaToLinear: function (color, gammaFactor) {
    if (gammaFactor === undefined)
      gammaFactor = 2;
    this.r = Math.pow(color.r, gammaFactor);
    this.g = Math.pow(color.g, gammaFactor);
    this.b = Math.pow(color.b, gammaFactor);
    return this;
  },
  copyLinearToGamma: function (color, gammaFactor) {
    if (gammaFactor === undefined)
      gammaFactor = 2;
    var safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
    this.r = Math.pow(color.r, safeInverse);
    this.g = Math.pow(color.g, safeInverse);
    this.b = Math.pow(color.b, safeInverse);
    return this;
  },
  convertGammaToLinear: function () {
    var r = this.r, g = this.g, b = this.b;
    this.r = r * r;
    this.g = g * g;
    this.b = b * b;
    return this;
  },
  convertLinearToGamma: function () {
    this.r = Math.sqrt(this.r);
    this.g = Math.sqrt(this.g);
    this.b = Math.sqrt(this.b);
    return this;
  },
  getHex: function () {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  },
  getHexString: function () {
    return ('000000' + this.getHex().toString(16)).slice(-6);
  },
  getHSL: function (optionalTarget) {
    // h,s,l ranges are in 0.0 - 1.0
    var hsl = optionalTarget || {
      h: 0,
      s: 0,
      l: 0
    };
    var r = this.r, g = this.g, b = this.b;
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var hue, saturation;
    var lightness = (min + max) / 2;
    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      var delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
      switch (max) {
      case r:
        hue = (g - b) / delta + (g < b ? 6 : 0);
        break;
      case g:
        hue = (b - r) / delta + 2;
        break;
      case b:
        hue = (r - g) / delta + 4;
        break;
      }
      hue /= 6;
    }
    hsl.h = hue;
    hsl.s = saturation;
    hsl.l = lightness;
    return hsl;
  },
  getStyle: function () {
    return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';
  },
  offsetHSL: function (h, s, l) {
    var hsl = this.getHSL();
    hsl.h += h;
    hsl.s += s;
    hsl.l += l;
    this.setHSL(hsl.h, hsl.s, hsl.l);
    return this;
  },
  add: function (color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  },
  addColors: function (color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  },
  addScalar: function (s) {
    this.r += s;
    this.g += s;
    this.b += s;
    return this;
  },
  multiply: function (color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  },
  multiplyScalar: function (s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    return this;
  },
  lerp: function (color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  },
  equals: function (c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  },
  fromArray: function (array, offset) {
    if (offset === undefined)
      offset = 0;
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined)
      array = [];
    if (offset === undefined)
      offset = 0;
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  }
};
THREE.ColorKeywords = {
  'aliceblue': 15792383,
  'antiquewhite': 16444375,
  'aqua': 65535,
  'aquamarine': 8388564,
  'azure': 15794175,
  'beige': 16119260,
  'bisque': 16770244,
  'black': 0,
  'blanchedalmond': 16772045,
  'blue': 255,
  'blueviolet': 9055202,
  'brown': 10824234,
  'burlywood': 14596231,
  'cadetblue': 6266528,
  'chartreuse': 8388352,
  'chocolate': 13789470,
  'coral': 16744272,
  'cornflowerblue': 6591981,
  'cornsilk': 16775388,
  'crimson': 14423100,
  'cyan': 65535,
  'darkblue': 139,
  'darkcyan': 35723,
  'darkgoldenrod': 12092939,
  'darkgray': 11119017,
  'darkgreen': 25600,
  'darkgrey': 11119017,
  'darkkhaki': 12433259,
  'darkmagenta': 9109643,
  'darkolivegreen': 5597999,
  'darkorange': 16747520,
  'darkorchid': 10040012,
  'darkred': 9109504,
  'darksalmon': 15308410,
  'darkseagreen': 9419919,
  'darkslateblue': 4734347,
  'darkslategray': 3100495,
  'darkslategrey': 3100495,
  'darkturquoise': 52945,
  'darkviolet': 9699539,
  'deeppink': 16716947,
  'deepskyblue': 49151,
  'dimgray': 6908265,
  'dimgrey': 6908265,
  'dodgerblue': 2003199,
  'firebrick': 11674146,
  'floralwhite': 16775920,
  'forestgreen': 2263842,
  'fuchsia': 16711935,
  'gainsboro': 14474460,
  'ghostwhite': 16316671,
  'gold': 16766720,
  'goldenrod': 14329120,
  'gray': 8421504,
  'green': 32768,
  'greenyellow': 11403055,
  'grey': 8421504,
  'honeydew': 15794160,
  'hotpink': 16738740,
  'indianred': 13458524,
  'indigo': 4915330,
  'ivory': 16777200,
  'khaki': 15787660,
  'lavender': 15132410,
  'lavenderblush': 16773365,
  'lawngreen': 8190976,
  'lemonchiffon': 16775885,
  'lightblue': 11393254,
  'lightcoral': 15761536,
  'lightcyan': 14745599,
  'lightgoldenrodyellow': 16448210,
  'lightgray': 13882323,
  'lightgreen': 9498256,
  'lightgrey': 13882323,
  'lightpink': 16758465,
  'lightsalmon': 16752762,
  'lightseagreen': 2142890,
  'lightskyblue': 8900346,
  'lightslategray': 7833753,
  'lightslategrey': 7833753,
  'lightsteelblue': 11584734,
  'lightyellow': 16777184,
  'lime': 65280,
  'limegreen': 3329330,
  'linen': 16445670,
  'magenta': 16711935,
  'maroon': 8388608,
  'mediumaquamarine': 6737322,
  'mediumblue': 205,
  'mediumorchid': 12211667,
  'mediumpurple': 9662683,
  'mediumseagreen': 3978097,
  'mediumslateblue': 8087790,
  'mediumspringgreen': 64154,
  'mediumturquoise': 4772300,
  'mediumvioletred': 13047173,
  'midnightblue': 1644912,
  'mintcream': 16121850,
  'mistyrose': 16770273,
  'moccasin': 16770229,
  'navajowhite': 16768685,
  'navy': 128,
  'oldlace': 16643558,
  'olive': 8421376,
  'olivedrab': 7048739,
  'orange': 16753920,
  'orangered': 16729344,
  'orchid': 14315734,
  'palegoldenrod': 15657130,
  'palegreen': 10025880,
  'paleturquoise': 11529966,
  'palevioletred': 14381203,
  'papayawhip': 16773077,
  'peachpuff': 16767673,
  'peru': 13468991,
  'pink': 16761035,
  'plum': 14524637,
  'powderblue': 11591910,
  'purple': 8388736,
  'red': 16711680,
  'rosybrown': 12357519,
  'royalblue': 4286945,
  'saddlebrown': 9127187,
  'salmon': 16416882,
  'sandybrown': 16032864,
  'seagreen': 3050327,
  'seashell': 16774638,
  'sienna': 10506797,
  'silver': 12632256,
  'skyblue': 8900331,
  'slateblue': 6970061,
  'slategray': 7372944,
  'slategrey': 7372944,
  'snow': 16775930,
  'springgreen': 65407,
  'steelblue': 4620980,
  'tan': 13808780,
  'teal': 32896,
  'thistle': 14204888,
  'tomato': 16737095,
  'turquoise': 4251856,
  'violet': 15631086,
  'wheat': 16113331,
  'white': 16777215,
  'whitesmoke': 16119285,
  'yellow': 16776960,
  'yellowgreen': 10145074
};
// File:src/math/Quaternion.js
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */
THREE.Quaternion = function (x, y, z, w) {
  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._w = w !== undefined ? w : 1;
};
THREE.Quaternion.prototype = {
  constructor: THREE.Quaternion,
  get x() {
    return this._x;
  },
  set x(value) {
    this._x = value;
    this.onChangeCallback();
  },
  get y() {
    return this._y;
  },
  set y(value) {
    this._y = value;
    this.onChangeCallback();
  },
  get z() {
    return this._z;
  },
  set z(value) {
    this._z = value;
    this.onChangeCallback();
  },
  get w() {
    return this._w;
  },
  set w(value) {
    this._w = value;
    this.onChangeCallback();
  },
  set: function (x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
    this.onChangeCallback();
    return this;
  },
  clone: function () {
    return new this.constructor(this._x, this._y, this._z, this._w);
  },
  copy: function (quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this.onChangeCallback();
    return this;
  },
  setFromEuler: function (euler, update) {
    if (euler instanceof THREE.Euler === false) {
      throw new Error('THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
    }
    // http://www.mathworks.com/matlabcentral/fileexchange/
    // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
    //	content/SpinCalc.m
    var c1 = Math.cos(euler._x / 2);
    var c2 = Math.cos(euler._y / 2);
    var c3 = Math.cos(euler._z / 2);
    var s1 = Math.sin(euler._x / 2);
    var s2 = Math.sin(euler._y / 2);
    var s3 = Math.sin(euler._z / 2);
    var order = euler.order;
    if (order === 'XYZ') {
      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === 'YXZ') {
      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;
    } else if (order === 'ZXY') {
      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === 'ZYX') {
      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;
    } else if (order === 'YZX') {
      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === 'XZY') {
      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;
    }
    if (update !== false)
      this.onChangeCallback();
    return this;
  },
  setFromAxisAngle: function (axis, angle) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
    // assumes axis is normalized
    var halfAngle = angle / 2, s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);
    this.onChangeCallback();
    return this;
  },
  setFromRotationMatrix: function (m) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    var te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33, s;
    if (trace > 0) {
      s = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }
    this.onChangeCallback();
    return this;
  },
  setFromUnitVectors: function () {
    // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final
    // assumes direction vectors vFrom and vTo are normalized
    var v1, r;
    var EPS = 0.000001;
    return function (vFrom, vTo) {
      if (v1 === undefined)
        v1 = new THREE.Vector3();
      r = vFrom.dot(vTo) + 1;
      if (r < EPS) {
        r = 0;
        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
          v1.set(-vFrom.y, vFrom.x, 0);
        } else {
          v1.set(0, -vFrom.z, vFrom.y);
        }
      } else {
        v1.crossVectors(vFrom, vTo);
      }
      this._x = v1.x;
      this._y = v1.y;
      this._z = v1.z;
      this._w = r;
      this.normalize();
      return this;
    };
  }(),
  inverse: function () {
    this.conjugate().normalize();
    return this;
  },
  conjugate: function () {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this.onChangeCallback();
    return this;
  },
  dot: function (v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  },
  lengthSq: function () {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  },
  length: function () {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  },
  normalize: function () {
    var l = this.length();
    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }
    this.onChangeCallback();
    return this;
  },
  multiply: function (q, p) {
    if (p !== undefined) {
      console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
      return this.multiplyQuaternions(q, p);
    }
    return this.multiplyQuaternions(this, q);
  },
  multiplyQuaternions: function (a, b) {
    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
    var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this.onChangeCallback();
    return this;
  },
  slerp: function (qb, t) {
    if (t === 0)
      return this;
    if (t === 1)
      return this.copy(qb);
    var x = this._x, y = this._y, z = this._z, w = this._w;
    // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
    var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;
      return this;
    }
    var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
    if (Math.abs(sinHalfTheta) < 0.001) {
      this._w = 0.5 * (w + this._w);
      this._x = 0.5 * (x + this._x);
      this._y = 0.5 * (y + this._y);
      this._z = 0.5 * (z + this._z);
      return this;
    }
    var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;
    this.onChangeCallback();
    return this;
  },
  equals: function (quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  },
  fromArray: function (array, offset) {
    if (offset === undefined)
      offset = 0;
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this.onChangeCallback();
    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined)
      array = [];
    if (offset === undefined)
      offset = 0;
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  },
  onChange: function (callback) {
    this.onChangeCallback = callback;
    return this;
  },
  onChangeCallback: function () {
  }
};
Object.assign(THREE.Quaternion, {
  slerp: function (qa, qb, qm, t) {
    return qm.copy(qa).slerp(qb, t);
  },
  slerpFlat: function (dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    // fuzz-free, array-based Quaternion SLERP operation
    var x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3], x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      var s = 1 - t, cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
      // Skip the Slerp for tiny steps to avoid numeric problems:
      if (sqrSin > Number.EPSILON) {
        var sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
        s = Math.sin(s * len) / sin;
        t = Math.sin(t * len) / sin;
      }
      var tDir = t * dir;
      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir;
      // Normalize in case we just did a lerp:
      if (s === 1 - t) {
        var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
});
// File:src/math/Vector2.js
/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */
THREE.Vector2 = function (x, y) {
  this.x = x || 0;
  this.y = y || 0;
};
THREE.Vector2.prototype = {
  constructor: THREE.Vector2,
  get width() {
    return this.x;
  },
  set width(value) {
    this.x = value;
  },
  get height() {
    return this.y;
  },
  set height(value) {
    this.y = value;
  },
  //
  set: function (x, y) {
    this.x = x;
    this.y = y;
    return this;
  },
  setScalar: function (scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  },
  setX: function (x) {
    this.x = x;
    return this;
  },
  setY: function (y) {
    this.y = y;
    return this;
  },
  setComponent: function (index, value) {
    switch (index) {
    case 0:
      this.x = value;
      break;
    case 1:
      this.y = value;
      break;
    default:
      throw new Error('index is out of range: ' + index);
    }
  },
  getComponent: function (index) {
    switch (index) {
    case 0:
      return this.x;
    case 1:
      return this.y;
    default:
      throw new Error('index is out of range: ' + index);
    }
  },
  clone: function () {
    return new this.constructor(this.x, this.y);
  },
  copy: function (v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  },
  add: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    return this;
  },
  addScalar: function (s) {
    this.x += s;
    this.y += s;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  },
  addScaledVector: function (v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    return this;
  },
  sub: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    return this;
  },
  subScalar: function (s) {
    this.x -= s;
    this.y -= s;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  },
  multiply: function (v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  },
  multiplyScalar: function (scalar) {
    if (isFinite(scalar)) {
      this.x *= scalar;
      this.y *= scalar;
    } else {
      this.x = 0;
      this.y = 0;
    }
    return this;
  },
  divide: function (v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  },
  divideScalar: function (scalar) {
    return this.multiplyScalar(1 / scalar);
  },
  min: function (v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  },
  max: function (v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  },
  clamp: function (min, max) {
    // This function assumes min < max, if this assumption isn't true it will not operate correctly
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  },
  clampScalar: function () {
    var min, max;
    return function clampScalar(minVal, maxVal) {
      if (min === undefined) {
        min = new THREE.Vector2();
        max = new THREE.Vector2();
      }
      min.set(minVal, minVal);
      max.set(maxVal, maxVal);
      return this.clamp(min, max);
    };
  }(),
  clampLength: function (min, max) {
    var length = this.length();
    this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
    return this;
  },
  floor: function () {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  },
  ceil: function () {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  },
  round: function () {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  },
  roundToZero: function () {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  },
  negate: function () {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  },
  dot: function (v) {
    return this.x * v.x + this.y * v.y;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  },
  lengthManhattan: function () {
    return Math.abs(this.x) + Math.abs(this.y);
  },
  normalize: function () {
    return this.divideScalar(this.length());
  },
  angle: function () {
    // computes the angle in radians with respect to the positive x-axis
    var angle = Math.atan2(this.y, this.x);
    if (angle < 0)
      angle += 2 * Math.PI;
    return angle;
  },
  distanceTo: function (v) {
    return Math.sqrt(this.distanceToSquared(v));
  },
  distanceToSquared: function (v) {
    var dx = this.x - v.x, dy = this.y - v.y;
    return dx * dx + dy * dy;
  },
  setLength: function (length) {
    return this.multiplyScalar(length / this.length());
  },
  lerp: function (v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  },
  lerpVectors: function (v1, v2, alpha) {
    this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
    return this;
  },
  equals: function (v) {
    return v.x === this.x && v.y === this.y;
  },
  fromArray: function (array, offset) {
    if (offset === undefined)
      offset = 0;
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined)
      array = [];
    if (offset === undefined)
      offset = 0;
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  },
  fromAttribute: function (attribute, index, offset) {
    if (offset === undefined)
      offset = 0;
    index = index * attribute.itemSize + offset;
    this.x = attribute.array[index];
    this.y = attribute.array[index + 1];
    return this;
  },
  rotateAround: function (center, angle) {
    var c = Math.cos(angle), s = Math.sin(angle);
    var x = this.x - center.x;
    var y = this.y - center.y;
    this.x = x * c - y * s + center.x;
    this.y = x * s + y * c + center.y;
    return this;
  }
};
// File:src/math/Vector3.js
/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */
THREE.Vector3 = function (x, y, z) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
};
THREE.Vector3.prototype = {
  constructor: THREE.Vector3,
  set: function (x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  },
  setScalar: function (scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  },
  setX: function (x) {
    this.x = x;
    return this;
  },
  setY: function (y) {
    this.y = y;
    return this;
  },
  setZ: function (z) {
    this.z = z;
    return this;
  },
  setComponent: function (index, value) {
    switch (index) {
    case 0:
      this.x = value;
      break;
    case 1:
      this.y = value;
      break;
    case 2:
      this.z = value;
      break;
    default:
      throw new Error('index is out of range: ' + index);
    }
  },
  getComponent: function (index) {
    switch (index) {
    case 0:
      return this.x;
    case 1:
      return this.y;
    case 2:
      return this.z;
    default:
      throw new Error('index is out of range: ' + index);
    }
  },
  clone: function () {
    return new this.constructor(this.x, this.y, this.z);
  },
  copy: function (v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  },
  add: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  },
  addScalar: function (s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  },
  addScaledVector: function (v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    return this;
  },
  sub: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  },
  subScalar: function (s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  },
  multiply: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
      return this.multiplyVectors(v, w);
    }
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  },
  multiplyScalar: function (scalar) {
    if (isFinite(scalar)) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
    } else {
      this.x = 0;
      this.y = 0;
      this.z = 0;
    }
    return this;
  },
  multiplyVectors: function (a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  },
  applyEuler: function () {
    var quaternion;
    return function applyEuler(euler) {
      if (euler instanceof THREE.Euler === false) {
        console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
      }
      if (quaternion === undefined)
        quaternion = new THREE.Quaternion();
      this.applyQuaternion(quaternion.setFromEuler(euler));
      return this;
    };
  }(),
  applyAxisAngle: function () {
    var quaternion;
    return function applyAxisAngle(axis, angle) {
      if (quaternion === undefined)
        quaternion = new THREE.Quaternion();
      this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
      return this;
    };
  }(),
  applyMatrix3: function (m) {
    var x = this.x;
    var y = this.y;
    var z = this.z;
    var e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;
    return this;
  },
  applyMatrix4: function (m) {
    // input: THREE.Matrix4 affine matrix
    var x = this.x, y = this.y, z = this.z;
    var e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z + e[12];
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13];
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14];
    return this;
  },
  applyProjection: function (m) {
    // input: THREE.Matrix4 projection matrix
    var x = this.x, y = this.y, z = this.z;
    var e = m.elements;
    var d = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    // perspective divide
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * d;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * d;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * d;
    return this;
  },
  applyQuaternion: function (q) {
    var x = this.x;
    var y = this.y;
    var z = this.z;
    var qx = q.x;
    var qy = q.y;
    var qz = q.z;
    var qw = q.w;
    // calculate quat * vector
    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z;
    // calculate result * inverse quat
    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  },
  project: function () {
    var matrix;
    return function project(camera) {
      if (matrix === undefined)
        matrix = new THREE.Matrix4();
      matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld));
      return this.applyProjection(matrix);
    };
  }(),
  unproject: function () {
    var matrix;
    return function unproject(camera) {
      if (matrix === undefined)
        matrix = new THREE.Matrix4();
      matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));
      return this.applyProjection(matrix);
    };
  }(),
  transformDirection: function (m) {
    // input: THREE.Matrix4 affine matrix
    // vector interpreted as a direction
    var x = this.x, y = this.y, z = this.z;
    var e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;
    this.normalize();
    return this;
  },
  divide: function (v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  },
  divideScalar: function (scalar) {
    return this.multiplyScalar(1 / scalar);
  },
  min: function (v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  },
  max: function (v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  },
  clamp: function (min, max) {
    // This function assumes min < max, if this assumption isn't true it will not operate correctly
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  },
  clampScalar: function () {
    var min, max;
    return function clampScalar(minVal, maxVal) {
      if (min === undefined) {
        min = new THREE.Vector3();
        max = new THREE.Vector3();
      }
      min.set(minVal, minVal, minVal);
      max.set(maxVal, maxVal, maxVal);
      return this.clamp(min, max);
    };
  }(),
  clampLength: function (min, max) {
    var length = this.length();
    this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
    return this;
  },
  floor: function () {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  },
  ceil: function () {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  },
  round: function () {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  },
  roundToZero: function () {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  },
  negate: function () {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  },
  dot: function (v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  },
  lengthManhattan: function () {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  },
  normalize: function () {
    return this.divideScalar(this.length());
  },
  setLength: function (length) {
    return this.multiplyScalar(length / this.length());
  },
  lerp: function (v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  },
  lerpVectors: function (v1, v2, alpha) {
    this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
    return this;
  },
  cross: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
      return this.crossVectors(v, w);
    }
    var x = this.x, y = this.y, z = this.z;
    this.x = y * v.z - z * v.y;
    this.y = z * v.x - x * v.z;
    this.z = x * v.y - y * v.x;
    return this;
  },
  crossVectors: function (a, b) {
    var ax = a.x, ay = a.y, az = a.z;
    var bx = b.x, by = b.y, bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  },
  projectOnVector: function () {
    var v1, dot;
    return function projectOnVector(vector) {
      if (v1 === undefined)
        v1 = new THREE.Vector3();
      v1.copy(vector).normalize();
      dot = this.dot(v1);
      return this.copy(v1).multiplyScalar(dot);
    };
  }(),
  projectOnPlane: function () {
    var v1;
    return function projectOnPlane(planeNormal) {
      if (v1 === undefined)
        v1 = new THREE.Vector3();
      v1.copy(this).projectOnVector(planeNormal);
      return this.sub(v1);
    };
  }(),
  reflect: function () {
    // reflect incident vector off plane orthogonal to normal
    // normal is assumed to have unit length
    var v1;
    return function reflect(normal) {
      if (v1 === undefined)
        v1 = new THREE.Vector3();
      return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
    };
  }(),
  angleTo: function (v) {
    var theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq());
    // clamp, to handle numerical problems
    return Math.acos(THREE.Math.clamp(theta, -1, 1));
  },
  distanceTo: function (v) {
    return Math.sqrt(this.distanceToSquared(v));
  },
  distanceToSquared: function (v) {
    var dx = this.x - v.x;
    var dy = this.y - v.y;
    var dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  },
  setFromSpherical: function (s) {
    var sinPhiRadius = Math.sin(s.phi) * s.radius;
    this.x = sinPhiRadius * Math.sin(s.theta);
    this.y = Math.cos(s.phi) * s.radius;
    this.z = sinPhiRadius * Math.cos(s.theta);
    return this;
  },
  setFromMatrixPosition: function (m) {
    return this.setFromMatrixColumn(m, 3);
  },
  setFromMatrixScale: function (m) {
    var sx = this.setFromMatrixColumn(m, 0).length();
    var sy = this.setFromMatrixColumn(m, 1).length();
    var sz = this.setFromMatrixColumn(m, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  },
  setFromMatrixColumn: function (m, index) {
    if (typeof m === 'number') {
      console.warn('THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).');
      m = arguments[1];
      index = arguments[0];
    }
    return this.fromArray(m.elements, index * 4);
  },
  equals: function (v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  },
  fromArray: function (array, offset) {
    if (offset === undefined)
      offset = 0;
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined)
      array = [];
    if (offset === undefined)
      offset = 0;
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  },
  fromAttribute: function (attribute, index, offset) {
    if (offset === undefined)
      offset = 0;
    index = index * attribute.itemSize + offset;
    this.x = attribute.array[index];
    this.y = attribute.array[index + 1];
    this.z = attribute.array[index + 2];
    return this;
  }
};
// File:src/math/Vector4.js
/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */
THREE.Vector4 = function (x, y, z, w) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
  this.w = w !== undefined ? w : 1;
};
THREE.Vector4.prototype = {
  constructor: THREE.Vector4,
  set: function (x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  },
  setScalar: function (scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  },
  setX: function (x) {
    this.x = x;
    return this;
  },
  setY: function (y) {
    this.y = y;
    return this;
  },
  setZ: function (z) {
    this.z = z;
    return this;
  },
  setW: function (w) {
    this.w = w;
    return this;
  },
  setComponent: function (index, value) {
    switch (index) {
    case 0:
      this.x = value;
      break;
    case 1:
      this.y = value;
      break;
    case 2:
      this.z = value;
      break;
    case 3:
      this.w = value;
      break;
    default:
      throw new Error('index is out of range: ' + index);
    }
  },
  getComponent: function (index) {
    switch (index) {
    case 0:
      return this.x;
    case 1:
      return this.y;
    case 2:
      return this.z;
    case 3:
      return this.w;
    default:
      throw new Error('index is out of range: ' + index);
    }
  },
  clone: function () {
    return new this.constructor(this.x, this.y, this.z, this.w);
  },
  copy: function (v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.w !== undefined ? v.w : 1;
    return this;
  },
  add: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;
    return this;
  },
  addScalar: function (s) {
    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  },
  addScaledVector: function (v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    this.w += v.w * s;
    return this;
  },
  sub: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;
    return this;
  },
  subScalar: function (s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    this.w -= s;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  },
  multiplyScalar: function (scalar) {
    if (isFinite(scalar)) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      this.w *= scalar;
    } else {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 0;
    }
    return this;
  },
  applyMatrix4: function (m) {
    var x = this.x;
    var y = this.y;
    var z = this.z;
    var w = this.w;
    var e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
    return this;
  },
  divideScalar: function (scalar) {
    return this.multiplyScalar(1 / scalar);
  },
  setAxisAngleFromQuaternion: function (q) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
    // q is assumed to be normalized
    this.w = 2 * Math.acos(q.w);
    var s = Math.sqrt(1 - q.w * q.w);
    if (s < 0.0001) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s;
      this.y = q.y / s;
      this.z = q.z / s;
    }
    return this;
  },
  setAxisAngleFromRotationMatrix: function (m) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    var angle, x, y, z,
      // variables for result
      epsilon = 0.01,
      // margin to allow for rounding errors
      epsilon2 = 0.1,
      // margin to distinguish between 0 and 180 degrees
      te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      // singularity found
      // first check for identity matrix which must have +1 for all terms
      // in leading diagonal and zero in other terms
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        // this singularity is identity matrix so angle = 0
        this.set(1, 0, 0, 0);
        return this;  // zero angle, arbitrary axis
      }
      // otherwise this singularity is angle = 180
      angle = Math.PI;
      var xx = (m11 + 1) / 2;
      var yy = (m22 + 1) / 2;
      var zz = (m33 + 1) / 2;
      var xy = (m12 + m21) / 4;
      var xz = (m13 + m31) / 4;
      var yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        // m11 is the largest diagonal term
        if (xx < epsilon) {
          x = 0;
          y = 0.707106781;
          z = 0.707106781;
        } else {
          x = Math.sqrt(xx);
          y = xy / x;
          z = xz / x;
        }
      } else if (yy > zz) {
        // m22 is the largest diagonal term
        if (yy < epsilon) {
          x = 0.707106781;
          y = 0;
          z = 0.707106781;
        } else {
          y = Math.sqrt(yy);
          x = xy / y;
          z = yz / y;
        }
      } else {
        // m33 is the largest diagonal term so base result on this
        if (zz < epsilon) {
          x = 0.707106781;
          y = 0.707106781;
          z = 0;
        } else {
          z = Math.sqrt(zz);
          x = xz / z;
          y = yz / z;
        }
      }
      this.set(x, y, z, angle);
      return this;  // return 180 deg rotation
    }
    // as we have reached here there are no singularities so we can handle normally
    var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    // used to normalize
    if (Math.abs(s) < 0.001)
      s = 1;
    // prevent divide by zero, should not happen if matrix is orthogonal and should be
    // caught by singularity test above, but I've left it in just in case
    this.x = (m32 - m23) / s;
    this.y = (m13 - m31) / s;
    this.z = (m21 - m12) / s;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  },
  min: function (v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    this.w = Math.min(this.w, v.w);
    return this;
  },
  max: function (v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    this.w = Math.max(this.w, v.w);
    return this;
  },
  clamp: function (min, max) {
    // This function assumes min < max, if this assumption isn't true it will not operate correctly
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));
    return this;
  },
  clampScalar: function () {
    var min, max;
    return function clampScalar(minVal, maxVal) {
      if (min === undefined) {
        min = new THREE.Vector4();
        max = new THREE.Vector4();
      }
      min.set(minVal, minVal, minVal, minVal);
      max.set(maxVal, maxVal, maxVal, maxVal);
      return this.clamp(min, max);
    };
  }(),
  floor: function () {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  },
  ceil: function () {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  },
  round: function () {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  },
  roundToZero: function () {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  },
  negate: function () {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  },
  dot: function (v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  },
  lengthManhattan: function () {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  },
  normalize: function () {
    return this.divideScalar(this.length());
  },
  setLength: function (length) {
    return this.multiplyScalar(length / this.length());
  },
  lerp: function (v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    this.w += (v.w - this.w) * alpha;
    return this;
  },
  lerpVectors: function (v1, v2, alpha) {
    this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
    return this;
  },
  equals: function (v) {
    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
  },
  fromArray: function (array, offset) {
    if (offset === undefined)
      offset = 0;
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined)
      array = [];
    if (offset === undefined)
      offset = 0;
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  },
  fromAttribute: function (attribute, index, offset) {
    if (offset === undefined)
      offset = 0;
    index = index * attribute.itemSize + offset;
    this.x = attribute.array[index];
    this.y = attribute.array[index + 1];
    this.z = attribute.array[index + 2];
    this.w = attribute.array[index + 3];
    return this;
  }
};
// File:src/math/Euler.js
/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */
THREE.Euler = function (x, y, z, order) {
  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._order = order || THREE.Euler.DefaultOrder;
};
THREE.Euler.RotationOrders = [
  'XYZ',
  'YZX',
  'ZXY',
  'XZY',
  'YXZ',
  'ZYX'
];
THREE.Euler.DefaultOrder = 'XYZ';
THREE.Euler.prototype = {
  constructor: THREE.Euler,
  get x() {
    return this._x;
  },
  set x(value) {
    this._x = value;
    this.onChangeCallback();
  },
  get y() {
    return this._y;
  },
  set y(value) {
    this._y = value;
    this.onChangeCallback();
  },
  get z() {
    return this._z;
  },
  set z(value) {
    this._z = value;
    this.onChangeCallback();
  },
  get order() {
    return this._order;
  },
  set order(value) {
    this._order = value;
    this.onChangeCallback();
  },
  set: function (x, y, z, order) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order || this._order;
    this.onChangeCallback();
    return this;
  },
  clone: function () {
    return new this.constructor(this._x, this._y, this._z, this._order);
  },
  copy: function (euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this.onChangeCallback();
    return this;
  },
  setFromRotationMatrix: function (m, order, update) {
    var clamp = THREE.Math.clamp;
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    var te = m.elements;
    var m11 = te[0], m12 = te[4], m13 = te[8];
    var m21 = te[1], m22 = te[5], m23 = te[9];
    var m31 = te[2], m32 = te[6], m33 = te[10];
    order = order || this._order;
    if (order === 'XYZ') {
      this._y = Math.asin(clamp(m13, -1, 1));
      if (Math.abs(m13) < 0.99999) {
        this._x = Math.atan2(-m23, m33);
        this._z = Math.atan2(-m12, m11);
      } else {
        this._x = Math.atan2(m32, m22);
        this._z = 0;
      }
    } else if (order === 'YXZ') {
      this._x = Math.asin(-clamp(m23, -1, 1));
      if (Math.abs(m23) < 0.99999) {
        this._y = Math.atan2(m13, m33);
        this._z = Math.atan2(m21, m22);
      } else {
        this._y = Math.atan2(-m31, m11);
        this._z = 0;
      }
    } else if (order === 'ZXY') {
      this._x = Math.asin(clamp(m32, -1, 1));
      if (Math.abs(m32) < 0.99999) {
        this._y = Math.atan2(-m31, m33);
        this._z = Math.atan2(-m12, m22);
      } else {
        this._y = 0;
        this._z = Math.atan2(m21, m11);
      }
    } else if (order === 'ZYX') {
      this._y = Math.asin(-clamp(m31, -1, 1));
      if (Math.abs(m31) < 0.99999) {
        this._x = Math.atan2(m32, m33);
        this._z = Math.atan2(m21, m11);
      } else {
        this._x = 0;
        this._z = Math.atan2(-m12, m22);
      }
    } else if (order === 'YZX') {
      this._z = Math.asin(clamp(m21, -1, 1));
      if (Math.abs(m21) < 0.99999) {
        this._x = Math.atan2(-m23, m22);
        this._y = Math.atan2(-m31, m11);
      } else {
        this._x = 0;
        this._y = Math.atan2(m13, m33);
      }
    } else if (order === 'XZY') {
      this._z = Math.asin(-clamp(m12, -1, 1));
      if (Math.abs(m12) < 0.99999) {
        this._x = Math.atan2(m32, m22);
        this._y = Math.atan2(m13, m11);
      } else {
        this._x = Math.atan2(-m23, m33);
        this._y = 0;
      }
    } else {
      console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order);
    }
    this._order = order;
    if (update !== false)
      this.onChangeCallback();
    return this;
  },
  setFromQuaternion: function () {
    var matrix;
    return function (q, order, update) {
      if (matrix === undefined)
        matrix = new THREE.Matrix4();
      matrix.makeRotationFromQuaternion(q);
      this.setFromRotationMatrix(matrix, order, update);
      return this;
    };
  }(),
  setFromVector3: function (v, order) {
    return this.set(v.x, v.y, v.z, order || this._order);
  },
  reorder: function () {
    // WARNING: this discards revolution information -bhouston
    var q = new THREE.Quaternion();
    return function (newOrder) {
      q.setFromEuler(this);
      this.setFromQuaternion(q, newOrder);
    };
  }(),
  equals: function (euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  },
  fromArray: function (array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== undefined)
      this._order = array[3];
    this.onChangeCallback();
    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined)
      array = [];
    if (offset === undefined)
      offset = 0;
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  },
  toVector3: function (optionalResult) {
    if (optionalResult) {
      return optionalResult.set(this._x, this._y, this._z);
    } else {
      return new THREE.Vector3(this._x, this._y, this._z);
    }
  },
  onChange: function (callback) {
    this.onChangeCallback = callback;
    return this;
  },
  onChangeCallback: function () {
  }
};
// File:src/math/Line3.js
/**
 * @author bhouston / http://clara.io
 */
THREE.Line3 = function (start, end) {
  this.start = start !== undefined ? start : new THREE.Vector3();
  this.end = end !== undefined ? end : new THREE.Vector3();
};
THREE.Line3.prototype = {
  constructor: THREE.Line3,
  set: function (start, end) {
    this.start.copy(start);
    this.end.copy(end);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (line) {
    this.start.copy(line.start);
    this.end.copy(line.end);
    return this;
  },
  center: function (optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    return result.addVectors(this.start, this.end).multiplyScalar(0.5);
  },
  delta: function (optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    return result.subVectors(this.end, this.start);
  },
  distanceSq: function () {
    return this.start.distanceToSquared(this.end);
  },
  distance: function () {
    return this.start.distanceTo(this.end);
  },
  at: function (t, optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    return this.delta(result).multiplyScalar(t).add(this.start);
  },
  closestPointToPointParameter: function () {
    var startP = new THREE.Vector3();
    var startEnd = new THREE.Vector3();
    return function (point, clampToLine) {
      startP.subVectors(point, this.start);
      startEnd.subVectors(this.end, this.start);
      var startEnd2 = startEnd.dot(startEnd);
      var startEnd_startP = startEnd.dot(startP);
      var t = startEnd_startP / startEnd2;
      if (clampToLine) {
        t = THREE.Math.clamp(t, 0, 1);
      }
      return t;
    };
  }(),
  closestPointToPoint: function (point, clampToLine, optionalTarget) {
    var t = this.closestPointToPointParameter(point, clampToLine);
    var result = optionalTarget || new THREE.Vector3();
    return this.delta(result).multiplyScalar(t).add(this.start);
  },
  applyMatrix4: function (matrix) {
    this.start.applyMatrix4(matrix);
    this.end.applyMatrix4(matrix);
    return this;
  },
  equals: function (line) {
    return line.start.equals(this.start) && line.end.equals(this.end);
  }
};
// File:src/math/Box2.js
/**
 * @author bhouston / http://clara.io
 */
THREE.Box2 = function (min, max) {
  this.min = min !== undefined ? min : new THREE.Vector2(+Infinity, +Infinity);
  this.max = max !== undefined ? max : new THREE.Vector2(-Infinity, -Infinity);
};
THREE.Box2.prototype = {
  constructor: THREE.Box2,
  set: function (min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  },
  setFromPoints: function (points) {
    this.makeEmpty();
    for (var i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }
    return this;
  },
  setFromCenterAndSize: function () {
    var v1 = new THREE.Vector2();
    return function (center, size) {
      var halfSize = v1.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    };
  }(),
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  },
  makeEmpty: function () {
    this.min.x = this.min.y = +Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  },
  isEmpty: function () {
    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
    return this.max.x < this.min.x || this.max.y < this.min.y;
  },
  center: function (optionalTarget) {
    var result = optionalTarget || new THREE.Vector2();
    return result.addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  size: function (optionalTarget) {
    var result = optionalTarget || new THREE.Vector2();
    return result.subVectors(this.max, this.min);
  },
  expandByPoint: function (point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  },
  expandByVector: function (vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  },
  expandByScalar: function (scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  },
  containsPoint: function (point) {
    if (point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y) {
      return false;
    }
    return true;
  },
  containsBox: function (box) {
    if (this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y) {
      return true;
    }
    return false;
  },
  getParameter: function (point, optionalTarget) {
    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.
    var result = optionalTarget || new THREE.Vector2();
    return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
  },
  intersectsBox: function (box) {
    // using 6 splitting planes to rule out intersections.
    if (box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y) {
      return false;
    }
    return true;
  },
  clampPoint: function (point, optionalTarget) {
    var result = optionalTarget || new THREE.Vector2();
    return result.copy(point).clamp(this.min, this.max);
  },
  distanceToPoint: function () {
    var v1 = new THREE.Vector2();
    return function (point) {
      var clampedPoint = v1.copy(point).clamp(this.min, this.max);
      return clampedPoint.sub(point).length();
    };
  }(),
  intersect: function (box) {
    this.min.max(box.min);
    this.max.min(box.max);
    return this;
  },
  union: function (box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  },
  translate: function (offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  },
  equals: function (box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
};
// File:src/math/Box3.js
/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */
THREE.Box3 = function (min, max) {
  this.min = min !== undefined ? min : new THREE.Vector3(+Infinity, +Infinity, +Infinity);
  this.max = max !== undefined ? max : new THREE.Vector3(-Infinity, -Infinity, -Infinity);
};
THREE.Box3.prototype = {
  constructor: THREE.Box3,
  set: function (min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  },
  setFromArray: function (array) {
    this.makeEmpty();
    var minX = +Infinity;
    var minY = +Infinity;
    var minZ = +Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;
    var maxZ = -Infinity;
    for (var i = 0, il = array.length; i < il; i += 3) {
      var x = array[i];
      var y = array[i + 1];
      var z = array[i + 2];
      if (x < minX)
        minX = x;
      if (y < minY)
        minY = y;
      if (z < minZ)
        minZ = z;
      if (x > maxX)
        maxX = x;
      if (y > maxY)
        maxY = y;
      if (z > maxZ)
        maxZ = z;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
  },
  setFromPoints: function (points) {
    this.makeEmpty();
    for (var i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }
    return this;
  },
  setFromCenterAndSize: function () {
    var v1 = new THREE.Vector3();
    return function (center, size) {
      var halfSize = v1.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    };
  }(),
  setFromObject: function () {
    // Computes the world-axis-aligned bounding box of an object (including its children),
    // accounting for both the object's, and children's, world transforms
    var box;
    return function (object) {
      if (box === undefined)
        box = new THREE.Box3();
      var scope = this;
      this.makeEmpty();
      object.updateMatrixWorld(true);
      object.traverse(function (node) {
        var geometry = node.geometry;
        if (geometry !== undefined) {
          if (geometry.boundingBox === null) {
            geometry.computeBoundingBox();
          }
          if (geometry.boundingBox.isEmpty() === false) {
            box.copy(geometry.boundingBox);
            box.applyMatrix4(node.matrixWorld);
            scope.union(box);
          }
        }
      });
      return this;
    };
  }(),
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  },
  makeEmpty: function () {
    this.min.x = this.min.y = this.min.z = +Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  },
  isEmpty: function () {
    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  },
  center: function (optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    return result.addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  size: function (optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    return result.subVectors(this.max, this.min);
  },
  expandByPoint: function (point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  },
  expandByVector: function (vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  },
  expandByScalar: function (scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  },
  containsPoint: function (point) {
    if (point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z) {
      return false;
    }
    return true;
  },
  containsBox: function (box) {
    if (this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z) {
      return true;
    }
    return false;
  },
  getParameter: function (point, optionalTarget) {
    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.
    var result = optionalTarget || new THREE.Vector3();
    return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
  },
  intersectsBox: function (box) {
    // using 6 splitting planes to rule out intersections.
    if (box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z) {
      return false;
    }
    return true;
  },
  intersectsSphere: function () {
    var closestPoint;
    return function intersectsSphere(sphere) {
      if (closestPoint === undefined)
        closestPoint = new THREE.Vector3();
      // Find the point on the AABB closest to the sphere center.
      this.clampPoint(sphere.center, closestPoint);
      // If that point is inside the sphere, the AABB and sphere intersect.
      return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    };
  }(),
  intersectsPlane: function (plane) {
    // We compute the minimum and maximum dot product values. If those values
    // are on the same side (back or front) of the plane, then there is no intersection.
    var min, max;
    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }
    return min <= plane.constant && max >= plane.constant;
  },
  clampPoint: function (point, optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    return result.copy(point).clamp(this.min, this.max);
  },
  distanceToPoint: function () {
    var v1 = new THREE.Vector3();
    return function (point) {
      var clampedPoint = v1.copy(point).clamp(this.min, this.max);
      return clampedPoint.sub(point).length();
    };
  }(),
  getBoundingSphere: function () {
    var v1 = new THREE.Vector3();
    return function (optionalTarget) {
      var result = optionalTarget || new THREE.Sphere();
      result.center = this.center();
      result.radius = this.size(v1).length() * 0.5;
      return result;
    };
  }(),
  intersect: function (box) {
    this.min.max(box.min);
    this.max.min(box.max);
    return this;
  },
  union: function (box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  },
  applyMatrix4: function () {
    var points = [
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3()
    ];
    return function (matrix) {
      // NOTE: I am using a binary pattern to specify all 2^3 combinations below
      points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
      // 000
      points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
      // 001
      points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
      // 010
      points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
      // 011
      points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
      // 100
      points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
      // 101
      points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
      // 110
      points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
      // 111
      this.makeEmpty();
      this.setFromPoints(points);
      return this;
    };
  }(),
  translate: function (offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  },
  equals: function (box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
};
// File:src/math/Matrix3.js
/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 * @author tschw
 */
THREE.Matrix3 = function () {
  this.elements = new Float32Array([
    1,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    1
  ]);
  if (arguments.length > 0) {
    console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
  }
};
THREE.Matrix3.prototype = {
  constructor: THREE.Matrix3,
  set: function (n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    var te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  },
  identity: function () {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  },
  clone: function () {
    return new this.constructor().fromArray(this.elements);
  },
  copy: function (m) {
    var me = m.elements;
    this.set(me[0], me[3], me[6], me[1], me[4], me[7], me[2], me[5], me[8]);
    return this;
  },
  setFromMatrix4: function (m) {
    var me = m.elements;
    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
    return this;
  },
  applyToVector3Array: function () {
    var v1;
    return function (array, offset, length) {
      if (v1 === undefined)
        v1 = new THREE.Vector3();
      if (offset === undefined)
        offset = 0;
      if (length === undefined)
        length = array.length;
      for (var i = 0, j = offset; i < length; i += 3, j += 3) {
        v1.fromArray(array, j);
        v1.applyMatrix3(this);
        v1.toArray(array, j);
      }
      return array;
    };
  }(),
  applyToBuffer: function () {
    var v1;
    return function applyToBuffer(buffer, offset, length) {
      if (v1 === undefined)
        v1 = new THREE.Vector3();
      if (offset === undefined)
        offset = 0;
      if (length === undefined)
        length = buffer.length / buffer.itemSize;
      for (var i = 0, j = offset; i < length; i++, j++) {
        v1.x = buffer.getX(j);
        v1.y = buffer.getY(j);
        v1.z = buffer.getZ(j);
        v1.applyMatrix3(this);
        buffer.setXYZ(v1.x, v1.y, v1.z);
      }
      return buffer;
    };
  }(),
  multiplyScalar: function (s) {
    var te = this.elements;
    te[0] *= s;
    te[3] *= s;
    te[6] *= s;
    te[1] *= s;
    te[4] *= s;
    te[7] *= s;
    te[2] *= s;
    te[5] *= s;
    te[8] *= s;
    return this;
  },
  determinant: function () {
    var te = this.elements;
    var a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
  },
  getInverse: function (matrix, throwOnDegenerate) {
    if (matrix instanceof THREE.Matrix4) {
      console.warn('THREE.Matrix3.getInverse no longer takes a Matrix4 argument.');
    }
    var me = matrix.elements, te = this.elements, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0) {
      var msg = 'THREE.Matrix3.getInverse(): can\'t invert matrix, determinant is 0';
      if (throwOnDegenerate || false) {
        throw new Error(msg);
      } else {
        console.warn(msg);
      }
      return this.identity();
    }
    te[0] = t11;
    te[1] = n31 * n23 - n33 * n21;
    te[2] = n32 * n21 - n31 * n22;
    te[3] = t12;
    te[4] = n33 * n11 - n31 * n13;
    te[5] = n31 * n12 - n32 * n11;
    te[6] = t13;
    te[7] = n21 * n13 - n23 * n11;
    te[8] = n22 * n11 - n21 * n12;
    return this.multiplyScalar(1 / det);
  },
  transpose: function () {
    var tmp, m = this.elements;
    tmp = m[1];
    m[1] = m[3];
    m[3] = tmp;
    tmp = m[2];
    m[2] = m[6];
    m[6] = tmp;
    tmp = m[5];
    m[5] = m[7];
    m[7] = tmp;
    return this;
  },
  flattenToArrayOffset: function (array, offset) {
    var te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  },
  getNormalMatrix: function (matrix4) {
    return this.setFromMatrix4(matrix4).getInverse(this).transpose();
  },
  transposeIntoArray: function (r) {
    var m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  },
  fromArray: function (array) {
    this.elements.set(array);
    return this;
  },
  toArray: function () {
    var te = this.elements;
    return [
      te[0],
      te[1],
      te[2],
      te[3],
      te[4],
      te[5],
      te[6],
      te[7],
      te[8]
    ];
  }
};
// File:src/math/Matrix4.js
/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */
THREE.Matrix4 = function () {
  this.elements = new Float32Array([
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
  ]);
  if (arguments.length > 0) {
    console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
  }
};
THREE.Matrix4.prototype = {
  constructor: THREE.Matrix4,
  set: function (n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    var te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  },
  identity: function () {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  },
  clone: function () {
    return new THREE.Matrix4().fromArray(this.elements);
  },
  copy: function (m) {
    this.elements.set(m.elements);
    return this;
  },
  copyPosition: function (m) {
    var te = this.elements;
    var me = m.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  },
  extractBasis: function (xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  },
  makeBasis: function (xAxis, yAxis, zAxis) {
    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
    return this;
  },
  extractRotation: function () {
    var v1;
    return function (m) {
      if (v1 === undefined)
        v1 = new THREE.Vector3();
      var te = this.elements;
      var me = m.elements;
      var scaleX = 1 / v1.setFromMatrixColumn(m, 0).length();
      var scaleY = 1 / v1.setFromMatrixColumn(m, 1).length();
      var scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();
      te[0] = me[0] * scaleX;
      te[1] = me[1] * scaleX;
      te[2] = me[2] * scaleX;
      te[4] = me[4] * scaleY;
      te[5] = me[5] * scaleY;
      te[6] = me[6] * scaleY;
      te[8] = me[8] * scaleZ;
      te[9] = me[9] * scaleZ;
      te[10] = me[10] * scaleZ;
      return this;
    };
  }(),
  makeRotationFromEuler: function (euler) {
    if (euler instanceof THREE.Euler === false) {
      console.error('THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
    }
    var te = this.elements;
    var x = euler.x, y = euler.y, z = euler.z;
    var a = Math.cos(x), b = Math.sin(x);
    var c = Math.cos(y), d = Math.sin(y);
    var e = Math.cos(z), f = Math.sin(z);
    if (euler.order === 'XYZ') {
      var ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = -c * f;
      te[8] = d;
      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c;
      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c;
    } else if (euler.order === 'YXZ') {
      var ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c;
    } else if (euler.order === 'ZXY') {
      var ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a * e;
      te[9] = df - ce * b;
      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c;
    } else if (euler.order === 'ZYX') {
      var ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = be * d - af;
      te[8] = ae * d + bf;
      te[1] = c * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;
      te[2] = -d;
      te[6] = b * c;
      te[10] = a * c;
    } else if (euler.order === 'YZX') {
      var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a * e;
      te[9] = -b * e;
      te[2] = -d * e;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === 'XZY') {
      var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = -f;
      te[8] = d * e;
      te[1] = ac * f + bd;
      te[5] = a * e;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e;
      te[10] = bd * f + ac;
    }
    // last column
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    // bottom row
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  },
  makeRotationFromQuaternion: function (q) {
    var te = this.elements;
    var x = q.x, y = q.y, z = q.z, w = q.w;
    var x2 = x + x, y2 = y + y, z2 = z + z;
    var xx = x * x2, xy = x * y2, xz = x * z2;
    var yy = y * y2, yz = y * z2, zz = z * z2;
    var wx = w * x2, wy = w * y2, wz = w * z2;
    te[0] = 1 - (yy + zz);
    te[4] = xy - wz;
    te[8] = xz + wy;
    te[1] = xy + wz;
    te[5] = 1 - (xx + zz);
    te[9] = yz - wx;
    te[2] = xz - wy;
    te[6] = yz + wx;
    te[10] = 1 - (xx + yy);
    // last column
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    // bottom row
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  },
  lookAt: function () {
    var x, y, z;
    return function (eye, target, up) {
      if (x === undefined)
        x = new THREE.Vector3();
      if (y === undefined)
        y = new THREE.Vector3();
      if (z === undefined)
        z = new THREE.Vector3();
      var te = this.elements;
      z.subVectors(eye, target).normalize();
      if (z.lengthSq() === 0) {
        z.z = 1;
      }
      x.crossVectors(up, z).normalize();
      if (x.lengthSq() === 0) {
        z.x += 0.0001;
        x.crossVectors(up, z).normalize();
      }
      y.crossVectors(z, x);
      te[0] = x.x;
      te[4] = y.x;
      te[8] = z.x;
      te[1] = x.y;
      te[5] = y.y;
      te[9] = z.y;
      te[2] = x.z;
      te[6] = y.z;
      te[10] = z.z;
      return this;
    };
  }(),
  multiply: function (m, n) {
    if (n !== undefined) {
      console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
      return this.multiplyMatrices(m, n);
    }
    return this.multiplyMatrices(this, m);
  },
  multiplyMatrices: function (a, b) {
    var ae = a.elements;
    var be = b.elements;
    var te = this.elements;
    var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  },
  multiplyToArray: function (a, b, r) {
    var te = this.elements;
    this.multiplyMatrices(a, b);
    r[0] = te[0];
    r[1] = te[1];
    r[2] = te[2];
    r[3] = te[3];
    r[4] = te[4];
    r[5] = te[5];
    r[6] = te[6];
    r[7] = te[7];
    r[8] = te[8];
    r[9] = te[9];
    r[10] = te[10];
    r[11] = te[11];
    r[12] = te[12];
    r[13] = te[13];
    r[14] = te[14];
    r[15] = te[15];
    return this;
  },
  multiplyScalar: function (s) {
    var te = this.elements;
    te[0] *= s;
    te[4] *= s;
    te[8] *= s;
    te[12] *= s;
    te[1] *= s;
    te[5] *= s;
    te[9] *= s;
    te[13] *= s;
    te[2] *= s;
    te[6] *= s;
    te[10] *= s;
    te[14] *= s;
    te[3] *= s;
    te[7] *= s;
    te[11] *= s;
    te[15] *= s;
    return this;
  },
  applyToVector3Array: function () {
    var v1;
    return function (array, offset, length) {
      if (v1 === undefined)
        v1 = new THREE.Vector3();
      if (offset === undefined)
        offset = 0;
      if (length === undefined)
        length = array.length;
      for (var i = 0, j = offset; i < length; i += 3, j += 3) {
        v1.fromArray(array, j);
        v1.applyMatrix4(this);
        v1.toArray(array, j);
      }
      return array;
    };
  }(),
  applyToBuffer: function () {
    var v1;
    return function applyToBuffer(buffer, offset, length) {
      if (v1 === undefined)
        v1 = new THREE.Vector3();
      if (offset === undefined)
        offset = 0;
      if (length === undefined)
        length = buffer.length / buffer.itemSize;
      for (var i = 0, j = offset; i < length; i++, j++) {
        v1.x = buffer.getX(j);
        v1.y = buffer.getY(j);
        v1.z = buffer.getZ(j);
        v1.applyMatrix4(this);
        buffer.setXYZ(v1.x, v1.y, v1.z);
      }
      return buffer;
    };
  }(),
  determinant: function () {
    var te = this.elements;
    var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    //TODO: make this more efficient
    //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  },
  transpose: function () {
    var te = this.elements;
    var tmp;
    tmp = te[1];
    te[1] = te[4];
    te[4] = tmp;
    tmp = te[2];
    te[2] = te[8];
    te[8] = tmp;
    tmp = te[6];
    te[6] = te[9];
    te[9] = tmp;
    tmp = te[3];
    te[3] = te[12];
    te[12] = tmp;
    tmp = te[7];
    te[7] = te[13];
    te[13] = tmp;
    tmp = te[11];
    te[11] = te[14];
    te[14] = tmp;
    return this;
  },
  flattenToArrayOffset: function (array, offset) {
    var te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  },
  getPosition: function () {
    var v1;
    return function () {
      if (v1 === undefined)
        v1 = new THREE.Vector3();
      console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
      return v1.setFromMatrixColumn(this, 3);
    };
  }(),
  setPosition: function (v) {
    var te = this.elements;
    te[12] = v.x;
    te[13] = v.y;
    te[14] = v.z;
    return this;
  },
  getInverse: function (m, throwOnDegenerate) {
    // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
    var te = this.elements, me = m.elements, n11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3], n12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7], n13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11], n14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0) {
      var msg = 'THREE.Matrix4.getInverse(): can\'t invert matrix, determinant is 0';
      if (throwOnDegenerate || false) {
        throw new Error(msg);
      } else {
        console.warn(msg);
      }
      return this.identity();
    }
    te[0] = t11;
    te[1] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
    te[2] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
    te[3] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
    te[4] = t12;
    te[5] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
    te[6] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
    te[7] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
    te[8] = t13;
    te[9] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
    te[10] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
    te[11] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
    te[12] = t14;
    te[13] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
    te[14] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
    te[15] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;
    return this.multiplyScalar(1 / det);
  },
  scale: function (v) {
    var te = this.elements;
    var x = v.x, y = v.y, z = v.z;
    te[0] *= x;
    te[4] *= y;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y;
    te[11] *= z;
    return this;
  },
  getMaxScaleOnAxis: function () {
    var te = this.elements;
    var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  },
  makeTranslation: function (x, y, z) {
    this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
    return this;
  },
  makeRotationX: function (theta) {
    var c = Math.cos(theta), s = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationY: function (theta) {
    var c = Math.cos(theta), s = Math.sin(theta);
    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationZ: function (theta) {
    var c = Math.cos(theta), s = Math.sin(theta);
    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationAxis: function (axis, angle) {
    // Based on http://www.gamedev.net/reference/articles/article1199.asp
    var c = Math.cos(angle);
    var s = Math.sin(angle);
    var t = 1 - c;
    var x = axis.x, y = axis.y, z = axis.z;
    var tx = t * x, ty = t * y;
    this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
    return this;
  },
  makeScale: function (x, y, z) {
    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
    return this;
  },
  compose: function (position, quaternion, scale) {
    this.makeRotationFromQuaternion(quaternion);
    this.scale(scale);
    this.setPosition(position);
    return this;
  },
  decompose: function () {
    var vector, matrix;
    return function (position, quaternion, scale) {
      if (vector === undefined)
        vector = new THREE.Vector3();
      if (matrix === undefined)
        matrix = new THREE.Matrix4();
      var te = this.elements;
      var sx = vector.set(te[0], te[1], te[2]).length();
      var sy = vector.set(te[4], te[5], te[6]).length();
      var sz = vector.set(te[8], te[9], te[10]).length();
      // if determine is negative, we need to invert one scale
      var det = this.determinant();
      if (det < 0) {
        sx = -sx;
      }
      position.x = te[12];
      position.y = te[13];
      position.z = te[14];
      // scale the rotation part
      matrix.elements.set(this.elements);
      // at this point matrix is incomplete so we can't use .copy()
      var invSX = 1 / sx;
      var invSY = 1 / sy;
      var invSZ = 1 / sz;
      matrix.elements[0] *= invSX;
      matrix.elements[1] *= invSX;
      matrix.elements[2] *= invSX;
      matrix.elements[4] *= invSY;
      matrix.elements[5] *= invSY;
      matrix.elements[6] *= invSY;
      matrix.elements[8] *= invSZ;
      matrix.elements[9] *= invSZ;
      matrix.elements[10] *= invSZ;
      quaternion.setFromRotationMatrix(matrix);
      scale.x = sx;
      scale.y = sy;
      scale.z = sz;
      return this;
    };
  }(),
  makeFrustum: function (left, right, bottom, top, near, far) {
    var te = this.elements;
    var x = 2 * near / (right - left);
    var y = 2 * near / (top - bottom);
    var a = (right + left) / (right - left);
    var b = (top + bottom) / (top - bottom);
    var c = -(far + near) / (far - near);
    var d = -2 * far * near / (far - near);
    te[0] = x;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  },
  makePerspective: function (fov, aspect, near, far) {
    var ymax = near * Math.tan(THREE.Math.degToRad(fov * 0.5));
    var ymin = -ymax;
    var xmin = ymin * aspect;
    var xmax = ymax * aspect;
    return this.makeFrustum(xmin, xmax, ymin, ymax, near, far);
  },
  makeOrthographic: function (left, right, top, bottom, near, far) {
    var te = this.elements;
    var w = 1 / (right - left);
    var h = 1 / (top - bottom);
    var p = 1 / (far - near);
    var x = (right + left) * w;
    var y = (top + bottom) * h;
    var z = (far + near) * p;
    te[0] = 2 * w;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x;
    te[1] = 0;
    te[5] = 2 * h;
    te[9] = 0;
    te[13] = -y;
    te[2] = 0;
    te[6] = 0;
    te[10] = -2 * p;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  },
  equals: function (matrix) {
    var te = this.elements;
    var me = matrix.elements;
    for (var i = 0; i < 16; i++) {
      if (te[i] !== me[i])
        return false;
    }
    return true;
  },
  fromArray: function (array) {
    this.elements.set(array);
    return this;
  },
  toArray: function () {
    var te = this.elements;
    return [
      te[0],
      te[1],
      te[2],
      te[3],
      te[4],
      te[5],
      te[6],
      te[7],
      te[8],
      te[9],
      te[10],
      te[11],
      te[12],
      te[13],
      te[14],
      te[15]
    ];
  }
};
// File:src/math/Ray.js
/**
 * @author bhouston / http://clara.io
 */
THREE.Ray = function (origin, direction) {
  this.origin = origin !== undefined ? origin : new THREE.Vector3();
  this.direction = direction !== undefined ? direction : new THREE.Vector3();
};
THREE.Ray.prototype = {
  constructor: THREE.Ray,
  set: function (origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  },
  at: function (t, optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    return result.copy(this.direction).multiplyScalar(t).add(this.origin);
  },
  lookAt: function (v) {
    this.direction.copy(v).sub(this.origin).normalize();
  },
  recast: function () {
    var v1 = new THREE.Vector3();
    return function (t) {
      this.origin.copy(this.at(t, v1));
      return this;
    };
  }(),
  closestPointToPoint: function (point, optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    result.subVectors(point, this.origin);
    var directionDistance = result.dot(this.direction);
    if (directionDistance < 0) {
      return result.copy(this.origin);
    }
    return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
  },
  distanceToPoint: function (point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  },
  distanceSqToPoint: function () {
    var v1 = new THREE.Vector3();
    return function (point) {
      var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
      // point behind the ray
      if (directionDistance < 0) {
        return this.origin.distanceToSquared(point);
      }
      v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
      return v1.distanceToSquared(point);
    };
  }(),
  distanceSqToSegment: function () {
    var segCenter = new THREE.Vector3();
    var segDir = new THREE.Vector3();
    var diff = new THREE.Vector3();
    return function (v0, v1, optionalPointOnRay, optionalPointOnSegment) {
      // from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
      // It returns the min distance between the ray and the segment
      // defined by v0 and v1
      // It can also set two optional targets :
      // - The closest point on the ray
      // - The closest point on the segment
      segCenter.copy(v0).add(v1).multiplyScalar(0.5);
      segDir.copy(v1).sub(v0).normalize();
      diff.copy(this.origin).sub(segCenter);
      var segExtent = v0.distanceTo(v1) * 0.5;
      var a01 = -this.direction.dot(segDir);
      var b0 = diff.dot(this.direction);
      var b1 = -diff.dot(segDir);
      var c = diff.lengthSq();
      var det = Math.abs(1 - a01 * a01);
      var s0, s1, sqrDist, extDet;
      if (det > 0) {
        // The ray and segment are not parallel.
        s0 = a01 * b1 - b0;
        s1 = a01 * b0 - b1;
        extDet = segExtent * det;
        if (s0 >= 0) {
          if (s1 >= -extDet) {
            if (s1 <= extDet) {
              // region 0
              // Minimum at interior points of ray and segment.
              var invDet = 1 / det;
              s0 *= invDet;
              s1 *= invDet;
              sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
            } else {
              // region 1
              s1 = segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          } else {
            // region 5
            s1 = -segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          if (s1 <= -extDet) {
            // region 4
            s0 = Math.max(0, -(-a01 * segExtent + b0));
            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          } else if (s1 <= extDet) {
            // region 3
            s0 = 0;
            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = s1 * (s1 + 2 * b1) + c;
          } else {
            // region 2
            s0 = Math.max(0, -(a01 * segExtent + b0));
            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        }
      } else {
        // Ray and segment are parallel.
        s1 = a01 > 0 ? -segExtent : segExtent;
        s0 = Math.max(0, -(a01 * s1 + b0));
        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
      }
      if (optionalPointOnRay) {
        optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
      }
      if (optionalPointOnSegment) {
        optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);
      }
      return sqrDist;
    };
  }(),
  intersectSphere: function () {
    var v1 = new THREE.Vector3();
    return function (sphere, optionalTarget) {
      v1.subVectors(sphere.center, this.origin);
      var tca = v1.dot(this.direction);
      var d2 = v1.dot(v1) - tca * tca;
      var radius2 = sphere.radius * sphere.radius;
      if (d2 > radius2)
        return null;
      var thc = Math.sqrt(radius2 - d2);
      // t0 = first intersect point - entrance on front of sphere
      var t0 = tca - thc;
      // t1 = second intersect point - exit point on back of sphere
      var t1 = tca + thc;
      // test to see if both t0 and t1 are behind the ray - if so, return null
      if (t0 < 0 && t1 < 0)
        return null;
      // test to see if t0 is behind the ray:
      // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
      // in order to always return an intersect point that is in front of the ray.
      if (t0 < 0)
        return this.at(t1, optionalTarget);
      // else t0 is in front of the ray, so return the first collision point scaled by t0
      return this.at(t0, optionalTarget);
    };
  }(),
  intersectsSphere: function (sphere) {
    return this.distanceToPoint(sphere.center) <= sphere.radius;
  },
  distanceToPlane: function (plane) {
    var denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      // line is coplanar, return origin
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      // Null is preferable to undefined since undefined means.... it is undefined
      return null;
    }
    var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    // Return if the ray never intersects the plane
    return t >= 0 ? t : null;
  },
  intersectPlane: function (plane, optionalTarget) {
    var t = this.distanceToPlane(plane);
    if (t === null) {
      return null;
    }
    return this.at(t, optionalTarget);
  },
  intersectsPlane: function (plane) {
    // check if the ray lies on the plane first
    var distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    var denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    // ray origin is behind the plane (and is pointing behind it)
    return false;
  },
  intersectBox: function (box, optionalTarget) {
    var tmin, tmax, tymin, tymax, tzmin, tzmax;
    var invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    var origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax)
      return null;
    // These lines also handle the case where tmin or tmax is NaN
    // (result of 0 * Infinity). x !== x returns true if x is NaN
    if (tymin > tmin || tmin !== tmin)
      tmin = tymin;
    if (tymax < tmax || tmax !== tmax)
      tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax)
      return null;
    if (tzmin > tmin || tmin !== tmin)
      tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax)
      tmax = tzmax;
    //return point closest to the ray (positive side)
    if (tmax < 0)
      return null;
    return this.at(tmin >= 0 ? tmin : tmax, optionalTarget);
  },
  intersectsBox: function () {
    var v = new THREE.Vector3();
    return function (box) {
      return this.intersectBox(box, v) !== null;
    };
  }(),
  intersectTriangle: function () {
    // Compute the offset origin, edges, and normal.
    var diff = new THREE.Vector3();
    var edge1 = new THREE.Vector3();
    var edge2 = new THREE.Vector3();
    var normal = new THREE.Vector3();
    return function (a, b, c, backfaceCulling, optionalTarget) {
      // from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp
      edge1.subVectors(b, a);
      edge2.subVectors(c, a);
      normal.crossVectors(edge1, edge2);
      // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
      // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
      //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
      //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
      //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
      var DdN = this.direction.dot(normal);
      var sign;
      if (DdN > 0) {
        if (backfaceCulling)
          return null;
        sign = 1;
      } else if (DdN < 0) {
        sign = -1;
        DdN = -DdN;
      } else {
        return null;
      }
      diff.subVectors(this.origin, a);
      var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
      // b1 < 0, no intersection
      if (DdQxE2 < 0) {
        return null;
      }
      var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
      // b2 < 0, no intersection
      if (DdE1xQ < 0) {
        return null;
      }
      // b1+b2 > 1, no intersection
      if (DdQxE2 + DdE1xQ > DdN) {
        return null;
      }
      // Line intersects triangle, check if ray does.
      var QdN = -sign * diff.dot(normal);
      // t < 0, no intersection
      if (QdN < 0) {
        return null;
      }
      // Ray intersects triangle.
      return this.at(QdN / DdN, optionalTarget);
    };
  }(),
  applyMatrix4: function (matrix4) {
    this.direction.add(this.origin).applyMatrix4(matrix4);
    this.origin.applyMatrix4(matrix4);
    this.direction.sub(this.origin);
    this.direction.normalize();
    return this;
  },
  equals: function (ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
};
// File:src/math/Sphere.js
/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */
THREE.Sphere = function (center, radius) {
  this.center = center !== undefined ? center : new THREE.Vector3();
  this.radius = radius !== undefined ? radius : 0;
};
THREE.Sphere.prototype = {
  constructor: THREE.Sphere,
  set: function (center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  },
  setFromPoints: function () {
    var box = new THREE.Box3();
    return function (points, optionalCenter) {
      var center = this.center;
      if (optionalCenter !== undefined) {
        center.copy(optionalCenter);
      } else {
        box.setFromPoints(points).center(center);
      }
      var maxRadiusSq = 0;
      for (var i = 0, il = points.length; i < il; i++) {
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
      }
      this.radius = Math.sqrt(maxRadiusSq);
      return this;
    };
  }(),
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  },
  empty: function () {
    return this.radius <= 0;
  },
  containsPoint: function (point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  },
  distanceToPoint: function (point) {
    return point.distanceTo(this.center) - this.radius;
  },
  intersectsSphere: function (sphere) {
    var radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  },
  intersectsBox: function (box) {
    return box.intersectsSphere(this);
  },
  intersectsPlane: function (plane) {
    // We use the following equation to compute the signed distance from
    // the center of the sphere to the plane.
    //
    // distance = q * n - d
    //
    // If this distance is greater than the radius of the sphere,
    // then there is no intersection.
    return Math.abs(this.center.dot(plane.normal) - plane.constant) <= this.radius;
  },
  clampPoint: function (point, optionalTarget) {
    var deltaLengthSq = this.center.distanceToSquared(point);
    var result = optionalTarget || new THREE.Vector3();
    result.copy(point);
    if (deltaLengthSq > this.radius * this.radius) {
      result.sub(this.center).normalize();
      result.multiplyScalar(this.radius).add(this.center);
    }
    return result;
  },
  getBoundingBox: function (optionalTarget) {
    var box = optionalTarget || new THREE.Box3();
    box.set(this.center, this.center);
    box.expandByScalar(this.radius);
    return box;
  },
  applyMatrix4: function (matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  },
  translate: function (offset) {
    this.center.add(offset);
    return this;
  },
  equals: function (sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
};
// File:src/math/Frustum.js
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://clara.io
 */
THREE.Frustum = function (p0, p1, p2, p3, p4, p5) {
  this.planes = [
    p0 !== undefined ? p0 : new THREE.Plane(),
    p1 !== undefined ? p1 : new THREE.Plane(),
    p2 !== undefined ? p2 : new THREE.Plane(),
    p3 !== undefined ? p3 : new THREE.Plane(),
    p4 !== undefined ? p4 : new THREE.Plane(),
    p5 !== undefined ? p5 : new THREE.Plane()
  ];
};
THREE.Frustum.prototype = {
  constructor: THREE.Frustum,
  set: function (p0, p1, p2, p3, p4, p5) {
    var planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (frustum) {
    var planes = this.planes;
    for (var i = 0; i < 6; i++) {
      planes[i].copy(frustum.planes[i]);
    }
    return this;
  },
  setFromMatrix: function (m) {
    var planes = this.planes;
    var me = m.elements;
    var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
    var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
    var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
    var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    return this;
  },
  intersectsObject: function () {
    var sphere = new THREE.Sphere();
    return function (object) {
      var geometry = object.geometry;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      sphere.copy(geometry.boundingSphere);
      sphere.applyMatrix4(object.matrixWorld);
      return this.intersectsSphere(sphere);
    };
  }(),
  intersectsSphere: function (sphere) {
    var planes = this.planes;
    var center = sphere.center;
    var negRadius = -sphere.radius;
    for (var i = 0; i < 6; i++) {
      var distance = planes[i].distanceToPoint(center);
      if (distance < negRadius) {
        return false;
      }
    }
    return true;
  },
  intersectsBox: function () {
    var p1 = new THREE.Vector3(), p2 = new THREE.Vector3();
    return function (box) {
      var planes = this.planes;
      for (var i = 0; i < 6; i++) {
        var plane = planes[i];
        p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
        p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
        p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
        p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
        p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
        p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
        var d1 = plane.distanceToPoint(p1);
        var d2 = plane.distanceToPoint(p2);
        // if both outside plane, no intersection
        if (d1 < 0 && d2 < 0) {
          return false;
        }
      }
      return true;
    };
  }(),
  containsPoint: function (point) {
    var planes = this.planes;
    for (var i = 0; i < 6; i++) {
      if (planes[i].distanceToPoint(point) < 0) {
        return false;
      }
    }
    return true;
  }
};
// File:src/math/Plane.js
/**
 * @author bhouston / http://clara.io
 */
THREE.Plane = function (normal, constant) {
  this.normal = normal !== undefined ? normal : new THREE.Vector3(1, 0, 0);
  this.constant = constant !== undefined ? constant : 0;
};
THREE.Plane.prototype = {
  constructor: THREE.Plane,
  set: function (normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  },
  setComponents: function (x, y, z, w) {
    this.normal.set(x, y, z);
    this.constant = w;
    return this;
  },
  setFromNormalAndCoplanarPoint: function (normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    // must be this.normal, not normal, as this.normal is normalized
    return this;
  },
  setFromCoplanarPoints: function () {
    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    return function (a, b, c) {
      var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
      // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
      this.setFromNormalAndCoplanarPoint(normal, a);
      return this;
    };
  }(),
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  },
  normalize: function () {
    // Note: will lead to a divide by zero if the plane is invalid.
    var inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  },
  negate: function () {
    this.constant *= -1;
    this.normal.negate();
    return this;
  },
  distanceToPoint: function (point) {
    return this.normal.dot(point) + this.constant;
  },
  distanceToSphere: function (sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  },
  projectPoint: function (point, optionalTarget) {
    return this.orthoPoint(point, optionalTarget).sub(point).negate();
  },
  orthoPoint: function (point, optionalTarget) {
    var perpendicularMagnitude = this.distanceToPoint(point);
    var result = optionalTarget || new THREE.Vector3();
    return result.copy(this.normal).multiplyScalar(perpendicularMagnitude);
  },
  intersectLine: function () {
    var v1 = new THREE.Vector3();
    return function (line, optionalTarget) {
      var result = optionalTarget || new THREE.Vector3();
      var direction = line.delta(v1);
      var denominator = this.normal.dot(direction);
      if (denominator === 0) {
        // line is coplanar, return origin
        if (this.distanceToPoint(line.start) === 0) {
          return result.copy(line.start);
        }
        // Unsure if this is the correct method to handle this case.
        return undefined;
      }
      var t = -(line.start.dot(this.normal) + this.constant) / denominator;
      if (t < 0 || t > 1) {
        return undefined;
      }
      return result.copy(direction).multiplyScalar(t).add(line.start);
    };
  }(),
  intersectsLine: function (line) {
    // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
    var startSign = this.distanceToPoint(line.start);
    var endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  },
  intersectsBox: function (box) {
    return box.intersectsPlane(this);
  },
  intersectsSphere: function (sphere) {
    return sphere.intersectsPlane(this);
  },
  coplanarPoint: function (optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    return result.copy(this.normal).multiplyScalar(-this.constant);
  },
  applyMatrix4: function () {
    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    var m1 = new THREE.Matrix3();
    return function (matrix, optionalNormalMatrix) {
      // compute new normal based on theory here:
      // http://www.songho.ca/opengl/gl_normaltransform.html
      var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);
      var newNormal = v1.copy(this.normal).applyMatrix3(normalMatrix);
      var newCoplanarPoint = this.coplanarPoint(v2);
      newCoplanarPoint.applyMatrix4(matrix);
      this.setFromNormalAndCoplanarPoint(newNormal, newCoplanarPoint);
      return this;
    };
  }(),
  translate: function (offset) {
    this.constant = this.constant - offset.dot(this.normal);
    return this;
  },
  equals: function (plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
};
// File:src/math/Spherical.js
/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The poles (phi) are at the positive and negative y axis.
 * The equator starts at positive z.
 */
THREE.Spherical = function (radius, phi, theta) {
  this.radius = radius !== undefined ? radius : 1;
  this.phi = phi !== undefined ? phi : 0;
  // up / down towards top and bottom pole
  this.theta = theta !== undefined ? theta : 0;
  // around the equator of the sphere
  return this;
};
THREE.Spherical.prototype = {
  constructor: THREE.Spherical,
  set: function (radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (other) {
    this.radius.copy(other.radius);
    this.phi.copy(other.phi);
    this.theta.copy(other.theta);
    return this;
  },
  // restrict phi to be betwee EPS and PI-EPS
  makeSafe: function () {
    var EPS = 0.000001;
    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
  },
  setFromVector3: function (vec3) {
    this.radius = vec3.length();
    if (this.radius === 0) {
      this.theta = 0;
      this.phi = 0;
    } else {
      this.theta = Math.atan2(vec3.x, vec3.z);
      // equator angle around y-up axis
      this.phi = Math.acos(THREE.Math.clamp(vec3.y / this.radius, -1, 1));  // polar angle
    }
    return this;
  }
};
// File:src/math/Math.js
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */
THREE.Math = {
  generateUUID: function () {
    // http://www.broofa.com/Tools/Math.uuid.htm
    var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
    var uuid = new Array(36);
    var rnd = 0, r;
    return function () {
      for (var i = 0; i < 36; i++) {
        if (i === 8 || i === 13 || i === 18 || i === 23) {
          uuid[i] = '-';
        } else if (i === 14) {
          uuid[i] = '4';
        } else {
          if (rnd <= 2)
            rnd = 33554432 + Math.random() * 16777216 | 0;
          r = rnd & 15;
          rnd = rnd >> 4;
          uuid[i] = chars[i === 19 ? r & 3 | 8 : r];
        }
      }
      return uuid.join('');
    };
  }(),
  clamp: function (value, min, max) {
    return Math.max(min, Math.min(max, value));
  },
  // compute euclidian modulo of m % n
  // https://en.wikipedia.org/wiki/Modulo_operation
  euclideanModulo: function (n, m) {
    return (n % m + m) % m;
  },
  // Linear mapping from range <a1, a2> to range <b1, b2>
  mapLinear: function (x, a1, a2, b1, b2) {
    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
  },
  // http://en.wikipedia.org/wiki/Smoothstep
  smoothstep: function (x, min, max) {
    if (x <= min)
      return 0;
    if (x >= max)
      return 1;
    x = (x - min) / (max - min);
    return x * x * (3 - 2 * x);
  },
  smootherstep: function (x, min, max) {
    if (x <= min)
      return 0;
    if (x >= max)
      return 1;
    x = (x - min) / (max - min);
    return x * x * x * (x * (x * 6 - 15) + 10);
  },
  random16: function () {
    console.warn('THREE.Math.random16() has been deprecated. Use Math.random() instead.');
    return Math.random();
  },
  // Random integer from <low, high> interval
  randInt: function (low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
  },
  // Random float from <low, high> interval
  randFloat: function (low, high) {
    return low + Math.random() * (high - low);
  },
  // Random float from <-range/2, range/2> interval
  randFloatSpread: function (range) {
    return range * (0.5 - Math.random());
  },
  degToRad: function () {
    var degreeToRadiansFactor = Math.PI / 180;
    return function (degrees) {
      return degrees * degreeToRadiansFactor;
    };
  }(),
  radToDeg: function () {
    var radianToDegreesFactor = 180 / Math.PI;
    return function (radians) {
      return radians * radianToDegreesFactor;
    };
  }(),
  isPowerOfTwo: function (value) {
    return (value & value - 1) === 0 && value !== 0;
  },
  nearestPowerOfTwo: function (value) {
    return Math.pow(2, Math.round(Math.log(value) / Math.LN2));
  },
  nextPowerOfTwo: function (value) {
    value--;
    value |= value >> 1;
    value |= value >> 2;
    value |= value >> 4;
    value |= value >> 8;
    value |= value >> 16;
    value++;
    return value;
  }
};
// File:src/math/Spline.js
/**
 * Spline from Tween.js, slightly optimized (and trashed)
 * http://sole.github.com/tween.js/examples/05_spline.html
 *
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */
THREE.Spline = function (points) {
  this.points = points;
  var c = [], v3 = {
      x: 0,
      y: 0,
      z: 0
    }, point, intPoint, weight, w2, w3, pa, pb, pc, pd;
  this.initFromArray = function (a) {
    this.points = [];
    for (var i = 0; i < a.length; i++) {
      this.points[i] = {
        x: a[i][0],
        y: a[i][1],
        z: a[i][2]
      };
    }
  };
  this.getPoint = function (k) {
    point = (this.points.length - 1) * k;
    intPoint = Math.floor(point);
    weight = point - intPoint;
    c[0] = intPoint === 0 ? intPoint : intPoint - 1;
    c[1] = intPoint;
    c[2] = intPoint > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
    c[3] = intPoint > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;
    pa = this.points[c[0]];
    pb = this.points[c[1]];
    pc = this.points[c[2]];
    pd = this.points[c[3]];
    w2 = weight * weight;
    w3 = weight * w2;
    v3.x = interpolate(pa.x, pb.x, pc.x, pd.x, weight, w2, w3);
    v3.y = interpolate(pa.y, pb.y, pc.y, pd.y, weight, w2, w3);
    v3.z = interpolate(pa.z, pb.z, pc.z, pd.z, weight, w2, w3);
    return v3;
  };
  this.getControlPointsArray = function () {
    var i, p, l = this.points.length, coords = [];
    for (i = 0; i < l; i++) {
      p = this.points[i];
      coords[i] = [
        p.x,
        p.y,
        p.z
      ];
    }
    return coords;
  };
  // approximate length by summing linear segments
  this.getLength = function (nSubDivisions) {
    var i, index, nSamples, position, point = 0, intPoint = 0, oldIntPoint = 0, oldPosition = new THREE.Vector3(), tmpVec = new THREE.Vector3(), chunkLengths = [], totalLength = 0;
    // first point has 0 length
    chunkLengths[0] = 0;
    if (!nSubDivisions)
      nSubDivisions = 100;
    nSamples = this.points.length * nSubDivisions;
    oldPosition.copy(this.points[0]);
    for (i = 1; i < nSamples; i++) {
      index = i / nSamples;
      position = this.getPoint(index);
      tmpVec.copy(position);
      totalLength += tmpVec.distanceTo(oldPosition);
      oldPosition.copy(position);
      point = (this.points.length - 1) * index;
      intPoint = Math.floor(point);
      if (intPoint !== oldIntPoint) {
        chunkLengths[intPoint] = totalLength;
        oldIntPoint = intPoint;
      }
    }
    // last point ends with total length
    chunkLengths[chunkLengths.length] = totalLength;
    return {
      chunks: chunkLengths,
      total: totalLength
    };
  };
  this.reparametrizeByArcLength = function (samplingCoef) {
    var i, j, index, indexCurrent, indexNext, realDistance, sampling, position, newpoints = [], tmpVec = new THREE.Vector3(), sl = this.getLength();
    newpoints.push(tmpVec.copy(this.points[0]).clone());
    for (i = 1; i < this.points.length; i++) {
      //tmpVec.copy( this.points[ i - 1 ] );
      //linearDistance = tmpVec.distanceTo( this.points[ i ] );
      realDistance = sl.chunks[i] - sl.chunks[i - 1];
      sampling = Math.ceil(samplingCoef * realDistance / sl.total);
      indexCurrent = (i - 1) / (this.points.length - 1);
      indexNext = i / (this.points.length - 1);
      for (j = 1; j < sampling - 1; j++) {
        index = indexCurrent + j * (1 / sampling) * (indexNext - indexCurrent);
        position = this.getPoint(index);
        newpoints.push(tmpVec.copy(position).clone());
      }
      newpoints.push(tmpVec.copy(this.points[i]).clone());
    }
    this.points = newpoints;
  };
  // Catmull-Rom
  function interpolate(p0, p1, p2, p3, t, t2, t3) {
    var v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5;
    return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
  }
};
// File:src/math/Triangle.js
/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */
THREE.Triangle = function (a, b, c) {
  this.a = a !== undefined ? a : new THREE.Vector3();
  this.b = b !== undefined ? b : new THREE.Vector3();
  this.c = c !== undefined ? c : new THREE.Vector3();
};
THREE.Triangle.normal = function () {
  var v0 = new THREE.Vector3();
  return function (a, b, c, optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    result.subVectors(c, b);
    v0.subVectors(a, b);
    result.cross(v0);
    var resultLengthSq = result.lengthSq();
    if (resultLengthSq > 0) {
      return result.multiplyScalar(1 / Math.sqrt(resultLengthSq));
    }
    return result.set(0, 0, 0);
  };
}();
// static/instance method to calculate barycentric coordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
THREE.Triangle.barycoordFromPoint = function () {
  var v0 = new THREE.Vector3();
  var v1 = new THREE.Vector3();
  var v2 = new THREE.Vector3();
  return function (point, a, b, c, optionalTarget) {
    v0.subVectors(c, a);
    v1.subVectors(b, a);
    v2.subVectors(point, a);
    var dot00 = v0.dot(v0);
    var dot01 = v0.dot(v1);
    var dot02 = v0.dot(v2);
    var dot11 = v1.dot(v1);
    var dot12 = v1.dot(v2);
    var denom = dot00 * dot11 - dot01 * dot01;
    var result = optionalTarget || new THREE.Vector3();
    // collinear or singular triangle
    if (denom === 0) {
      // arbitrary location outside of triangle?
      // not sure if this is the best idea, maybe should be returning undefined
      return result.set(-2, -1, -1);
    }
    var invDenom = 1 / denom;
    var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    // barycentric coordinates must always sum to 1
    return result.set(1 - u - v, v, u);
  };
}();
THREE.Triangle.containsPoint = function () {
  var v1 = new THREE.Vector3();
  return function (point, a, b, c) {
    var result = THREE.Triangle.barycoordFromPoint(point, a, b, c, v1);
    return result.x >= 0 && result.y >= 0 && result.x + result.y <= 1;
  };
}();
THREE.Triangle.prototype = {
  constructor: THREE.Triangle,
  set: function (a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  },
  setFromPointsAndIndices: function (points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  },
  area: function () {
    var v0 = new THREE.Vector3();
    var v1 = new THREE.Vector3();
    return function () {
      v0.subVectors(this.c, this.b);
      v1.subVectors(this.a, this.b);
      return v0.cross(v1).length() * 0.5;
    };
  }(),
  midpoint: function (optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    return result.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  },
  normal: function (optionalTarget) {
    return THREE.Triangle.normal(this.a, this.b, this.c, optionalTarget);
  },
  plane: function (optionalTarget) {
    var result = optionalTarget || new THREE.Plane();
    return result.setFromCoplanarPoints(this.a, this.b, this.c);
  },
  barycoordFromPoint: function (point, optionalTarget) {
    return THREE.Triangle.barycoordFromPoint(point, this.a, this.b, this.c, optionalTarget);
  },
  containsPoint: function (point) {
    return THREE.Triangle.containsPoint(point, this.a, this.b, this.c);
  },
  equals: function (triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
};
// File:src/core/Clock.js
/**
 * @author alteredq / http://alteredqualia.com/
 */
THREE.Clock = function (autoStart) {
  this.autoStart = autoStart !== undefined ? autoStart : true;
  this.startTime = 0;
  this.oldTime = 0;
  this.elapsedTime = 0;
  this.running = false;
};
THREE.Clock.prototype = {
  constructor: THREE.Clock,
  start: function () {
    this.startTime = performance.now();
    this.oldTime = this.startTime;
    this.running = true;
  },
  stop: function () {
    this.getElapsedTime();
    this.running = false;
  },
  getElapsedTime: function () {
    this.getDelta();
    return this.elapsedTime;
  },
  getDelta: function () {
    var diff = 0;
    if (this.autoStart && !this.running) {
      this.start();
    }
    if (this.running) {
      var newTime = performance.now();
      diff = 0.001 * (newTime - this.oldTime);
      this.oldTime = newTime;
      this.elapsedTime += diff;
    }
    return diff;
  }
};
// File:src/core/EventDispatcher.js
/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */
THREE.EventDispatcher = function () {
};
THREE.EventDispatcher.prototype = {
  constructor: THREE.EventDispatcher,
  apply: function (object) {
    object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
    object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
    object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
    object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;
  },
  addEventListener: function (type, listener) {
    if (this._listeners === undefined)
      this._listeners = {};
    var listeners = this._listeners;
    if (listeners[type] === undefined) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  },
  hasEventListener: function (type, listener) {
    if (this._listeners === undefined)
      return false;
    var listeners = this._listeners;
    if (listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1) {
      return true;
    }
    return false;
  },
  removeEventListener: function (type, listener) {
    if (this._listeners === undefined)
      return;
    var listeners = this._listeners;
    var listenerArray = listeners[type];
    if (listenerArray !== undefined) {
      var index = listenerArray.indexOf(listener);
      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  },
  dispatchEvent: function (event) {
    if (this._listeners === undefined)
      return;
    var listeners = this._listeners;
    var listenerArray = listeners[event.type];
    if (listenerArray !== undefined) {
      event.target = this;
      var array = [];
      var length = listenerArray.length;
      for (var i = 0; i < length; i++) {
        array[i] = listenerArray[i];
      }
      for (var i = 0; i < length; i++) {
        array[i].call(this, event);
      }
    }
  }
};
// File:src/core/Layers.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
THREE.Layers = function () {
  this.mask = 1;
};
THREE.Layers.prototype = {
  constructor: THREE.Layers,
  set: function (channel) {
    this.mask = 1 << channel;
  },
  enable: function (channel) {
    this.mask |= 1 << channel;
  },
  toggle: function (channel) {
    this.mask ^= 1 << channel;
  },
  disable: function (channel) {
    this.mask &= ~(1 << channel);
  },
  test: function (layers) {
    return (this.mask & layers.mask) !== 0;
  }
};
// File:src/core/Raycaster.js
/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://clara.io/
 * @author stephomi / http://stephaneginier.com/
 */
(function (THREE) {
  THREE.Raycaster = function (origin, direction, near, far) {
    this.ray = new THREE.Ray(origin, direction);
    // direction is assumed to be normalized (for accurate distance calculations)
    this.near = near || 0;
    this.far = far || Infinity;
    this.params = {
      Mesh: {},
      Line: {},
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
    Object.defineProperties(this.params, {
      PointCloud: {
        get: function () {
          console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
          return this.Points;
        }
      }
    });
  };
  function ascSort(a, b) {
    return a.distance - b.distance;
  }
  function intersectObject(object, raycaster, intersects, recursive) {
    if (object.visible === false)
      return;
    object.raycast(raycaster, intersects);
    if (recursive === true) {
      var children = object.children;
      for (var i = 0, l = children.length; i < l; i++) {
        intersectObject(children[i], raycaster, intersects, true);
      }
    }
  }
  //
  THREE.Raycaster.prototype = {
    constructor: THREE.Raycaster,
    linePrecision: 1,
    set: function (origin, direction) {
      // direction is assumed to be normalized (for accurate distance calculations)
      this.ray.set(origin, direction);
    },
    setFromCamera: function (coords, camera) {
      if (camera instanceof THREE.PerspectiveCamera) {
        this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
        this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
      } else if (camera instanceof THREE.OrthographicCamera) {
        this.ray.origin.set(coords.x, coords.y, -1).unproject(camera);
        this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
      } else {
        console.error('THREE.Raycaster: Unsupported camera type.');
      }
    },
    intersectObject: function (object, recursive) {
      var intersects = [];
      intersectObject(object, this, intersects, recursive);
      intersects.sort(ascSort);
      return intersects;
    },
    intersectObjects: function (objects, recursive) {
      var intersects = [];
      if (Array.isArray(objects) === false) {
        console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
        return intersects;
      }
      for (var i = 0, l = objects.length; i < l; i++) {
        intersectObject(objects[i], this, intersects, recursive);
      }
      intersects.sort(ascSort);
      return intersects;
    }
  };
}(THREE));
// File:src/core/Object3D.js
/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */
THREE.Object3D = function () {
  Object.defineProperty(this, 'id', { value: THREE.Object3DIdCount++ });
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.type = 'Object3D';
  this.parent = null;
  this.children = [];
  this.up = THREE.Object3D.DefaultUp.clone();
  var position = new THREE.Vector3();
  var rotation = new THREE.Euler();
  var quaternion = new THREE.Quaternion();
  var scale = new THREE.Vector3(1, 1, 1);
  function onRotationChange() {
    quaternion.setFromEuler(rotation, false);
  }
  function onQuaternionChange() {
    rotation.setFromQuaternion(quaternion, undefined, false);
  }
  rotation.onChange(onRotationChange);
  quaternion.onChange(onQuaternionChange);
  Object.defineProperties(this, {
    position: {
      enumerable: true,
      value: position
    },
    rotation: {
      enumerable: true,
      value: rotation
    },
    quaternion: {
      enumerable: true,
      value: quaternion
    },
    scale: {
      enumerable: true,
      value: scale
    },
    modelViewMatrix: { value: new THREE.Matrix4() },
    normalMatrix: { value: new THREE.Matrix3() }
  });
  this.rotationAutoUpdate = true;
  this.matrix = new THREE.Matrix4();
  this.matrixWorld = new THREE.Matrix4();
  this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;
  this.matrixWorldNeedsUpdate = false;
  this.layers = new THREE.Layers();
  this.visible = true;
  this.castShadow = false;
  this.receiveShadow = false;
  this.frustumCulled = true;
  this.renderOrder = 0;
  this.userData = {};
};
THREE.Object3D.DefaultUp = new THREE.Vector3(0, 1, 0);
THREE.Object3D.DefaultMatrixAutoUpdate = true;
THREE.Object3D.prototype = {
  constructor: THREE.Object3D,
  applyMatrix: function (matrix) {
    this.matrix.multiplyMatrices(matrix, this.matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  },
  setRotationFromAxisAngle: function (axis, angle) {
    // assumes axis is normalized
    this.quaternion.setFromAxisAngle(axis, angle);
  },
  setRotationFromEuler: function (euler) {
    this.quaternion.setFromEuler(euler, true);
  },
  setRotationFromMatrix: function (m) {
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    this.quaternion.setFromRotationMatrix(m);
  },
  setRotationFromQuaternion: function (q) {
    // assumes q is normalized
    this.quaternion.copy(q);
  },
  rotateOnAxis: function () {
    // rotate object on axis in object space
    // axis is assumed to be normalized
    var q1 = new THREE.Quaternion();
    return function (axis, angle) {
      q1.setFromAxisAngle(axis, angle);
      this.quaternion.multiply(q1);
      return this;
    };
  }(),
  rotateX: function () {
    var v1 = new THREE.Vector3(1, 0, 0);
    return function (angle) {
      return this.rotateOnAxis(v1, angle);
    };
  }(),
  rotateY: function () {
    var v1 = new THREE.Vector3(0, 1, 0);
    return function (angle) {
      return this.rotateOnAxis(v1, angle);
    };
  }(),
  rotateZ: function () {
    var v1 = new THREE.Vector3(0, 0, 1);
    return function (angle) {
      return this.rotateOnAxis(v1, angle);
    };
  }(),
  translateOnAxis: function () {
    // translate object by distance along axis in object space
    // axis is assumed to be normalized
    var v1 = new THREE.Vector3();
    return function (axis, distance) {
      v1.copy(axis).applyQuaternion(this.quaternion);
      this.position.add(v1.multiplyScalar(distance));
      return this;
    };
  }(),
  translateX: function () {
    var v1 = new THREE.Vector3(1, 0, 0);
    return function (distance) {
      return this.translateOnAxis(v1, distance);
    };
  }(),
  translateY: function () {
    var v1 = new THREE.Vector3(0, 1, 0);
    return function (distance) {
      return this.translateOnAxis(v1, distance);
    };
  }(),
  translateZ: function () {
    var v1 = new THREE.Vector3(0, 0, 1);
    return function (distance) {
      return this.translateOnAxis(v1, distance);
    };
  }(),
  localToWorld: function (vector) {
    return vector.applyMatrix4(this.matrixWorld);
  },
  worldToLocal: function () {
    var m1 = new THREE.Matrix4();
    return function (vector) {
      return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
    };
  }(),
  lookAt: function () {
    // This routine does not support objects with rotated and/or translated parent(s)
    var m1 = new THREE.Matrix4();
    return function (vector) {
      m1.lookAt(vector, this.position, this.up);
      this.quaternion.setFromRotationMatrix(m1);
    };
  }(),
  add: function (object) {
    if (arguments.length > 1) {
      for (var i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
      }
      return this;
    }
    if (object === this) {
      console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
      return this;
    }
    if (object instanceof THREE.Object3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }
      object.parent = this;
      object.dispatchEvent({ type: 'added' });
      this.children.push(object);
    } else {
      console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
    }
    return this;
  },
  remove: function (object) {
    if (arguments.length > 1) {
      for (var i = 0; i < arguments.length; i++) {
        this.remove(arguments[i]);
      }
    }
    var index = this.children.indexOf(object);
    if (index !== -1) {
      object.parent = null;
      object.dispatchEvent({ type: 'removed' });
      this.children.splice(index, 1);
    }
  },
  getObjectById: function (id) {
    return this.getObjectByProperty('id', id);
  },
  getObjectByName: function (name) {
    return this.getObjectByProperty('name', name);
  },
  getObjectByProperty: function (name, value) {
    if (this[name] === value)
      return this;
    for (var i = 0, l = this.children.length; i < l; i++) {
      var child = this.children[i];
      var object = child.getObjectByProperty(name, value);
      if (object !== undefined) {
        return object;
      }
    }
    return undefined;
  },
  getWorldPosition: function (optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    this.updateMatrixWorld(true);
    return result.setFromMatrixPosition(this.matrixWorld);
  },
  getWorldQuaternion: function () {
    var position = new THREE.Vector3();
    var scale = new THREE.Vector3();
    return function (optionalTarget) {
      var result = optionalTarget || new THREE.Quaternion();
      this.updateMatrixWorld(true);
      this.matrixWorld.decompose(position, result, scale);
      return result;
    };
  }(),
  getWorldRotation: function () {
    var quaternion = new THREE.Quaternion();
    return function (optionalTarget) {
      var result = optionalTarget || new THREE.Euler();
      this.getWorldQuaternion(quaternion);
      return result.setFromQuaternion(quaternion, this.rotation.order, false);
    };
  }(),
  getWorldScale: function () {
    var position = new THREE.Vector3();
    var quaternion = new THREE.Quaternion();
    return function (optionalTarget) {
      var result = optionalTarget || new THREE.Vector3();
      this.updateMatrixWorld(true);
      this.matrixWorld.decompose(position, quaternion, result);
      return result;
    };
  }(),
  getWorldDirection: function () {
    var quaternion = new THREE.Quaternion();
    return function (optionalTarget) {
      var result = optionalTarget || new THREE.Vector3();
      this.getWorldQuaternion(quaternion);
      return result.set(0, 0, 1).applyQuaternion(quaternion);
    };
  }(),
  raycast: function () {
  },
  traverse: function (callback) {
    callback(this);
    var children = this.children;
    for (var i = 0, l = children.length; i < l; i++) {
      children[i].traverse(callback);
    }
  },
  traverseVisible: function (callback) {
    if (this.visible === false)
      return;
    callback(this);
    var children = this.children;
    for (var i = 0, l = children.length; i < l; i++) {
      children[i].traverseVisible(callback);
    }
  },
  traverseAncestors: function (callback) {
    var parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  },
  updateMatrix: function () {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  },
  updateMatrixWorld: function (force) {
    if (this.matrixAutoUpdate === true)
      this.updateMatrix();
    if (this.matrixWorldNeedsUpdate === true || force === true) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    // update children
    for (var i = 0, l = this.children.length; i < l; i++) {
      this.children[i].updateMatrixWorld(force);
    }
  },
  toJSON: function (meta) {
    var isRootObject = meta === undefined;
    var output = {};
    // meta is a hash used to collect geometries, materials.
    // not providing it implies that this is the root object
    // being serialized.
    if (isRootObject) {
      // initialize meta obj
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {}
      };
      output.metadata = {
        version: 4.4,
        type: 'Object',
        generator: 'Object3D.toJSON'
      };
    }
    // standard Object3D serialization
    var object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== '')
      object.name = this.name;
    if (JSON.stringify(this.userData) !== '{}')
      object.userData = this.userData;
    if (this.castShadow === true)
      object.castShadow = true;
    if (this.receiveShadow === true)
      object.receiveShadow = true;
    if (this.visible === false)
      object.visible = false;
    object.matrix = this.matrix.toArray();
    //
    if (this.geometry !== undefined) {
      if (meta.geometries[this.geometry.uuid] === undefined) {
        meta.geometries[this.geometry.uuid] = this.geometry.toJSON(meta);
      }
      object.geometry = this.geometry.uuid;
    }
    if (this.material !== undefined) {
      if (meta.materials[this.material.uuid] === undefined) {
        meta.materials[this.material.uuid] = this.material.toJSON(meta);
      }
      object.material = this.material.uuid;
    }
    //
    if (this.children.length > 0) {
      object.children = [];
      for (var i = 0; i < this.children.length; i++) {
        object.children.push(this.children[i].toJSON(meta).object);
      }
    }
    if (isRootObject) {
      var geometries = extractFromCache(meta.geometries);
      var materials = extractFromCache(meta.materials);
      var textures = extractFromCache(meta.textures);
      var images = extractFromCache(meta.images);
      if (geometries.length > 0)
        output.geometries = geometries;
      if (materials.length > 0)
        output.materials = materials;
      if (textures.length > 0)
        output.textures = textures;
      if (images.length > 0)
        output.images = images;
    }
    output.object = object;
    return output;
    // extract data from the cache hash
    // remove metadata on each item
    // and return as array
    function extractFromCache(cache) {
      var values = [];
      for (var key in cache) {
        var data = cache[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
  },
  clone: function (recursive) {
    return new this.constructor().copy(this, recursive);
  },
  copy: function (source, recursive) {
    if (recursive === undefined)
      recursive = true;
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.rotationAutoUpdate = source.rotationAutoUpdate;
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (var i = 0; i < source.children.length; i++) {
        var child = source.children[i];
        this.add(child.clone());
      }
    }
    return this;
  }
};
THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype);
THREE.Object3DIdCount = 0;
// File:src/core/Face3.js
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */
THREE.Face3 = function (a, b, c, normal, color, materialIndex) {
  this.a = a;
  this.b = b;
  this.c = c;
  this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
  this.vertexNormals = Array.isArray(normal) ? normal : [];
  this.color = color instanceof THREE.Color ? color : new THREE.Color();
  this.vertexColors = Array.isArray(color) ? color : [];
  this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
};
THREE.Face3.prototype = {
  constructor: THREE.Face3,
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.a = source.a;
    this.b = source.b;
    this.c = source.c;
    this.normal.copy(source.normal);
    this.color.copy(source.color);
    this.materialIndex = source.materialIndex;
    for (var i = 0, il = source.vertexNormals.length; i < il; i++) {
      this.vertexNormals[i] = source.vertexNormals[i].clone();
    }
    for (var i = 0, il = source.vertexColors.length; i < il; i++) {
      this.vertexColors[i] = source.vertexColors[i].clone();
    }
    return this;
  }
};
// File:src/core/BufferAttribute.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
THREE.BufferAttribute = function (array, itemSize) {
  this.uuid = THREE.Math.generateUUID();
  this.array = array;
  this.itemSize = itemSize;
  this.dynamic = false;
  this.updateRange = {
    offset: 0,
    count: -1
  };
  this.version = 0;
};
THREE.BufferAttribute.prototype = {
  constructor: THREE.BufferAttribute,
  get count() {
    return this.array.length / this.itemSize;
  },
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  },
  setDynamic: function (value) {
    this.dynamic = value;
    return this;
  },
  copy: function (source) {
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.dynamic = source.dynamic;
    return this;
  },
  copyAt: function (index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;
    for (var i = 0, l = this.itemSize; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }
    return this;
  },
  copyArray: function (array) {
    this.array.set(array);
    return this;
  },
  copyColorsArray: function (colors) {
    var array = this.array, offset = 0;
    for (var i = 0, l = colors.length; i < l; i++) {
      var color = colors[i];
      if (color === undefined) {
        console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
        color = new THREE.Color();
      }
      array[offset++] = color.r;
      array[offset++] = color.g;
      array[offset++] = color.b;
    }
    return this;
  },
  copyIndicesArray: function (indices) {
    var array = this.array, offset = 0;
    for (var i = 0, l = indices.length; i < l; i++) {
      var index = indices[i];
      array[offset++] = index.a;
      array[offset++] = index.b;
      array[offset++] = index.c;
    }
    return this;
  },
  copyVector2sArray: function (vectors) {
    var array = this.array, offset = 0;
    for (var i = 0, l = vectors.length; i < l; i++) {
      var vector = vectors[i];
      if (vector === undefined) {
        console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
        vector = new THREE.Vector2();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
    }
    return this;
  },
  copyVector3sArray: function (vectors) {
    var array = this.array, offset = 0;
    for (var i = 0, l = vectors.length; i < l; i++) {
      var vector = vectors[i];
      if (vector === undefined) {
        console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
        vector = new THREE.Vector3();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
    }
    return this;
  },
  copyVector4sArray: function (vectors) {
    var array = this.array, offset = 0;
    for (var i = 0, l = vectors.length; i < l; i++) {
      var vector = vectors[i];
      if (vector === undefined) {
        console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
        vector = new THREE.Vector4();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
      array[offset++] = vector.w;
    }
    return this;
  },
  set: function (value, offset) {
    if (offset === undefined)
      offset = 0;
    this.array.set(value, offset);
    return this;
  },
  getX: function (index) {
    return this.array[index * this.itemSize];
  },
  setX: function (index, x) {
    this.array[index * this.itemSize] = x;
    return this;
  },
  getY: function (index) {
    return this.array[index * this.itemSize + 1];
  },
  setY: function (index, y) {
    this.array[index * this.itemSize + 1] = y;
    return this;
  },
  getZ: function (index) {
    return this.array[index * this.itemSize + 2];
  },
  setZ: function (index, z) {
    this.array[index * this.itemSize + 2] = z;
    return this;
  },
  getW: function (index) {
    return this.array[index * this.itemSize + 3];
  },
  setW: function (index, w) {
    this.array[index * this.itemSize + 3] = w;
    return this;
  },
  setXY: function (index, x, y) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    return this;
  },
  setXYZ: function (index, x, y, z) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    return this;
  },
  setXYZW: function (index, x, y, z, w) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    this.array[index + 3] = w;
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  }
};
//
THREE.Int8Attribute = function (array, itemSize) {
  return new THREE.BufferAttribute(new Int8Array(array), itemSize);
};
THREE.Uint8Attribute = function (array, itemSize) {
  return new THREE.BufferAttribute(new Uint8Array(array), itemSize);
};
THREE.Uint8ClampedAttribute = function (array, itemSize) {
  return new THREE.BufferAttribute(new Uint8ClampedArray(array), itemSize);
};
THREE.Int16Attribute = function (array, itemSize) {
  return new THREE.BufferAttribute(new Int16Array(array), itemSize);
};
THREE.Uint16Attribute = function (array, itemSize) {
  return new THREE.BufferAttribute(new Uint16Array(array), itemSize);
};
THREE.Int32Attribute = function (array, itemSize) {
  return new THREE.BufferAttribute(new Int32Array(array), itemSize);
};
THREE.Uint32Attribute = function (array, itemSize) {
  return new THREE.BufferAttribute(new Uint32Array(array), itemSize);
};
THREE.Float32Attribute = function (array, itemSize) {
  return new THREE.BufferAttribute(new Float32Array(array), itemSize);
};
THREE.Float64Attribute = function (array, itemSize) {
  return new THREE.BufferAttribute(new Float64Array(array), itemSize);
};
// Deprecated
THREE.DynamicBufferAttribute = function (array, itemSize) {
  console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.');
  return new THREE.BufferAttribute(array, itemSize).setDynamic(true);
};
// File:src/core/InstancedBufferAttribute.js
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */
THREE.InstancedBufferAttribute = function (array, itemSize, meshPerAttribute) {
  THREE.BufferAttribute.call(this, array, itemSize);
  this.meshPerAttribute = meshPerAttribute || 1;
};
THREE.InstancedBufferAttribute.prototype = Object.create(THREE.BufferAttribute.prototype);
THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;
THREE.InstancedBufferAttribute.prototype.copy = function (source) {
  THREE.BufferAttribute.prototype.copy.call(this, source);
  this.meshPerAttribute = source.meshPerAttribute;
  return this;
};
// File:src/core/InterleavedBuffer.js
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */
THREE.InterleavedBuffer = function (array, stride) {
  this.uuid = THREE.Math.generateUUID();
  this.array = array;
  this.stride = stride;
  this.dynamic = false;
  this.updateRange = {
    offset: 0,
    count: -1
  };
  this.version = 0;
};
THREE.InterleavedBuffer.prototype = {
  constructor: THREE.InterleavedBuffer,
  get length() {
    return this.array.length;
  },
  get count() {
    return this.array.length / this.stride;
  },
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  },
  setDynamic: function (value) {
    this.dynamic = value;
    return this;
  },
  copy: function (source) {
    this.array = new source.array.constructor(source.array);
    this.stride = source.stride;
    this.dynamic = source.dynamic;
    return this;
  },
  copyAt: function (index1, attribute, index2) {
    index1 *= this.stride;
    index2 *= attribute.stride;
    for (var i = 0, l = this.stride; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }
    return this;
  },
  set: function (value, offset) {
    if (offset === undefined)
      offset = 0;
    this.array.set(value, offset);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  }
};
// File:src/core/InstancedInterleavedBuffer.js
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */
THREE.InstancedInterleavedBuffer = function (array, stride, meshPerAttribute) {
  THREE.InterleavedBuffer.call(this, array, stride);
  this.meshPerAttribute = meshPerAttribute || 1;
};
THREE.InstancedInterleavedBuffer.prototype = Object.create(THREE.InterleavedBuffer.prototype);
THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;
THREE.InstancedInterleavedBuffer.prototype.copy = function (source) {
  THREE.InterleavedBuffer.prototype.copy.call(this, source);
  this.meshPerAttribute = source.meshPerAttribute;
  return this;
};
// File:src/core/InterleavedBufferAttribute.js
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */
THREE.InterleavedBufferAttribute = function (interleavedBuffer, itemSize, offset) {
  this.uuid = THREE.Math.generateUUID();
  this.data = interleavedBuffer;
  this.itemSize = itemSize;
  this.offset = offset;
};
THREE.InterleavedBufferAttribute.prototype = {
  constructor: THREE.InterleavedBufferAttribute,
  get length() {
    console.warn('THREE.BufferAttribute: .length has been deprecated. Please use .count.');
    return this.array.length;
  },
  get count() {
    return this.data.count;
  },
  setX: function (index, x) {
    this.data.array[index * this.data.stride + this.offset] = x;
    return this;
  },
  setY: function (index, y) {
    this.data.array[index * this.data.stride + this.offset + 1] = y;
    return this;
  },
  setZ: function (index, z) {
    this.data.array[index * this.data.stride + this.offset + 2] = z;
    return this;
  },
  setW: function (index, w) {
    this.data.array[index * this.data.stride + this.offset + 3] = w;
    return this;
  },
  getX: function (index) {
    return this.data.array[index * this.data.stride + this.offset];
  },
  getY: function (index) {
    return this.data.array[index * this.data.stride + this.offset + 1];
  },
  getZ: function (index) {
    return this.data.array[index * this.data.stride + this.offset + 2];
  },
  getW: function (index) {
    return this.data.array[index * this.data.stride + this.offset + 3];
  },
  setXY: function (index, x, y) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    return this;
  },
  setXYZ: function (index, x, y, z) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    return this;
  },
  setXYZW: function (index, x, y, z, w) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    this.data.array[index + 3] = w;
    return this;
  }
};
// File:src/core/Geometry.js
/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://clara.io
 */
THREE.Geometry = function () {
  Object.defineProperty(this, 'id', { value: THREE.GeometryIdCount++ });
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.type = 'Geometry';
  this.vertices = [];
  this.colors = [];
  this.faces = [];
  this.faceVertexUvs = [[]];
  this.morphTargets = [];
  this.morphNormals = [];
  this.skinWeights = [];
  this.skinIndices = [];
  this.lineDistances = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  // update flags
  this.verticesNeedUpdate = false;
  this.elementsNeedUpdate = false;
  this.uvsNeedUpdate = false;
  this.normalsNeedUpdate = false;
  this.colorsNeedUpdate = false;
  this.lineDistancesNeedUpdate = false;
  this.groupsNeedUpdate = false;
};
THREE.Geometry.prototype = {
  constructor: THREE.Geometry,
  applyMatrix: function (matrix) {
    var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
    for (var i = 0, il = this.vertices.length; i < il; i++) {
      var vertex = this.vertices[i];
      vertex.applyMatrix4(matrix);
    }
    for (var i = 0, il = this.faces.length; i < il; i++) {
      var face = this.faces[i];
      face.normal.applyMatrix3(normalMatrix).normalize();
      for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
      }
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    this.verticesNeedUpdate = true;
    this.normalsNeedUpdate = true;
    return this;
  },
  rotateX: function () {
    // rotate geometry around world x-axis
    var m1;
    return function rotateX(angle) {
      if (m1 === undefined)
        m1 = new THREE.Matrix4();
      m1.makeRotationX(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  rotateY: function () {
    // rotate geometry around world y-axis
    var m1;
    return function rotateY(angle) {
      if (m1 === undefined)
        m1 = new THREE.Matrix4();
      m1.makeRotationY(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  rotateZ: function () {
    // rotate geometry around world z-axis
    var m1;
    return function rotateZ(angle) {
      if (m1 === undefined)
        m1 = new THREE.Matrix4();
      m1.makeRotationZ(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  translate: function () {
    // translate geometry
    var m1;
    return function translate(x, y, z) {
      if (m1 === undefined)
        m1 = new THREE.Matrix4();
      m1.makeTranslation(x, y, z);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  scale: function () {
    // scale geometry
    var m1;
    return function scale(x, y, z) {
      if (m1 === undefined)
        m1 = new THREE.Matrix4();
      m1.makeScale(x, y, z);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  lookAt: function () {
    var obj;
    return function lookAt(vector) {
      if (obj === undefined)
        obj = new THREE.Object3D();
      obj.lookAt(vector);
      obj.updateMatrix();
      this.applyMatrix(obj.matrix);
    };
  }(),
  fromBufferGeometry: function (geometry) {
    var scope = this;
    var indices = geometry.index !== null ? geometry.index.array : undefined;
    var attributes = geometry.attributes;
    var positions = attributes.position.array;
    var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
    var colors = attributes.color !== undefined ? attributes.color.array : undefined;
    var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
    var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
    if (uvs2 !== undefined)
      this.faceVertexUvs[1] = [];
    var tempNormals = [];
    var tempUVs = [];
    var tempUVs2 = [];
    for (var i = 0, j = 0; i < positions.length; i += 3, j += 2) {
      scope.vertices.push(new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]));
      if (normals !== undefined) {
        tempNormals.push(new THREE.Vector3(normals[i], normals[i + 1], normals[i + 2]));
      }
      if (colors !== undefined) {
        scope.colors.push(new THREE.Color(colors[i], colors[i + 1], colors[i + 2]));
      }
      if (uvs !== undefined) {
        tempUVs.push(new THREE.Vector2(uvs[j], uvs[j + 1]));
      }
      if (uvs2 !== undefined) {
        tempUVs2.push(new THREE.Vector2(uvs2[j], uvs2[j + 1]));
      }
    }
    function addFace(a, b, c, materialIndex) {
      var vertexNormals = normals !== undefined ? [
        tempNormals[a].clone(),
        tempNormals[b].clone(),
        tempNormals[c].clone()
      ] : [];
      var vertexColors = colors !== undefined ? [
        scope.colors[a].clone(),
        scope.colors[b].clone(),
        scope.colors[c].clone()
      ] : [];
      var face = new THREE.Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
      scope.faces.push(face);
      if (uvs !== undefined) {
        scope.faceVertexUvs[0].push([
          tempUVs[a].clone(),
          tempUVs[b].clone(),
          tempUVs[c].clone()
        ]);
      }
      if (uvs2 !== undefined) {
        scope.faceVertexUvs[1].push([
          tempUVs2[a].clone(),
          tempUVs2[b].clone(),
          tempUVs2[c].clone()
        ]);
      }
    }
    if (indices !== undefined) {
      var groups = geometry.groups;
      if (groups.length > 0) {
        for (var i = 0; i < groups.length; i++) {
          var group = groups[i];
          var start = group.start;
          var count = group.count;
          for (var j = start, jl = start + count; j < jl; j += 3) {
            addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);
          }
        }
      } else {
        for (var i = 0; i < indices.length; i += 3) {
          addFace(indices[i], indices[i + 1], indices[i + 2]);
        }
      }
    } else {
      for (var i = 0; i < positions.length / 3; i += 3) {
        addFace(i, i + 1, i + 2);
      }
    }
    this.computeFaceNormals();
    if (geometry.boundingBox !== null) {
      this.boundingBox = geometry.boundingBox.clone();
    }
    if (geometry.boundingSphere !== null) {
      this.boundingSphere = geometry.boundingSphere.clone();
    }
    return this;
  },
  center: function () {
    this.computeBoundingBox();
    var offset = this.boundingBox.center().negate();
    this.translate(offset.x, offset.y, offset.z);
    return offset;
  },
  normalize: function () {
    this.computeBoundingSphere();
    var center = this.boundingSphere.center;
    var radius = this.boundingSphere.radius;
    var s = radius === 0 ? 1 : 1 / radius;
    var matrix = new THREE.Matrix4();
    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
    this.applyMatrix(matrix);
    return this;
  },
  computeFaceNormals: function () {
    var cb = new THREE.Vector3(), ab = new THREE.Vector3();
    for (var f = 0, fl = this.faces.length; f < fl; f++) {
      var face = this.faces[f];
      var vA = this.vertices[face.a];
      var vB = this.vertices[face.b];
      var vC = this.vertices[face.c];
      cb.subVectors(vC, vB);
      ab.subVectors(vA, vB);
      cb.cross(ab);
      cb.normalize();
      face.normal.copy(cb);
    }
  },
  computeVertexNormals: function (areaWeighted) {
    if (areaWeighted === undefined)
      areaWeighted = true;
    var v, vl, f, fl, face, vertices;
    vertices = new Array(this.vertices.length);
    for (v = 0, vl = this.vertices.length; v < vl; v++) {
      vertices[v] = new THREE.Vector3();
    }
    if (areaWeighted) {
      // vertex normals weighted by triangle areas
      // http://www.iquilezles.org/www/articles/normals/normals.htm
      var vA, vB, vC;
      var cb = new THREE.Vector3(), ab = new THREE.Vector3();
      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        vA = this.vertices[face.a];
        vB = this.vertices[face.b];
        vC = this.vertices[face.c];
        cb.subVectors(vC, vB);
        ab.subVectors(vA, vB);
        cb.cross(ab);
        vertices[face.a].add(cb);
        vertices[face.b].add(cb);
        vertices[face.c].add(cb);
      }
    } else {
      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        vertices[face.a].add(face.normal);
        vertices[face.b].add(face.normal);
        vertices[face.c].add(face.normal);
      }
    }
    for (v = 0, vl = this.vertices.length; v < vl; v++) {
      vertices[v].normalize();
    }
    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];
      var vertexNormals = face.vertexNormals;
      if (vertexNormals.length === 3) {
        vertexNormals[0].copy(vertices[face.a]);
        vertexNormals[1].copy(vertices[face.b]);
        vertexNormals[2].copy(vertices[face.c]);
      } else {
        vertexNormals[0] = vertices[face.a].clone();
        vertexNormals[1] = vertices[face.b].clone();
        vertexNormals[2] = vertices[face.c].clone();
      }
    }
    if (this.faces.length > 0) {
      this.normalsNeedUpdate = true;
    }
  },
  computeMorphNormals: function () {
    var i, il, f, fl, face;
    // save original normals
    // - create temp variables on first access
    //   otherwise just copy (for faster repeated calls)
    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];
      if (!face.__originalFaceNormal) {
        face.__originalFaceNormal = face.normal.clone();
      } else {
        face.__originalFaceNormal.copy(face.normal);
      }
      if (!face.__originalVertexNormals)
        face.__originalVertexNormals = [];
      for (i = 0, il = face.vertexNormals.length; i < il; i++) {
        if (!face.__originalVertexNormals[i]) {
          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
        } else {
          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
        }
      }
    }
    // use temp geometry to compute face and vertex normals for each morph
    var tmpGeo = new THREE.Geometry();
    tmpGeo.faces = this.faces;
    for (i = 0, il = this.morphTargets.length; i < il; i++) {
      // create on first access
      if (!this.morphNormals[i]) {
        this.morphNormals[i] = {};
        this.morphNormals[i].faceNormals = [];
        this.morphNormals[i].vertexNormals = [];
        var dstNormalsFace = this.morphNormals[i].faceNormals;
        var dstNormalsVertex = this.morphNormals[i].vertexNormals;
        var faceNormal, vertexNormals;
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          faceNormal = new THREE.Vector3();
          vertexNormals = {
            a: new THREE.Vector3(),
            b: new THREE.Vector3(),
            c: new THREE.Vector3()
          };
          dstNormalsFace.push(faceNormal);
          dstNormalsVertex.push(vertexNormals);
        }
      }
      var morphNormals = this.morphNormals[i];
      // set vertices to morph target
      tmpGeo.vertices = this.morphTargets[i].vertices;
      // compute morph normals
      tmpGeo.computeFaceNormals();
      tmpGeo.computeVertexNormals();
      // store morph normals
      var faceNormal, vertexNormals;
      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        faceNormal = morphNormals.faceNormals[f];
        vertexNormals = morphNormals.vertexNormals[f];
        faceNormal.copy(face.normal);
        vertexNormals.a.copy(face.vertexNormals[0]);
        vertexNormals.b.copy(face.vertexNormals[1]);
        vertexNormals.c.copy(face.vertexNormals[2]);
      }
    }
    // restore original normals
    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];
      face.normal = face.__originalFaceNormal;
      face.vertexNormals = face.__originalVertexNormals;
    }
  },
  computeTangents: function () {
    console.warn('THREE.Geometry: .computeTangents() has been removed.');
  },
  computeLineDistances: function () {
    var d = 0;
    var vertices = this.vertices;
    for (var i = 0, il = vertices.length; i < il; i++) {
      if (i > 0) {
        d += vertices[i].distanceTo(vertices[i - 1]);
      }
      this.lineDistances[i] = d;
    }
  },
  computeBoundingBox: function () {
    if (this.boundingBox === null) {
      this.boundingBox = new THREE.Box3();
    }
    this.boundingBox.setFromPoints(this.vertices);
  },
  computeBoundingSphere: function () {
    if (this.boundingSphere === null) {
      this.boundingSphere = new THREE.Sphere();
    }
    this.boundingSphere.setFromPoints(this.vertices);
  },
  merge: function (geometry, matrix, materialIndexOffset) {
    if (geometry instanceof THREE.Geometry === false) {
      console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);
      return;
    }
    var normalMatrix, vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, uvs1 = this.faceVertexUvs[0], uvs2 = geometry.faceVertexUvs[0];
    if (materialIndexOffset === undefined)
      materialIndexOffset = 0;
    if (matrix !== undefined) {
      normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
    }
    // vertices
    for (var i = 0, il = vertices2.length; i < il; i++) {
      var vertex = vertices2[i];
      var vertexCopy = vertex.clone();
      if (matrix !== undefined)
        vertexCopy.applyMatrix4(matrix);
      vertices1.push(vertexCopy);
    }
    // faces
    for (i = 0, il = faces2.length; i < il; i++) {
      var face = faces2[i], faceCopy, normal, color, faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
      faceCopy = new THREE.Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
      faceCopy.normal.copy(face.normal);
      if (normalMatrix !== undefined) {
        faceCopy.normal.applyMatrix3(normalMatrix).normalize();
      }
      for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {
        normal = faceVertexNormals[j].clone();
        if (normalMatrix !== undefined) {
          normal.applyMatrix3(normalMatrix).normalize();
        }
        faceCopy.vertexNormals.push(normal);
      }
      faceCopy.color.copy(face.color);
      for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {
        color = faceVertexColors[j];
        faceCopy.vertexColors.push(color.clone());
      }
      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
      faces1.push(faceCopy);
    }
    // uvs
    for (i = 0, il = uvs2.length; i < il; i++) {
      var uv = uvs2[i], uvCopy = [];
      if (uv === undefined) {
        continue;
      }
      for (var j = 0, jl = uv.length; j < jl; j++) {
        uvCopy.push(uv[j].clone());
      }
      uvs1.push(uvCopy);
    }
  },
  mergeMesh: function (mesh) {
    if (mesh instanceof THREE.Mesh === false) {
      console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);
      return;
    }
    mesh.matrixAutoUpdate && mesh.updateMatrix();
    this.merge(mesh.geometry, mesh.matrix);
  },
  /*
  * Checks for duplicate vertices with hashmap.
  * Duplicated vertices are removed
  * and faces' vertices are updated.
  */
  mergeVertices: function () {
    var verticesMap = {};
    // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
    var unique = [], changes = [];
    var v, key;
    var precisionPoints = 4;
    // number of decimal points, e.g. 4 for epsilon of 0.0001
    var precision = Math.pow(10, precisionPoints);
    var i, il, face;
    var indices, j, jl;
    for (i = 0, il = this.vertices.length; i < il; i++) {
      v = this.vertices[i];
      key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);
      if (verticesMap[key] === undefined) {
        verticesMap[key] = i;
        unique.push(this.vertices[i]);
        changes[i] = unique.length - 1;
      } else {
        changes[i] = changes[verticesMap[key]];
      }
    }
    // if faces are completely degenerate after merging vertices, we
    // have to remove them from the geometry.
    var faceIndicesToRemove = [];
    for (i = 0, il = this.faces.length; i < il; i++) {
      face = this.faces[i];
      face.a = changes[face.a];
      face.b = changes[face.b];
      face.c = changes[face.c];
      indices = [
        face.a,
        face.b,
        face.c
      ];
      var dupIndex = -1;
      // if any duplicate vertices are found in a Face3
      // we have to remove the face as nothing can be saved
      for (var n = 0; n < 3; n++) {
        if (indices[n] === indices[(n + 1) % 3]) {
          dupIndex = n;
          faceIndicesToRemove.push(i);
          break;
        }
      }
    }
    for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
      var idx = faceIndicesToRemove[i];
      this.faces.splice(idx, 1);
      for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
        this.faceVertexUvs[j].splice(idx, 1);
      }
    }
    // Use unique set of vertices
    var diff = this.vertices.length - unique.length;
    this.vertices = unique;
    return diff;
  },
  sortFacesByMaterialIndex: function () {
    var faces = this.faces;
    var length = faces.length;
    // tag faces
    for (var i = 0; i < length; i++) {
      faces[i]._id = i;
    }
    // sort faces
    function materialIndexSort(a, b) {
      return a.materialIndex - b.materialIndex;
    }
    faces.sort(materialIndexSort);
    // sort uvs
    var uvs1 = this.faceVertexUvs[0];
    var uvs2 = this.faceVertexUvs[1];
    var newUvs1, newUvs2;
    if (uvs1 && uvs1.length === length)
      newUvs1 = [];
    if (uvs2 && uvs2.length === length)
      newUvs2 = [];
    for (var i = 0; i < length; i++) {
      var id = faces[i]._id;
      if (newUvs1)
        newUvs1.push(uvs1[id]);
      if (newUvs2)
        newUvs2.push(uvs2[id]);
    }
    if (newUvs1)
      this.faceVertexUvs[0] = newUvs1;
    if (newUvs2)
      this.faceVertexUvs[1] = newUvs2;
  },
  toJSON: function () {
    var data = {
      metadata: {
        version: 4.4,
        type: 'Geometry',
        generator: 'Geometry.toJSON'
      }
    };
    // standard Geometry serialization
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== '')
      data.name = this.name;
    if (this.parameters !== undefined) {
      var parameters = this.parameters;
      for (var key in parameters) {
        if (parameters[key] !== undefined)
          data[key] = parameters[key];
      }
      return data;
    }
    var vertices = [];
    for (var i = 0; i < this.vertices.length; i++) {
      var vertex = this.vertices[i];
      vertices.push(vertex.x, vertex.y, vertex.z);
    }
    var faces = [];
    var normals = [];
    var normalsHash = {};
    var colors = [];
    var colorsHash = {};
    var uvs = [];
    var uvsHash = {};
    for (var i = 0; i < this.faces.length; i++) {
      var face = this.faces[i];
      var hasMaterial = true;
      var hasFaceUv = false;
      // deprecated
      var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
      var hasFaceNormal = face.normal.length() > 0;
      var hasFaceVertexNormal = face.vertexNormals.length > 0;
      var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
      var hasFaceVertexColor = face.vertexColors.length > 0;
      var faceType = 0;
      faceType = setBit(faceType, 0, 0);
      // isQuad
      faceType = setBit(faceType, 1, hasMaterial);
      faceType = setBit(faceType, 2, hasFaceUv);
      faceType = setBit(faceType, 3, hasFaceVertexUv);
      faceType = setBit(faceType, 4, hasFaceNormal);
      faceType = setBit(faceType, 5, hasFaceVertexNormal);
      faceType = setBit(faceType, 6, hasFaceColor);
      faceType = setBit(faceType, 7, hasFaceVertexColor);
      faces.push(faceType);
      faces.push(face.a, face.b, face.c);
      faces.push(face.materialIndex);
      if (hasFaceVertexUv) {
        var faceVertexUvs = this.faceVertexUvs[0][i];
        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
      }
      if (hasFaceNormal) {
        faces.push(getNormalIndex(face.normal));
      }
      if (hasFaceVertexNormal) {
        var vertexNormals = face.vertexNormals;
        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
      }
      if (hasFaceColor) {
        faces.push(getColorIndex(face.color));
      }
      if (hasFaceVertexColor) {
        var vertexColors = face.vertexColors;
        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
      }
    }
    function setBit(value, position, enabled) {
      return enabled ? value | 1 << position : value & ~(1 << position);
    }
    function getNormalIndex(normal) {
      var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
      if (normalsHash[hash] !== undefined) {
        return normalsHash[hash];
      }
      normalsHash[hash] = normals.length / 3;
      normals.push(normal.x, normal.y, normal.z);
      return normalsHash[hash];
    }
    function getColorIndex(color) {
      var hash = color.r.toString() + color.g.toString() + color.b.toString();
      if (colorsHash[hash] !== undefined) {
        return colorsHash[hash];
      }
      colorsHash[hash] = colors.length;
      colors.push(color.getHex());
      return colorsHash[hash];
    }
    function getUvIndex(uv) {
      var hash = uv.x.toString() + uv.y.toString();
      if (uvsHash[hash] !== undefined) {
        return uvsHash[hash];
      }
      uvsHash[hash] = uvs.length / 2;
      uvs.push(uv.x, uv.y);
      return uvsHash[hash];
    }
    data.data = {};
    data.data.vertices = vertices;
    data.data.normals = normals;
    if (colors.length > 0)
      data.data.colors = colors;
    if (uvs.length > 0)
      data.data.uvs = [uvs];
    // temporal backward compatibility
    data.data.faces = faces;
    return data;
  },
  clone: function () {
    /*
    		// Handle primitives
    
    		var parameters = this.parameters;
    
    		if ( parameters !== undefined ) {
    
    			var values = [];
    
    			for ( var key in parameters ) {
    
    				values.push( parameters[ key ] );
    
    			}
    
    			var geometry = Object.create( this.constructor.prototype );
    			this.constructor.apply( geometry, values );
    			return geometry;
    
    		}
    
    		return new this.constructor().copy( this );
    		*/
    return new THREE.Geometry().copy(this);
  },
  copy: function (source) {
    this.vertices = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    var vertices = source.vertices;
    for (var i = 0, il = vertices.length; i < il; i++) {
      this.vertices.push(vertices[i].clone());
    }
    var faces = source.faces;
    for (var i = 0, il = faces.length; i < il; i++) {
      this.faces.push(faces[i].clone());
    }
    for (var i = 0, il = source.faceVertexUvs.length; i < il; i++) {
      var faceVertexUvs = source.faceVertexUvs[i];
      if (this.faceVertexUvs[i] === undefined) {
        this.faceVertexUvs[i] = [];
      }
      for (var j = 0, jl = faceVertexUvs.length; j < jl; j++) {
        var uvs = faceVertexUvs[j], uvsCopy = [];
        for (var k = 0, kl = uvs.length; k < kl; k++) {
          var uv = uvs[k];
          uvsCopy.push(uv.clone());
        }
        this.faceVertexUvs[i].push(uvsCopy);
      }
    }
    return this;
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  }
};
THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype);
THREE.GeometryIdCount = 0;
// File:src/core/BufferGeometry.js
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */
THREE.BufferGeometry = function () {
  Object.defineProperty(this, 'id', { value: THREE.GeometryIdCount++ });
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.type = 'BufferGeometry';
  this.index = null;
  this.attributes = {};
  this.morphAttributes = {};
  this.groups = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  this.drawRange = {
    start: 0,
    count: Infinity
  };
};
THREE.BufferGeometry.prototype = {
  constructor: THREE.BufferGeometry,
  getIndex: function () {
    return this.index;
  },
  setIndex: function (index) {
    this.index = index;
  },
  addAttribute: function (name, attribute) {
    if (attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false) {
      console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
      this.addAttribute(name, new THREE.BufferAttribute(arguments[1], arguments[2]));
      return;
    }
    if (name === 'index') {
      console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
      this.setIndex(attribute);
      return;
    }
    this.attributes[name] = attribute;
    return this;
  },
  getAttribute: function (name) {
    return this.attributes[name];
  },
  removeAttribute: function (name) {
    delete this.attributes[name];
    return this;
  },
  addGroup: function (start, count, materialIndex) {
    this.groups.push({
      start: start,
      count: count,
      materialIndex: materialIndex !== undefined ? materialIndex : 0
    });
  },
  clearGroups: function () {
    this.groups = [];
  },
  setDrawRange: function (start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  },
  applyMatrix: function (matrix) {
    var position = this.attributes.position;
    if (position !== undefined) {
      matrix.applyToVector3Array(position.array);
      position.needsUpdate = true;
    }
    var normal = this.attributes.normal;
    if (normal !== undefined) {
      var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
      normalMatrix.applyToVector3Array(normal.array);
      normal.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  },
  rotateX: function () {
    // rotate geometry around world x-axis
    var m1;
    return function rotateX(angle) {
      if (m1 === undefined)
        m1 = new THREE.Matrix4();
      m1.makeRotationX(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  rotateY: function () {
    // rotate geometry around world y-axis
    var m1;
    return function rotateY(angle) {
      if (m1 === undefined)
        m1 = new THREE.Matrix4();
      m1.makeRotationY(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  rotateZ: function () {
    // rotate geometry around world z-axis
    var m1;
    return function rotateZ(angle) {
      if (m1 === undefined)
        m1 = new THREE.Matrix4();
      m1.makeRotationZ(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  translate: function () {
    // translate geometry
    var m1;
    return function translate(x, y, z) {
      if (m1 === undefined)
        m1 = new THREE.Matrix4();
      m1.makeTranslation(x, y, z);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  scale: function () {
    // scale geometry
    var m1;
    return function scale(x, y, z) {
      if (m1 === undefined)
        m1 = new THREE.Matrix4();
      m1.makeScale(x, y, z);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  lookAt: function () {
    var obj;
    return function lookAt(vector) {
      if (obj === undefined)
        obj = new THREE.Object3D();
      obj.lookAt(vector);
      obj.updateMatrix();
      this.applyMatrix(obj.matrix);
    };
  }(),
  center: function () {
    this.computeBoundingBox();
    var offset = this.boundingBox.center().negate();
    this.translate(offset.x, offset.y, offset.z);
    return offset;
  },
  setFromObject: function (object) {
    var geometry = object.geometry;
    if (object instanceof THREE.Points || object instanceof THREE.Line) {
      var positions = new THREE.Float32Attribute(geometry.vertices.length * 3, 3);
      var colors = new THREE.Float32Attribute(geometry.colors.length * 3, 3);
      this.addAttribute('position', positions.copyVector3sArray(geometry.vertices));
      this.addAttribute('color', colors.copyColorsArray(geometry.colors));
      if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
        var lineDistances = new THREE.Float32Attribute(geometry.lineDistances.length, 1);
        this.addAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));
      }
      if (geometry.boundingSphere !== null) {
        this.boundingSphere = geometry.boundingSphere.clone();
      }
      if (geometry.boundingBox !== null) {
        this.boundingBox = geometry.boundingBox.clone();
      }
    } else if (object instanceof THREE.Mesh) {
      if (geometry instanceof THREE.Geometry) {
        this.fromGeometry(geometry);
      }
    }
    return this;
  },
  updateFromObject: function (object) {
    var geometry = object.geometry;
    if (object instanceof THREE.Mesh) {
      var direct = geometry.__directGeometry;
      if (direct === undefined) {
        return this.fromGeometry(geometry);
      }
      direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
      direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
      direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
      direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
      direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
      geometry.verticesNeedUpdate = false;
      geometry.normalsNeedUpdate = false;
      geometry.colorsNeedUpdate = false;
      geometry.uvsNeedUpdate = false;
      geometry.groupsNeedUpdate = false;
      geometry = direct;
    }
    if (geometry.verticesNeedUpdate === true) {
      var attribute = this.attributes.position;
      if (attribute !== undefined) {
        attribute.copyVector3sArray(geometry.vertices);
        attribute.needsUpdate = true;
      }
      geometry.verticesNeedUpdate = false;
    }
    if (geometry.normalsNeedUpdate === true) {
      var attribute = this.attributes.normal;
      if (attribute !== undefined) {
        attribute.copyVector3sArray(geometry.normals);
        attribute.needsUpdate = true;
      }
      geometry.normalsNeedUpdate = false;
    }
    if (geometry.colorsNeedUpdate === true) {
      var attribute = this.attributes.color;
      if (attribute !== undefined) {
        attribute.copyColorsArray(geometry.colors);
        attribute.needsUpdate = true;
      }
      geometry.colorsNeedUpdate = false;
    }
    if (geometry.uvsNeedUpdate) {
      var attribute = this.attributes.uv;
      if (attribute !== undefined) {
        attribute.copyVector2sArray(geometry.uvs);
        attribute.needsUpdate = true;
      }
      geometry.uvsNeedUpdate = false;
    }
    if (geometry.lineDistancesNeedUpdate) {
      var attribute = this.attributes.lineDistance;
      if (attribute !== undefined) {
        attribute.copyArray(geometry.lineDistances);
        attribute.needsUpdate = true;
      }
      geometry.lineDistancesNeedUpdate = false;
    }
    if (geometry.groupsNeedUpdate) {
      geometry.computeGroups(object.geometry);
      this.groups = geometry.groups;
      geometry.groupsNeedUpdate = false;
    }
    return this;
  },
  fromGeometry: function (geometry) {
    geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry(geometry);
    return this.fromDirectGeometry(geometry.__directGeometry);
  },
  fromDirectGeometry: function (geometry) {
    var positions = new Float32Array(geometry.vertices.length * 3);
    this.addAttribute('position', new THREE.BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));
    if (geometry.normals.length > 0) {
      var normals = new Float32Array(geometry.normals.length * 3);
      this.addAttribute('normal', new THREE.BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
    }
    if (geometry.colors.length > 0) {
      var colors = new Float32Array(geometry.colors.length * 3);
      this.addAttribute('color', new THREE.BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
    }
    if (geometry.uvs.length > 0) {
      var uvs = new Float32Array(geometry.uvs.length * 2);
      this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
    }
    if (geometry.uvs2.length > 0) {
      var uvs2 = new Float32Array(geometry.uvs2.length * 2);
      this.addAttribute('uv2', new THREE.BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
    }
    if (geometry.indices.length > 0) {
      var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
      var indices = new TypeArray(geometry.indices.length * 3);
      this.setIndex(new THREE.BufferAttribute(indices, 1).copyIndicesArray(geometry.indices));
    }
    // groups
    this.groups = geometry.groups;
    // morphs
    for (var name in geometry.morphTargets) {
      var array = [];
      var morphTargets = geometry.morphTargets[name];
      for (var i = 0, l = morphTargets.length; i < l; i++) {
        var morphTarget = morphTargets[i];
        var attribute = new THREE.Float32Attribute(morphTarget.length * 3, 3);
        array.push(attribute.copyVector3sArray(morphTarget));
      }
      this.morphAttributes[name] = array;
    }
    // skinning
    if (geometry.skinIndices.length > 0) {
      var skinIndices = new THREE.Float32Attribute(geometry.skinIndices.length * 4, 4);
      this.addAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));
    }
    if (geometry.skinWeights.length > 0) {
      var skinWeights = new THREE.Float32Attribute(geometry.skinWeights.length * 4, 4);
      this.addAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));
    }
    //
    if (geometry.boundingSphere !== null) {
      this.boundingSphere = geometry.boundingSphere.clone();
    }
    if (geometry.boundingBox !== null) {
      this.boundingBox = geometry.boundingBox.clone();
    }
    return this;
  },
  computeBoundingBox: function () {
    var vector = new THREE.Vector3();
    return function () {
      if (this.boundingBox === null) {
        this.boundingBox = new THREE.Box3();
      }
      var positions = this.attributes.position.array;
      if (positions) {
        this.boundingBox.setFromArray(positions);
      }
      if (positions === undefined || positions.length === 0) {
        this.boundingBox.min.set(0, 0, 0);
        this.boundingBox.max.set(0, 0, 0);
      }
      if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
        console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
      }
    };
  }(),
  computeBoundingSphere: function () {
    var box = new THREE.Box3();
    var vector = new THREE.Vector3();
    return function () {
      if (this.boundingSphere === null) {
        this.boundingSphere = new THREE.Sphere();
      }
      var positions = this.attributes.position.array;
      if (positions) {
        var center = this.boundingSphere.center;
        box.setFromArray(positions);
        box.center(center);
        // hoping to find a boundingSphere with a radius smaller than the
        // boundingSphere of the boundingBox: sqrt(3) smaller in the best case
        var maxRadiusSq = 0;
        for (var i = 0, il = positions.length; i < il; i += 3) {
          vector.fromArray(positions, i);
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
        }
        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
        if (isNaN(this.boundingSphere.radius)) {
          console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
      }
    };
  }(),
  computeFaceNormals: function () {
  },
  computeVertexNormals: function () {
    var index = this.index;
    var attributes = this.attributes;
    var groups = this.groups;
    if (attributes.position) {
      var positions = attributes.position.array;
      if (attributes.normal === undefined) {
        this.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(positions.length), 3));
      } else {
        // reset existing normals to zero
        var array = attributes.normal.array;
        for (var i = 0, il = array.length; i < il; i++) {
          array[i] = 0;
        }
      }
      var normals = attributes.normal.array;
      var vA, vB, vC, pA = new THREE.Vector3(), pB = new THREE.Vector3(), pC = new THREE.Vector3(), cb = new THREE.Vector3(), ab = new THREE.Vector3();
      // indexed elements
      if (index) {
        var indices = index.array;
        if (groups.length === 0) {
          this.addGroup(0, indices.length);
        }
        for (var j = 0, jl = groups.length; j < jl; ++j) {
          var group = groups[j];
          var start = group.start;
          var count = group.count;
          for (var i = start, il = start + count; i < il; i += 3) {
            vA = indices[i + 0] * 3;
            vB = indices[i + 1] * 3;
            vC = indices[i + 2] * 3;
            pA.fromArray(positions, vA);
            pB.fromArray(positions, vB);
            pC.fromArray(positions, vC);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            normals[vA] += cb.x;
            normals[vA + 1] += cb.y;
            normals[vA + 2] += cb.z;
            normals[vB] += cb.x;
            normals[vB + 1] += cb.y;
            normals[vB + 2] += cb.z;
            normals[vC] += cb.x;
            normals[vC + 1] += cb.y;
            normals[vC + 2] += cb.z;
          }
        }
      } else {
        // non-indexed elements (unconnected triangle soup)
        for (var i = 0, il = positions.length; i < il; i += 9) {
          pA.fromArray(positions, i);
          pB.fromArray(positions, i + 3);
          pC.fromArray(positions, i + 6);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normals[i] = cb.x;
          normals[i + 1] = cb.y;
          normals[i + 2] = cb.z;
          normals[i + 3] = cb.x;
          normals[i + 4] = cb.y;
          normals[i + 5] = cb.z;
          normals[i + 6] = cb.x;
          normals[i + 7] = cb.y;
          normals[i + 8] = cb.z;
        }
      }
      this.normalizeNormals();
      attributes.normal.needsUpdate = true;
    }
  },
  merge: function (geometry, offset) {
    if (geometry instanceof THREE.BufferGeometry === false) {
      console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
      return;
    }
    if (offset === undefined)
      offset = 0;
    var attributes = this.attributes;
    for (var key in attributes) {
      if (geometry.attributes[key] === undefined)
        continue;
      var attribute1 = attributes[key];
      var attributeArray1 = attribute1.array;
      var attribute2 = geometry.attributes[key];
      var attributeArray2 = attribute2.array;
      var attributeSize = attribute2.itemSize;
      for (var i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, j++) {
        attributeArray1[j] = attributeArray2[i];
      }
    }
    return this;
  },
  normalizeNormals: function () {
    var normals = this.attributes.normal.array;
    var x, y, z, n;
    for (var i = 0, il = normals.length; i < il; i += 3) {
      x = normals[i];
      y = normals[i + 1];
      z = normals[i + 2];
      n = 1 / Math.sqrt(x * x + y * y + z * z);
      normals[i] *= n;
      normals[i + 1] *= n;
      normals[i + 2] *= n;
    }
  },
  toNonIndexed: function () {
    if (this.index === null) {
      console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');
      return this;
    }
    var geometry2 = new THREE.BufferGeometry();
    var indices = this.index.array;
    var attributes = this.attributes;
    for (var name in attributes) {
      var attribute = attributes[name];
      var array = attribute.array;
      var itemSize = attribute.itemSize;
      var array2 = new array.constructor(indices.length * itemSize);
      var index = 0, index2 = 0;
      for (var i = 0, l = indices.length; i < l; i++) {
        index = indices[i] * itemSize;
        for (var j = 0; j < itemSize; j++) {
          array2[index2++] = array[index++];
        }
      }
      geometry2.addAttribute(name, new THREE.BufferAttribute(array2, itemSize));
    }
    return geometry2;
  },
  toJSON: function () {
    var data = {
      metadata: {
        version: 4.4,
        type: 'BufferGeometry',
        generator: 'BufferGeometry.toJSON'
      }
    };
    // standard BufferGeometry serialization
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== '')
      data.name = this.name;
    if (this.parameters !== undefined) {
      var parameters = this.parameters;
      for (var key in parameters) {
        if (parameters[key] !== undefined)
          data[key] = parameters[key];
      }
      return data;
    }
    data.data = { attributes: {} };
    var index = this.index;
    if (index !== null) {
      var array = Array.prototype.slice.call(index.array);
      data.data.index = {
        type: index.array.constructor.name,
        array: array
      };
    }
    var attributes = this.attributes;
    for (var key in attributes) {
      var attribute = attributes[key];
      var array = Array.prototype.slice.call(attribute.array);
      data.data.attributes[key] = {
        itemSize: attribute.itemSize,
        type: attribute.array.constructor.name,
        array: array
      };
    }
    var groups = this.groups;
    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }
    var boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }
    return data;
  },
  clone: function () {
    /*
    		// Handle primitives
    
    		var parameters = this.parameters;
    
    		if ( parameters !== undefined ) {
    
    			var values = [];
    
    			for ( var key in parameters ) {
    
    				values.push( parameters[ key ] );
    
    			}
    
    			var geometry = Object.create( this.constructor.prototype );
    			this.constructor.apply( geometry, values );
    			return geometry;
    
    		}
    
    		return new this.constructor().copy( this );
    		*/
    return new THREE.BufferGeometry().copy(this);
  },
  copy: function (source) {
    var index = source.index;
    if (index !== null) {
      this.setIndex(index.clone());
    }
    var attributes = source.attributes;
    for (var name in attributes) {
      var attribute = attributes[name];
      this.addAttribute(name, attribute.clone());
    }
    var groups = source.groups;
    for (var i = 0, l = groups.length; i < l; i++) {
      var group = groups[i];
      this.addGroup(group.start, group.count);
    }
    return this;
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  }
};
THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype);
THREE.BufferGeometry.MaxIndex = 65535;
// File:src/core/InstancedBufferGeometry.js
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */
THREE.InstancedBufferGeometry = function () {
  THREE.BufferGeometry.call(this);
  this.type = 'InstancedBufferGeometry';
  this.maxInstancedCount = undefined;
};
THREE.InstancedBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;
THREE.InstancedBufferGeometry.prototype.addGroup = function (start, count, instances) {
  this.groups.push({
    start: start,
    count: count,
    instances: instances
  });
};
THREE.InstancedBufferGeometry.prototype.copy = function (source) {
  var index = source.index;
  if (index !== null) {
    this.setIndex(index.clone());
  }
  var attributes = source.attributes;
  for (var name in attributes) {
    var attribute = attributes[name];
    this.addAttribute(name, attribute.clone());
  }
  var groups = source.groups;
  for (var i = 0, l = groups.length; i < l; i++) {
    var group = groups[i];
    this.addGroup(group.start, group.count, group.instances);
  }
  return this;
};
THREE.EventDispatcher.prototype.apply(THREE.InstancedBufferGeometry.prototype);
// File:src/core/Uniform.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
THREE.Uniform = function (type, value) {
  this.type = type;
  this.value = value;
  this.dynamic = false;
};
THREE.Uniform.prototype = {
  constructor: THREE.Uniform,
  onUpdate: function (callback) {
    this.dynamic = true;
    this.onUpdateCallback = callback;
    return this;
  }
};
// File:src/cameras/Camera.js
/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/
THREE.Camera = function () {
  THREE.Object3D.call(this);
  this.type = 'Camera';
  this.matrixWorldInverse = new THREE.Matrix4();
  this.projectionMatrix = new THREE.Matrix4();
};
THREE.Camera.prototype = Object.create(THREE.Object3D.prototype);
THREE.Camera.prototype.constructor = THREE.Camera;
THREE.Camera.prototype.getWorldDirection = function () {
  var quaternion = new THREE.Quaternion();
  return function (optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    this.getWorldQuaternion(quaternion);
    return result.set(0, 0, -1).applyQuaternion(quaternion);
  };
}();
THREE.Camera.prototype.lookAt = function () {
  // This routine does not support cameras with rotated and/or translated parent(s)
  var m1 = new THREE.Matrix4();
  return function (vector) {
    m1.lookAt(this.position, vector, this.up);
    this.quaternion.setFromRotationMatrix(m1);
  };
}();
THREE.Camera.prototype.clone = function () {
  return new this.constructor().copy(this);
};
THREE.Camera.prototype.copy = function (source) {
  THREE.Object3D.prototype.copy.call(this, source);
  this.matrixWorldInverse.copy(source.matrixWorldInverse);
  this.projectionMatrix.copy(source.projectionMatrix);
  return this;
};
// File:src/cameras/OrthographicCamera.js
/**
 * @author alteredq / http://alteredqualia.com/
 */
THREE.OrthographicCamera = function (left, right, top, bottom, near, far) {
  THREE.Camera.call(this);
  this.type = 'OrthographicCamera';
  this.zoom = 1;
  this.left = left;
  this.right = right;
  this.top = top;
  this.bottom = bottom;
  this.near = near !== undefined ? near : 0.1;
  this.far = far !== undefined ? far : 2000;
  this.updateProjectionMatrix();
};
THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;
THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {
  var dx = (this.right - this.left) / (2 * this.zoom);
  var dy = (this.top - this.bottom) / (2 * this.zoom);
  var cx = (this.right + this.left) / 2;
  var cy = (this.top + this.bottom) / 2;
  this.projectionMatrix.makeOrthographic(cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far);
};
THREE.OrthographicCamera.prototype.copy = function (source) {
  THREE.Camera.prototype.copy.call(this, source);
  this.left = source.left;
  this.right = source.right;
  this.top = source.top;
  this.bottom = source.bottom;
  this.near = source.near;
  this.far = source.far;
  this.zoom = source.zoom;
  return this;
};
THREE.OrthographicCamera.prototype.toJSON = function (meta) {
  var data = THREE.Object3D.prototype.toJSON.call(this, meta);
  data.object.zoom = this.zoom;
  data.object.left = this.left;
  data.object.right = this.right;
  data.object.top = this.top;
  data.object.bottom = this.bottom;
  data.object.near = this.near;
  data.object.far = this.far;
  return data;
};
// File:src/cameras/PerspectiveCamera.js
/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */
THREE.PerspectiveCamera = function (fov, aspect, near, far) {
  THREE.Camera.call(this);
  this.type = 'PerspectiveCamera';
  this.focalLength = 10;
  this.zoom = 1;
  this.fov = fov !== undefined ? fov : 50;
  this.aspect = aspect !== undefined ? aspect : 1;
  this.near = near !== undefined ? near : 0.1;
  this.far = far !== undefined ? far : 2000;
  this.updateProjectionMatrix();
};
THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;
/**
 * Uses Focal Length (in mm) to estimate and set FOV
 * 35mm (full-frame) camera is used if frame size is not specified;
 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
 */
THREE.PerspectiveCamera.prototype.setLens = function (focalLength, frameHeight) {
  if (frameHeight === undefined)
    frameHeight = 24;
  this.fov = 2 * THREE.Math.radToDeg(Math.atan(frameHeight / (focalLength * 2)));
  this.updateProjectionMatrix();
};
/**
 * Sets an offset in a larger frustum. This is useful for multi-window or
 * multi-monitor/multi-machine setups.
 *
 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
 * the monitors are in grid like this
 *
 *   +---+---+---+
 *   | A | B | C |
 *   +---+---+---+
 *   | D | E | F |
 *   +---+---+---+
 *
 * then for each monitor you would call it like this
 *
 *   var w = 1920;
 *   var h = 1080;
 *   var fullWidth = w * 3;
 *   var fullHeight = h * 2;
 *
 *   --A--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
 *   --B--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
 *   --C--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
 *   --D--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
 *   --E--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
 *   --F--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
 *
 *   Note there is no reason monitors have to be the same size or in a grid.
 */
THREE.PerspectiveCamera.prototype.setViewOffset = function (fullWidth, fullHeight, x, y, width, height) {
  this.fullWidth = fullWidth;
  this.fullHeight = fullHeight;
  this.x = x;
  this.y = y;
  this.width = width;
  this.height = height;
  this.updateProjectionMatrix();
};
THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {
  var fov = THREE.Math.radToDeg(2 * Math.atan(Math.tan(THREE.Math.degToRad(this.fov) * 0.5) / this.zoom));
  if (this.fullWidth) {
    var aspect = this.fullWidth / this.fullHeight;
    var top = Math.tan(THREE.Math.degToRad(fov * 0.5)) * this.near;
    var bottom = -top;
    var left = aspect * bottom;
    var right = aspect * top;
    var width = Math.abs(right - left);
    var height = Math.abs(top - bottom);
    this.projectionMatrix.makeFrustum(left + this.x * width / this.fullWidth, left + (this.x + this.width) * width / this.fullWidth, top - (this.y + this.height) * height / this.fullHeight, top - this.y * height / this.fullHeight, this.near, this.far);
  } else {
    this.projectionMatrix.makePerspective(fov, this.aspect, this.near, this.far);
  }
};
THREE.PerspectiveCamera.prototype.copy = function (source) {
  THREE.Camera.prototype.copy.call(this, source);
  this.focalLength = source.focalLength;
  this.zoom = source.zoom;
  this.fov = source.fov;
  this.aspect = source.aspect;
  this.near = source.near;
  this.far = source.far;
  return this;
};
THREE.PerspectiveCamera.prototype.toJSON = function (meta) {
  var data = THREE.Object3D.prototype.toJSON.call(this, meta);
  data.object.focalLength = this.focalLength;
  data.object.zoom = this.zoom;
  data.object.fov = this.fov;
  data.object.aspect = this.aspect;
  data.object.near = this.near;
  data.object.far = this.far;
  return data;
};
// File:src/lights/Light.js
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */
THREE.Light = function (color, intensity) {
  THREE.Object3D.call(this);
  this.type = 'Light';
  this.color = new THREE.Color(color);
  this.intensity = intensity !== undefined ? intensity : 1;
  this.receiveShadow = undefined;
};
THREE.Light.prototype = Object.create(THREE.Object3D.prototype);
THREE.Light.prototype.constructor = THREE.Light;
THREE.Light.prototype.copy = function (source) {
  THREE.Object3D.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.intensity = source.intensity;
  return this;
};
THREE.Light.prototype.toJSON = function (meta) {
  var data = THREE.Object3D.prototype.toJSON.call(this, meta);
  data.object.color = this.color.getHex();
  data.object.intensity = this.intensity;
  if (this.groundColor !== undefined)
    data.object.groundColor = this.groundColor.getHex();
  if (this.distance !== undefined)
    data.object.distance = this.distance;
  if (this.angle !== undefined)
    data.object.angle = this.angle;
  if (this.decay !== undefined)
    data.object.decay = this.decay;
  if (this.penumbra !== undefined)
    data.object.penumbra = this.penumbra;
  return data;
};
// File:src/lights/LightShadow.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
THREE.LightShadow = function (camera) {
  this.camera = camera;
  this.bias = 0;
  this.radius = 1;
  this.mapSize = new THREE.Vector2(512, 512);
  this.map = null;
  this.matrix = new THREE.Matrix4();
};
THREE.LightShadow.prototype = {
  constructor: THREE.LightShadow,
  copy: function (source) {
    this.camera = source.camera.clone();
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  }
};
// File:src/lights/AmbientLight.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
THREE.AmbientLight = function (color, intensity) {
  THREE.Light.call(this, color, intensity);
  this.type = 'AmbientLight';
  this.castShadow = undefined;
};
THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);
THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;
// File:src/lights/DirectionalLight.js
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */
THREE.DirectionalLight = function (color, intensity) {
  THREE.Light.call(this, color, intensity);
  this.type = 'DirectionalLight';
  this.position.set(0, 1, 0);
  this.updateMatrix();
  this.target = new THREE.Object3D();
  this.shadow = new THREE.LightShadow(new THREE.OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
};
THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);
THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;
THREE.DirectionalLight.prototype.copy = function (source) {
  THREE.Light.prototype.copy.call(this, source);
  this.target = source.target.clone();
  this.shadow = source.shadow.clone();
  return this;
};
// File:src/lights/PointLight.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
THREE.PointLight = function (color, intensity, distance, decay) {
  THREE.Light.call(this, color, intensity);
  this.type = 'PointLight';
  this.distance = distance !== undefined ? distance : 0;
  this.decay = decay !== undefined ? decay : 1;
  // for physically correct lights, should be 2.
  this.shadow = new THREE.LightShadow(new THREE.PerspectiveCamera(90, 1, 0.5, 500));
};
THREE.PointLight.prototype = Object.create(THREE.Light.prototype);
THREE.PointLight.prototype.constructor = THREE.PointLight;
Object.defineProperty(THREE.PointLight.prototype, 'power', {
  get: function () {
    // intensity = power per solid angle.
    // ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
    return this.intensity * 4 * Math.PI;
  },
  set: function (power) {
    // intensity = power per solid angle.
    // ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
    this.intensity = power / (4 * Math.PI);
  }
});
THREE.PointLight.prototype.copy = function (source) {
  THREE.Light.prototype.copy.call(this, source);
  this.distance = source.distance;
  this.decay = source.decay;
  this.shadow = source.shadow.clone();
  return this;
};
// File:src/lights/SpotLight.js
/**
 * @author alteredq / http://alteredqualia.com/
 */
THREE.SpotLight = function (color, intensity, distance, angle, penumbra, decay) {
  THREE.Light.call(this, color, intensity);
  this.type = 'SpotLight';
  this.position.set(0, 1, 0);
  this.updateMatrix();
  this.target = new THREE.Object3D();
  this.distance = distance !== undefined ? distance : 0;
  this.angle = angle !== undefined ? angle : Math.PI / 3;
  this.penumbra = penumbra !== undefined ? penumbra : 0;
  this.decay = decay !== undefined ? decay : 1;
  // for physically correct lights, should be 2.
  this.shadow = new THREE.LightShadow(new THREE.PerspectiveCamera(50, 1, 0.5, 500));
};
THREE.SpotLight.prototype = Object.create(THREE.Light.prototype);
THREE.SpotLight.prototype.constructor = THREE.SpotLight;
Object.defineProperty(THREE.SpotLight.prototype, 'power', {
  get: function () {
    // intensity = power per solid angle.
    // ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
    return this.intensity * Math.PI;
  },
  set: function (power) {
    // intensity = power per solid angle.
    // ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
    this.intensity = power / Math.PI;
  }
});
THREE.SpotLight.prototype.copy = function (source) {
  THREE.Light.prototype.copy.call(this, source);
  this.distance = source.distance;
  this.angle = source.angle;
  this.penumbra = source.penumbra;
  this.decay = source.decay;
  this.target = source.target.clone();
  this.shadow = source.shadow.clone();
  return this;
};
// File:src/loaders/Cache.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
THREE.Cache = {
  enabled: false,
  files: {},
  add: function (key, file) {
    if (this.enabled === false)
      return;
    this.files[key] = file;
  },
  get: function (key) {
    if (this.enabled === false)
      return;
    return this.files[key];
  },
  remove: function (key) {
    delete this.files[key];
  },
  clear: function () {
    this.files = {};
  }
};
// File:src/loaders/Loader.js
/**
 * @author alteredq / http://alteredqualia.com/
 */
THREE.Loader = function () {
  this.onLoadStart = function () {
  };
  this.onLoadProgress = function () {
  };
  this.onLoadComplete = function () {
  };
};
THREE.Loader.prototype = {
  constructor: THREE.Loader,
  crossOrigin: undefined,
  extractUrlBase: function (url) {
    var parts = url.split('/');
    if (parts.length === 1)
      return './';
    parts.pop();
    return parts.join('/') + '/';
  },
  initMaterials: function (materials, texturePath, crossOrigin) {
    var array = [];
    for (var i = 0; i < materials.length; ++i) {
      array[i] = this.createMaterial(materials[i], texturePath, crossOrigin);
    }
    return array;
  },
  createMaterial: function () {
    var color, textureLoader, materialLoader;
    return function (m, texturePath, crossOrigin) {
      if (color === undefined)
        color = new THREE.Color();
      if (textureLoader === undefined)
        textureLoader = new THREE.TextureLoader();
      if (materialLoader === undefined)
        materialLoader = new THREE.MaterialLoader();
      // convert from old material format
      var textures = {};
      function loadTexture(path, repeat, offset, wrap, anisotropy) {
        var fullPath = texturePath + path;
        var loader = THREE.Loader.Handlers.get(fullPath);
        var texture;
        if (loader !== null) {
          texture = loader.load(fullPath);
        } else {
          textureLoader.setCrossOrigin(crossOrigin);
          texture = textureLoader.load(fullPath);
        }
        if (repeat !== undefined) {
          texture.repeat.fromArray(repeat);
          if (repeat[0] !== 1)
            texture.wrapS = THREE.RepeatWrapping;
          if (repeat[1] !== 1)
            texture.wrapT = THREE.RepeatWrapping;
        }
        if (offset !== undefined) {
          texture.offset.fromArray(offset);
        }
        if (wrap !== undefined) {
          if (wrap[0] === 'repeat')
            texture.wrapS = THREE.RepeatWrapping;
          if (wrap[0] === 'mirror')
            texture.wrapS = THREE.MirroredRepeatWrapping;
          if (wrap[1] === 'repeat')
            texture.wrapT = THREE.RepeatWrapping;
          if (wrap[1] === 'mirror')
            texture.wrapT = THREE.MirroredRepeatWrapping;
        }
        if (anisotropy !== undefined) {
          texture.anisotropy = anisotropy;
        }
        var uuid = THREE.Math.generateUUID();
        textures[uuid] = texture;
        return uuid;
      }
      //
      var json = {
        uuid: THREE.Math.generateUUID(),
        type: 'MeshLambertMaterial'
      };
      for (var name in m) {
        var value = m[name];
        switch (name) {
        case 'DbgColor':
        case 'DbgIndex':
        case 'opticalDensity':
        case 'illumination':
          break;
        case 'DbgName':
          json.name = value;
          break;
        case 'blending':
          json.blending = THREE[value];
          break;
        case 'colorAmbient':
        case 'mapAmbient':
          console.warn('THREE.Loader.createMaterial:', name, 'is no longer supported.');
          break;
        case 'colorDiffuse':
          json.color = color.fromArray(value).getHex();
          break;
        case 'colorSpecular':
          json.specular = color.fromArray(value).getHex();
          break;
        case 'colorEmissive':
          json.emissive = color.fromArray(value).getHex();
          break;
        case 'specularCoef':
          json.shininess = value;
          break;
        case 'shading':
          if (value.toLowerCase() === 'basic')
            json.type = 'MeshBasicMaterial';
          if (value.toLowerCase() === 'phong')
            json.type = 'MeshPhongMaterial';
          break;
        case 'mapDiffuse':
          json.map = loadTexture(value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
          break;
        case 'mapDiffuseRepeat':
        case 'mapDiffuseOffset':
        case 'mapDiffuseWrap':
        case 'mapDiffuseAnisotropy':
          break;
        case 'mapLight':
          json.lightMap = loadTexture(value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
          break;
        case 'mapLightRepeat':
        case 'mapLightOffset':
        case 'mapLightWrap':
        case 'mapLightAnisotropy':
          break;
        case 'mapAO':
          json.aoMap = loadTexture(value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);
          break;
        case 'mapAORepeat':
        case 'mapAOOffset':
        case 'mapAOWrap':
        case 'mapAOAnisotropy':
          break;
        case 'mapBump':
          json.bumpMap = loadTexture(value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
          break;
        case 'mapBumpScale':
          json.bumpScale = value;
          break;
        case 'mapBumpRepeat':
        case 'mapBumpOffset':
        case 'mapBumpWrap':
        case 'mapBumpAnisotropy':
          break;
        case 'mapNormal':
          json.normalMap = loadTexture(value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
          break;
        case 'mapNormalFactor':
          json.normalScale = [
            value,
            value
          ];
          break;
        case 'mapNormalRepeat':
        case 'mapNormalOffset':
        case 'mapNormalWrap':
        case 'mapNormalAnisotropy':
          break;
        case 'mapSpecular':
          json.specularMap = loadTexture(value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
          break;
        case 'mapSpecularRepeat':
        case 'mapSpecularOffset':
        case 'mapSpecularWrap':
        case 'mapSpecularAnisotropy':
          break;
        case 'mapAlpha':
          json.alphaMap = loadTexture(value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
          break;
        case 'mapAlphaRepeat':
        case 'mapAlphaOffset':
        case 'mapAlphaWrap':
        case 'mapAlphaAnisotropy':
          break;
        case 'flipSided':
          json.side = THREE.BackSide;
          break;
        case 'doubleSided':
          json.side = THREE.DoubleSide;
          break;
        case 'transparency':
          console.warn('THREE.Loader.createMaterial: transparency has been renamed to opacity');
          json.opacity = value;
          break;
        case 'depthTest':
        case 'depthWrite':
        case 'colorWrite':
        case 'opacity':
        case 'reflectivity':
        case 'transparent':
        case 'visible':
        case 'wireframe':
          json[name] = value;
          break;
        case 'vertexColors':
          if (value === true)
            json.vertexColors = THREE.VertexColors;
          if (value === 'face')
            json.vertexColors = THREE.FaceColors;
          break;
        default:
          console.error('THREE.Loader.createMaterial: Unsupported', name, value);
          break;
        }
      }
      if (json.type === 'MeshBasicMaterial')
        delete json.emissive;
      if (json.type !== 'MeshPhongMaterial')
        delete json.specular;
      if (json.opacity < 1)
        json.transparent = true;
      materialLoader.setTextures(textures);
      return materialLoader.parse(json);
    };
  }()
};
THREE.Loader.Handlers = {
  handlers: [],
  add: function (regex, loader) {
    this.handlers.push(regex, loader);
  },
  get: function (file) {
    var handlers = this.handlers;
    for (var i = 0, l = handlers.length; i < l; i += 2) {
      var regex = handlers[i];
      var loader = handlers[i + 1];
      if (regex.test(file)) {
        return loader;
      }
    }
    return null;
  }
};
// File:src/loaders/XHRLoader.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
THREE.XHRLoader = function (manager) {
  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};
THREE.XHRLoader.prototype = {
  constructor: THREE.XHRLoader,
  load: function (url, onLoad, onProgress, onError) {
    if (this.path !== undefined)
      url = this.path + url;
    var scope = this;
    var cached = THREE.Cache.get(url);
    if (cached !== undefined) {
      if (onLoad) {
        setTimeout(function () {
          onLoad(cached);
        }, 0);
      }
      return cached;
    }
    var request = new XMLHttpRequest();
    request.overrideMimeType('text/plain');
    request.open('GET', url, true);
    request.addEventListener('load', function (event) {
      var response = event.target.response;
      THREE.Cache.add(url, response);
      if (this.status === 200) {
        if (onLoad)
          onLoad(response);
        scope.manager.itemEnd(url);
      } else if (this.status === 0) {
        // Some browsers return HTTP Status 0 when using non-http protocol
        // e.g. 'file://' or 'data://'. Handle as success.
        console.warn('THREE.XHRLoader: HTTP Status 0 received.');
        if (onLoad)
          onLoad(response);
        scope.manager.itemEnd(url);
      } else {
        if (onError)
          onError(event);
        scope.manager.itemError(url);
      }
    }, false);
    if (onProgress !== undefined) {
      request.addEventListener('progress', function (event) {
        onProgress(event);
      }, false);
    }
    request.addEventListener('error', function (event) {
      if (onError)
        onError(event);
      scope.manager.itemError(url);
    }, false);
    if (this.responseType !== undefined)
      request.responseType = this.responseType;
    if (this.withCredentials !== undefined)
      request.withCredentials = this.withCredentials;
    request.send(null);
    scope.manager.itemStart(url);
    return request;
  },
  setPath: function (value) {
    this.path = value;
  },
  setResponseType: function (value) {
    this.responseType = value;
  },
  setWithCredentials: function (value) {
    this.withCredentials = value;
  }
};
// File:src/loaders/JSONLoader.js
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */
THREE.JSONLoader = function (manager) {
  if (typeof manager === 'boolean') {
    console.warn('THREE.JSONLoader: showStatus parameter has been removed from constructor.');
    manager = undefined;
  }
  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
  this.withCredentials = false;
};
THREE.JSONLoader.prototype = {
  constructor: THREE.JSONLoader,
  // Deprecated
  get statusDomElement() {
    if (this._statusDomElement === undefined) {
      this._statusDomElement = document.createElement('div');
    }
    console.warn('THREE.JSONLoader: .statusDomElement has been removed.');
    return this._statusDomElement;
  },
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var texturePath = this.texturePath && typeof this.texturePath === 'string' ? this.texturePath : THREE.Loader.prototype.extractUrlBase(url);
    var loader = new THREE.XHRLoader(this.manager);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function (text) {
      var json = JSON.parse(text);
      var metadata = json.metadata;
      if (metadata !== undefined) {
        var type = metadata.type;
        if (type !== undefined) {
          if (type.toLowerCase() === 'object') {
            console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.');
            return;
          }
          if (type.toLowerCase() === 'scene') {
            console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.');
            return;
          }
        }
      }
      var object = scope.parse(json, texturePath);
      onLoad(object.geometry, object.materials);
    }, onProgress, onError);
  },
  setTexturePath: function (value) {
    this.texturePath = value;
  },
  parse: function (json, texturePath) {
    var geometry = new THREE.Geometry(), scale = json.scale !== undefined ? 1 / json.scale : 1;
    parseModel(scale);
    parseSkin();
    parseMorphing(scale);
    parseAnimations();
    geometry.computeFaceNormals();
    geometry.computeBoundingSphere();
    function parseModel(scale) {
      function isBitSet(value, position) {
        return value & 1 << position;
      }
      var i, j, fi, offset, zLength, colorIndex, normalIndex, uvIndex, materialIndex, type, isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor, vertex, face, faceA, faceB, hex, normal, uvLayer, uv, u, v, faces = json.faces, vertices = json.vertices, normals = json.normals, colors = json.colors, nUvLayers = 0;
      if (json.uvs !== undefined) {
        // disregard empty arrays
        for (i = 0; i < json.uvs.length; i++) {
          if (json.uvs[i].length)
            nUvLayers++;
        }
        for (i = 0; i < nUvLayers; i++) {
          geometry.faceVertexUvs[i] = [];
        }
      }
      offset = 0;
      zLength = vertices.length;
      while (offset < zLength) {
        vertex = new THREE.Vector3();
        vertex.x = vertices[offset++] * scale;
        vertex.y = vertices[offset++] * scale;
        vertex.z = vertices[offset++] * scale;
        geometry.vertices.push(vertex);
      }
      offset = 0;
      zLength = faces.length;
      while (offset < zLength) {
        type = faces[offset++];
        isQuad = isBitSet(type, 0);
        hasMaterial = isBitSet(type, 1);
        hasFaceVertexUv = isBitSet(type, 3);
        hasFaceNormal = isBitSet(type, 4);
        hasFaceVertexNormal = isBitSet(type, 5);
        hasFaceColor = isBitSet(type, 6);
        hasFaceVertexColor = isBitSet(type, 7);
        if (isQuad) {
          faceA = new THREE.Face3();
          faceA.a = faces[offset];
          faceA.b = faces[offset + 1];
          faceA.c = faces[offset + 3];
          faceB = new THREE.Face3();
          faceB.a = faces[offset + 1];
          faceB.b = faces[offset + 2];
          faceB.c = faces[offset + 3];
          offset += 4;
          if (hasMaterial) {
            materialIndex = faces[offset++];
            faceA.materialIndex = materialIndex;
            faceB.materialIndex = materialIndex;
          }
          // to get face <=> uv index correspondence
          fi = geometry.faces.length;
          if (hasFaceVertexUv) {
            for (i = 0; i < nUvLayers; i++) {
              uvLayer = json.uvs[i];
              geometry.faceVertexUvs[i][fi] = [];
              geometry.faceVertexUvs[i][fi + 1] = [];
              for (j = 0; j < 4; j++) {
                uvIndex = faces[offset++];
                u = uvLayer[uvIndex * 2];
                v = uvLayer[uvIndex * 2 + 1];
                uv = new THREE.Vector2(u, v);
                if (j !== 2)
                  geometry.faceVertexUvs[i][fi].push(uv);
                if (j !== 0)
                  geometry.faceVertexUvs[i][fi + 1].push(uv);
              }
            }
          }
          if (hasFaceNormal) {
            normalIndex = faces[offset++] * 3;
            faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
            faceB.normal.copy(faceA.normal);
          }
          if (hasFaceVertexNormal) {
            for (i = 0; i < 4; i++) {
              normalIndex = faces[offset++] * 3;
              normal = new THREE.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
              if (i !== 2)
                faceA.vertexNormals.push(normal);
              if (i !== 0)
                faceB.vertexNormals.push(normal);
            }
          }
          if (hasFaceColor) {
            colorIndex = faces[offset++];
            hex = colors[colorIndex];
            faceA.color.setHex(hex);
            faceB.color.setHex(hex);
          }
          if (hasFaceVertexColor) {
            for (i = 0; i < 4; i++) {
              colorIndex = faces[offset++];
              hex = colors[colorIndex];
              if (i !== 2)
                faceA.vertexColors.push(new THREE.Color(hex));
              if (i !== 0)
                faceB.vertexColors.push(new THREE.Color(hex));
            }
          }
          geometry.faces.push(faceA);
          geometry.faces.push(faceB);
        } else {
          face = new THREE.Face3();
          face.a = faces[offset++];
          face.b = faces[offset++];
          face.c = faces[offset++];
          if (hasMaterial) {
            materialIndex = faces[offset++];
            face.materialIndex = materialIndex;
          }
          // to get face <=> uv index correspondence
          fi = geometry.faces.length;
          if (hasFaceVertexUv) {
            for (i = 0; i < nUvLayers; i++) {
              uvLayer = json.uvs[i];
              geometry.faceVertexUvs[i][fi] = [];
              for (j = 0; j < 3; j++) {
                uvIndex = faces[offset++];
                u = uvLayer[uvIndex * 2];
                v = uvLayer[uvIndex * 2 + 1];
                uv = new THREE.Vector2(u, v);
                geometry.faceVertexUvs[i][fi].push(uv);
              }
            }
          }
          if (hasFaceNormal) {
            normalIndex = faces[offset++] * 3;
            face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
          }
          if (hasFaceVertexNormal) {
            for (i = 0; i < 3; i++) {
              normalIndex = faces[offset++] * 3;
              normal = new THREE.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
              face.vertexNormals.push(normal);
            }
          }
          if (hasFaceColor) {
            colorIndex = faces[offset++];
            face.color.setHex(colors[colorIndex]);
          }
          if (hasFaceVertexColor) {
            for (i = 0; i < 3; i++) {
              colorIndex = faces[offset++];
              face.vertexColors.push(new THREE.Color(colors[colorIndex]));
            }
          }
          geometry.faces.push(face);
        }
      }
    }
    function parseSkin() {
      var influencesPerVertex = json.influencesPerVertex !== undefined ? json.influencesPerVertex : 2;
      if (json.skinWeights) {
        for (var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex) {
          var x = json.skinWeights[i];
          var y = influencesPerVertex > 1 ? json.skinWeights[i + 1] : 0;
          var z = influencesPerVertex > 2 ? json.skinWeights[i + 2] : 0;
          var w = influencesPerVertex > 3 ? json.skinWeights[i + 3] : 0;
          geometry.skinWeights.push(new THREE.Vector4(x, y, z, w));
        }
      }
      if (json.skinIndices) {
        for (var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex) {
          var a = json.skinIndices[i];
          var b = influencesPerVertex > 1 ? json.skinIndices[i + 1] : 0;
          var c = influencesPerVertex > 2 ? json.skinIndices[i + 2] : 0;
          var d = influencesPerVertex > 3 ? json.skinIndices[i + 3] : 0;
          geometry.skinIndices.push(new THREE.Vector4(a, b, c, d));
        }
      }
      geometry.bones = json.bones;
      if (geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length)) {
        console.warn('When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' + geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.');
      }
    }
    function parseMorphing(scale) {
      if (json.morphTargets !== undefined) {
        for (var i = 0, l = json.morphTargets.length; i < l; i++) {
          geometry.morphTargets[i] = {};
          geometry.morphTargets[i].name = json.morphTargets[i].name;
          geometry.morphTargets[i].vertices = [];
          var dstVertices = geometry.morphTargets[i].vertices;
          var srcVertices = json.morphTargets[i].vertices;
          for (var v = 0, vl = srcVertices.length; v < vl; v += 3) {
            var vertex = new THREE.Vector3();
            vertex.x = srcVertices[v] * scale;
            vertex.y = srcVertices[v + 1] * scale;
            vertex.z = srcVertices[v + 2] * scale;
            dstVertices.push(vertex);
          }
        }
      }
      if (json.morphColors !== undefined && json.morphColors.length > 0) {
        console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
        var faces = geometry.faces;
        var morphColors = json.morphColors[0].colors;
        for (var i = 0, l = faces.length; i < l; i++) {
          faces[i].color.fromArray(morphColors, i * 3);
        }
      }
    }
    function parseAnimations() {
      var outputAnimations = [];
      // parse old style Bone/Hierarchy animations
      var animations = [];
      if (json.animation !== undefined) {
        animations.push(json.animation);
      }
      if (json.animations !== undefined) {
        if (json.animations.length) {
          animations = animations.concat(json.animations);
        } else {
          animations.push(json.animations);
        }
      }
      for (var i = 0; i < animations.length; i++) {
        var clip = THREE.AnimationClip.parseAnimation(animations[i], geometry.bones);
        if (clip)
          outputAnimations.push(clip);
      }
      // parse implicit morph animations
      if (geometry.morphTargets) {
        // TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
        var morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);
        outputAnimations = outputAnimations.concat(morphAnimationClips);
      }
      if (outputAnimations.length > 0)
        geometry.animations = outputAnimations;
    }
    if (json.materials === undefined || json.materials.length === 0) {
      return { geometry: geometry };
    } else {
      var materials = THREE.Loader.prototype.initMaterials(json.materials, texturePath, this.crossOrigin);
      return {
        geometry: geometry,
        materials: materials
      };
    }
  }
};
// File:src/loaders/LoadingManager.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
THREE.LoadingManager = function (onLoad, onProgress, onError) {
  var scope = this;
  var isLoading = false, itemsLoaded = 0, itemsTotal = 0;
  this.onStart = undefined;
  this.onLoad = onLoad;
  this.onProgress = onProgress;
  this.onError = onError;
  this.itemStart = function (url) {
    itemsTotal++;
    if (isLoading === false) {
      if (scope.onStart !== undefined) {
        scope.onStart(url, itemsLoaded, itemsTotal);
      }
    }
    isLoading = true;
  };
  this.itemEnd = function (url) {
    itemsLoaded++;
    if (scope.onProgress !== undefined) {
      scope.onProgress(url, itemsLoaded, itemsTotal);
    }
    if (itemsLoaded === itemsTotal) {
      isLoading = false;
      if (scope.onLoad !== undefined) {
        scope.onLoad();
      }
    }
  };
  this.itemError = function (url) {
    if (scope.onError !== undefined) {
      scope.onError(url);
    }
  };
};
THREE.DefaultLoadingManager = new THREE.LoadingManager();
// File:src/loaders/BufferGeometryLoader.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
THREE.BufferGeometryLoader = function (manager) {
  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};
THREE.BufferGeometryLoader.prototype = {
  constructor: THREE.BufferGeometryLoader,
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new THREE.XHRLoader(scope.manager);
    loader.load(url, function (text) {
      onLoad(scope.parse(JSON.parse(text)));
    }, onProgress, onError);
  },
  parse: function (json) {
    var geometry = new THREE.BufferGeometry();
    var index = json.data.index;
    var TYPED_ARRAYS = {
      'Int8Array': Int8Array,
      'Uint8Array': Uint8Array,
      'Uint8ClampedArray': Uint8ClampedArray,
      'Int16Array': Int16Array,
      'Uint16Array': Uint16Array,
      'Int32Array': Int32Array,
      'Uint32Array': Uint32Array,
      'Float32Array': Float32Array,
      'Float64Array': Float64Array
    };
    if (index !== undefined) {
      var typedArray = new TYPED_ARRAYS[index.type](index.array);
      geometry.setIndex(new THREE.BufferAttribute(typedArray, 1));
    }
    var attributes = json.data.attributes;
    for (var key in attributes) {
      var attribute = attributes[key];
      var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
      geometry.addAttribute(key, new THREE.BufferAttribute(typedArray, attribute.itemSize));
    }
    var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
    if (groups !== undefined) {
      for (var i = 0, n = groups.length; i !== n; ++i) {
        var group = groups[i];
        geometry.addGroup(group.start, group.count, group.materialIndex);
      }
    }
    var boundingSphere = json.data.boundingSphere;
    if (boundingSphere !== undefined) {
      var center = new THREE.Vector3();
      if (boundingSphere.center !== undefined) {
        center.fromArray(boundingSphere.center);
      }
      geometry.boundingSphere = new THREE.Sphere(center, boundingSphere.radius);
    }
    return geometry;
  }
};
// File:src/loaders/MaterialLoader.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
THREE.MaterialLoader = function (manager) {
  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
  this.textures = {};
};
THREE.MaterialLoader.prototype = {
  constructor: THREE.MaterialLoader,
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new THREE.XHRLoader(scope.manager);
    loader.load(url, function (text) {
      onLoad(scope.parse(JSON.parse(text)));
    }, onProgress, onError);
  },
  setTextures: function (value) {
    this.textures = value;
  },
  getTexture: function (name) {
    var textures = this.textures;
    if (textures[name] === undefined) {
      console.warn('THREE.MaterialLoader: Undefined texture', name);
    }
    return textures[name];
  },
  parse: function (json) {
    var material = new THREE[json.type]();
    if (json.uuid !== undefined)
      material.uuid = json.uuid;
    if (json.name !== undefined)
      material.name = json.name;
    if (json.color !== undefined)
      material.color.setHex(json.color);
    if (json.roughness !== undefined)
      material.roughness = json.roughness;
    if (json.metalness !== undefined)
      material.metalness = json.metalness;
    if (json.emissive !== undefined)
      material.emissive.setHex(json.emissive);
    if (json.specular !== undefined)
      material.specular.setHex(json.specular);
    if (json.shininess !== undefined)
      material.shininess = json.shininess;
    if (json.uniforms !== undefined)
      material.uniforms = json.uniforms;
    if (json.vertexShader !== undefined)
      material.vertexShader = json.vertexShader;
    if (json.fragmentShader !== undefined)
      material.fragmentShader = json.fragmentShader;
    if (json.vertexColors !== undefined)
      material.vertexColors = json.vertexColors;
    if (json.shading !== undefined)
      material.shading = json.shading;
    if (json.blending !== undefined)
      material.blending = json.blending;
    if (json.side !== undefined)
      material.side = json.side;
    if (json.opacity !== undefined)
      material.opacity = json.opacity;
    if (json.transparent !== undefined)
      material.transparent = json.transparent;
    if (json.alphaTest !== undefined)
      material.alphaTest = json.alphaTest;
    if (json.depthTest !== undefined)
      material.depthTest = json.depthTest;
    if (json.depthWrite !== undefined)
      material.depthWrite = json.depthWrite;
    if (json.colorWrite !== undefined)
      material.colorWrite = json.colorWrite;
    if (json.wireframe !== undefined)
      material.wireframe = json.wireframe;
    if (json.wireframeLinewidth !== undefined)
      material.wireframeLinewidth = json.wireframeLinewidth;
    // for PointsMaterial
    if (json.size !== undefined)
      material.size = json.size;
    if (json.sizeAttenuation !== undefined)
      material.sizeAttenuation = json.sizeAttenuation;
    // maps
    if (json.map !== undefined)
      material.map = this.getTexture(json.map);
    if (json.alphaMap !== undefined) {
      material.alphaMap = this.getTexture(json.alphaMap);
      material.transparent = true;
    }
    if (json.bumpMap !== undefined)
      material.bumpMap = this.getTexture(json.bumpMap);
    if (json.bumpScale !== undefined)
      material.bumpScale = json.bumpScale;
    if (json.normalMap !== undefined)
      material.normalMap = this.getTexture(json.normalMap);
    if (json.normalScale !== undefined) {
      var normalScale = json.normalScale;
      if (Array.isArray(normalScale) === false) {
        // Blender exporter used to export a scalar. See #7459
        normalScale = [
          normalScale,
          normalScale
        ];
      }
      material.normalScale = new THREE.Vector2().fromArray(normalScale);
    }
    if (json.displacementMap !== undefined)
      material.displacementMap = this.getTexture(json.displacementMap);
    if (json.displacementScale !== undefined)
      material.displacementScale = json.displacementScale;
    if (json.displacementBias !== undefined)
      material.displacementBias = json.displacementBias;
    if (json.roughnessMap !== undefined)
      material.roughnessMap = this.getTexture(json.roughnessMap);
    if (json.metalnessMap !== undefined)
      material.metalnessMap = this.getTexture(json.metalnessMap);
    if (json.emissiveMap !== undefined)
      material.emissiveMap = this.getTexture(json.emissiveMap);
    if (json.emissiveIntensity !== undefined)
      material.emissiveIntensity = json.emissiveIntensity;
    if (json.specularMap !== undefined)
      material.specularMap = this.getTexture(json.specularMap);
    if (json.envMap !== undefined) {
      material.envMap = this.getTexture(json.envMap);
      material.combine = THREE.MultiplyOperation;
    }
    if (json.reflectivity)
      material.reflectivity = json.reflectivity;
    if (json.lightMap !== undefined)
      material.lightMap = this.getTexture(json.lightMap);
    if (json.lightMapIntensity !== undefined)
      material.lightMapIntensity = json.lightMapIntensity;
    if (json.aoMap !== undefined)
      material.aoMap = this.getTexture(json.aoMap);
    if (json.aoMapIntensity !== undefined)
      material.aoMapIntensity = json.aoMapIntensity;
    // MultiMaterial
    if (json.materials !== undefined) {
      for (var i = 0, l = json.materials.length; i < l; i++) {
        material.materials.push(this.parse(json.materials[i]));
      }
    }
    return material;
  }
};
// File:src/loaders/ObjectLoader.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
THREE.ObjectLoader = function (manager) {
  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
  this.texturePath = '';
};
THREE.ObjectLoader.prototype = {
  constructor: THREE.ObjectLoader,
  load: function (url, onLoad, onProgress, onError) {
    if (this.texturePath === '') {
      this.texturePath = url.substring(0, url.lastIndexOf('/') + 1);
    }
    var scope = this;
    var loader = new THREE.XHRLoader(scope.manager);
    loader.load(url, function (text) {
      scope.parse(JSON.parse(text), onLoad);
    }, onProgress, onError);
  },
  setTexturePath: function (value) {
    this.texturePath = value;
  },
  setCrossOrigin: function (value) {
    this.crossOrigin = value;
  },
  parse: function (json, onLoad) {
    var geometries = this.parseGeometries(json.geometries);
    var images = this.parseImages(json.images, function () {
      if (onLoad !== undefined)
        onLoad(object);
    });
    var textures = this.parseTextures(json.textures, images);
    var materials = this.parseMaterials(json.materials, textures);
    var object = this.parseObject(json.object, geometries, materials);
    if (json.animations) {
      object.animations = this.parseAnimations(json.animations);
    }
    if (json.images === undefined || json.images.length === 0) {
      if (onLoad !== undefined)
        onLoad(object);
    }
    return object;
  },
  parseGeometries: function (json) {
    var geometries = {};
    if (json !== undefined) {
      var geometryLoader = new THREE.JSONLoader();
      var bufferGeometryLoader = new THREE.BufferGeometryLoader();
      for (var i = 0, l = json.length; i < l; i++) {
        var geometry;
        var data = json[i];
        switch (data.type) {
        case 'PlaneGeometry':
        case 'PlaneBufferGeometry':
          geometry = new THREE[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
          break;
        case 'BoxGeometry':
        case 'BoxBufferGeometry':
        case 'CubeGeometry':
          // backwards compatible
          geometry = new THREE[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
          break;
        case 'CircleGeometry':
        case 'CircleBufferGeometry':
          geometry = new THREE[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
          break;
        case 'CylinderGeometry':
        case 'CylinderBufferGeometry':
          geometry = new THREE[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
          break;
        case 'SphereGeometry':
        case 'SphereBufferGeometry':
          geometry = new THREE[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
          break;
        case 'DodecahedronGeometry':
          geometry = new THREE.DodecahedronGeometry(data.radius, data.detail);
          break;
        case 'IcosahedronGeometry':
          geometry = new THREE.IcosahedronGeometry(data.radius, data.detail);
          break;
        case 'OctahedronGeometry':
          geometry = new THREE.OctahedronGeometry(data.radius, data.detail);
          break;
        case 'TetrahedronGeometry':
          geometry = new THREE.TetrahedronGeometry(data.radius, data.detail);
          break;
        case 'RingGeometry':
        case 'RingBufferGeometry':
          geometry = new THREE[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
          break;
        case 'TorusGeometry':
        case 'TorusBufferGeometry':
          geometry = new THREE[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
          break;
        case 'TorusKnotGeometry':
        case 'TorusKnotBufferGeometry':
          geometry = new THREE[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
          break;
        case 'LatheGeometry':
          geometry = new THREE.LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
          break;
        case 'BufferGeometry':
          geometry = bufferGeometryLoader.parse(data);
          break;
        case 'Geometry':
          geometry = geometryLoader.parse(data.data, this.texturePath).geometry;
          break;
        default:
          console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
          continue;
        }
        geometry.uuid = data.uuid;
        if (data.name !== undefined)
          geometry.name = data.name;
        geometries[data.uuid] = geometry;
      }
    }
    return geometries;
  },
  parseMaterials: function (json, textures) {
    var materials = {};
    if (json !== undefined) {
      var loader = new THREE.MaterialLoader();
      loader.setTextures(textures);
      for (var i = 0, l = json.length; i < l; i++) {
        var material = loader.parse(json[i]);
        materials[material.uuid] = material;
      }
    }
    return materials;
  },
  parseAnimations: function (json) {
    var animations = [];
    for (var i = 0; i < json.length; i++) {
      var clip = THREE.AnimationClip.parse(json[i]);
      animations.push(clip);
    }
    return animations;
  },
  parseImages: function (json, onLoad) {
    var scope = this;
    var images = {};
    function loadImage(url) {
      scope.manager.itemStart(url);
      return loader.load(url, function () {
        scope.manager.itemEnd(url);
      });
    }
    if (json !== undefined && json.length > 0) {
      var manager = new THREE.LoadingManager(onLoad);
      var loader = new THREE.ImageLoader(manager);
      loader.setCrossOrigin(this.crossOrigin);
      for (var i = 0, l = json.length; i < l; i++) {
        var image = json[i];
        var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.texturePath + image.url;
        images[image.uuid] = loadImage(path);
      }
    }
    return images;
  },
  parseTextures: function (json, images) {
    function parseConstant(value) {
      if (typeof value === 'number')
        return value;
      console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
      return THREE[value];
    }
    var textures = {};
    if (json !== undefined) {
      for (var i = 0, l = json.length; i < l; i++) {
        var data = json[i];
        if (data.image === undefined) {
          console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
        }
        if (images[data.image] === undefined) {
          console.warn('THREE.ObjectLoader: Undefined image', data.image);
        }
        var texture = new THREE.Texture(images[data.image]);
        texture.needsUpdate = true;
        texture.uuid = data.uuid;
        if (data.name !== undefined)
          texture.name = data.name;
        if (data.mapping !== undefined)
          texture.mapping = parseConstant(data.mapping);
        if (data.offset !== undefined)
          texture.offset = new THREE.Vector2(data.offset[0], data.offset[1]);
        if (data.repeat !== undefined)
          texture.repeat = new THREE.Vector2(data.repeat[0], data.repeat[1]);
        if (data.minFilter !== undefined)
          texture.minFilter = parseConstant(data.minFilter);
        if (data.magFilter !== undefined)
          texture.magFilter = parseConstant(data.magFilter);
        if (data.anisotropy !== undefined)
          texture.anisotropy = data.anisotropy;
        if (Array.isArray(data.wrap)) {
          texture.wrapS = parseConstant(data.wrap[0]);
          texture.wrapT = parseConstant(data.wrap[1]);
        }
        textures[data.uuid] = texture;
      }
    }
    return textures;
  },
  parseObject: function () {
    var matrix = new THREE.Matrix4();
    return function (data, geometries, materials) {
      var object;
      function getGeometry(name) {
        if (geometries[name] === undefined) {
          console.warn('THREE.ObjectLoader: Undefined geometry', name);
        }
        return geometries[name];
      }
      function getMaterial(name) {
        if (name === undefined)
          return undefined;
        if (materials[name] === undefined) {
          console.warn('THREE.ObjectLoader: Undefined material', name);
        }
        return materials[name];
      }
      switch (data.type) {
      case 'Scene':
        object = new THREE.Scene();
        break;
      case 'PerspectiveCamera':
        object = new THREE.PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
        break;
      case 'OrthographicCamera':
        object = new THREE.OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
        break;
      case 'AmbientLight':
        object = new THREE.AmbientLight(data.color, data.intensity);
        break;
      case 'DirectionalLight':
        object = new THREE.DirectionalLight(data.color, data.intensity);
        break;
      case 'PointLight':
        object = new THREE.PointLight(data.color, data.intensity, data.distance, data.decay);
        break;
      case 'SpotLight':
        object = new THREE.SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
        break;
      case 'HemisphereLight':
        object = new THREE.HemisphereLight(data.color, data.groundColor, data.intensity);
        break;
      case 'Mesh':
        var geometry = getGeometry(data.geometry);
        var material = getMaterial(data.material);
        if (geometry.bones && geometry.bones.length > 0) {
          object = new THREE.SkinnedMesh(geometry, material);
        } else {
          object = new THREE.Mesh(geometry, material);
        }
        break;
      case 'LOD':
        object = new THREE.LOD();
        break;
      case 'Line':
        object = new THREE.Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
        break;
      case 'PointCloud':
      case 'Points':
        object = new THREE.Points(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case 'Sprite':
        object = new THREE.Sprite(getMaterial(data.material));
        break;
      case 'Group':
        object = new THREE.Group();
        break;
      default:
        object = new THREE.Object3D();
      }
      object.uuid = data.uuid;
      if (data.name !== undefined)
        object.name = data.name;
      if (data.matrix !== undefined) {
        matrix.fromArray(data.matrix);
        matrix.decompose(object.position, object.quaternion, object.scale);
      } else {
        if (data.position !== undefined)
          object.position.fromArray(data.position);
        if (data.rotation !== undefined)
          object.rotation.fromArray(data.rotation);
        if (data.scale !== undefined)
          object.scale.fromArray(data.scale);
      }
      if (data.castShadow !== undefined)
        object.castShadow = data.castShadow;
      if (data.receiveShadow !== undefined)
        object.receiveShadow = data.receiveShadow;
      if (data.visible !== undefined)
        object.visible = data.visible;
      if (data.userData !== undefined)
        object.userData = data.userData;
      if (data.children !== undefined) {
        for (var child in data.children) {
          object.add(this.parseObject(data.children[child], geometries, materials));
        }
      }
      if (data.type === 'LOD') {
        var levels = data.levels;
        for (var l = 0; l < levels.length; l++) {
          var level = levels[l];
          var child = object.getObjectByProperty('uuid', level.object);
          if (child !== undefined) {
            object.addLevel(child, level.distance);
          }
        }
      }
      return object;
    };
  }()
};
// File:src/loaders/TextureLoader.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
THREE.TextureLoader = function (manager) {
  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};
THREE.TextureLoader.prototype = {
  constructor: THREE.TextureLoader,
  load: function (url, onLoad, onProgress, onError) {
    var texture = new THREE.Texture();
    var loader = new THREE.ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function (image) {
      texture.image = image;
      texture.needsUpdate = true;
      if (onLoad !== undefined) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  },
  setCrossOrigin: function (value) {
    this.crossOrigin = value;
  },
  setPath: function (value) {
    this.path = value;
  }
};
// File:src/materials/Material.js
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */
THREE.Material = function () {
  Object.defineProperty(this, 'id', { value: THREE.MaterialIdCount++ });
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.type = 'Material';
  this.side = THREE.FrontSide;
  this.opacity = 1;
  this.transparent = false;
  this.blending = THREE.NormalBlending;
  this.blendSrc = THREE.SrcAlphaFactor;
  this.blendDst = THREE.OneMinusSrcAlphaFactor;
  this.blendEquation = THREE.AddEquation;
  this.blendSrcAlpha = null;
  this.blendDstAlpha = null;
  this.blendEquationAlpha = null;
  this.depthFunc = THREE.LessEqualDepth;
  this.depthTest = true;
  this.depthWrite = true;
  this.colorWrite = true;
  this.precision = null;
  // override the renderer's default precision for this material
  this.polygonOffset = false;
  this.polygonOffsetFactor = 0;
  this.polygonOffsetUnits = 0;
  this.alphaTest = 0;
  this.premultipliedAlpha = false;
  this.overdraw = 0;
  // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer
  this.visible = true;
  this._needsUpdate = true;
};
THREE.Material.prototype = {
  constructor: THREE.Material,
  get needsUpdate() {
    return this._needsUpdate;
  },
  set needsUpdate(value) {
    if (value === true)
      this.update();
    this._needsUpdate = value;
  },
  setValues: function (values) {
    if (values === undefined)
      return;
    for (var key in values) {
      var newValue = values[key];
      if (newValue === undefined) {
        console.warn('THREE.Material: \'' + key + '\' parameter is undefined.');
        continue;
      }
      var currentValue = this[key];
      if (currentValue === undefined) {
        console.warn('THREE.' + this.type + ': \'' + key + '\' is not a property of this material.');
        continue;
      }
      if (currentValue instanceof THREE.Color) {
        currentValue.set(newValue);
      } else if (currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3) {
        currentValue.copy(newValue);
      } else if (key === 'overdraw') {
        // ensure overdraw is backwards-compatible with legacy boolean type
        this[key] = Number(newValue);
      } else {
        this[key] = newValue;
      }
    }
  },
  toJSON: function (meta) {
    var isRoot = meta === undefined;
    if (isRoot) {
      meta = {
        textures: {},
        images: {}
      };
    }
    var data = {
      metadata: {
        version: 4.4,
        type: 'Material',
        generator: 'Material.toJSON'
      }
    };
    // standard Material serialization
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== '')
      data.name = this.name;
    if (this.color instanceof THREE.Color)
      data.color = this.color.getHex();
    if (this.roughness !== 0.5)
      data.roughness = this.roughness;
    if (this.metalness !== 0.5)
      data.metalness = this.metalness;
    if (this.emissive instanceof THREE.Color)
      data.emissive = this.emissive.getHex();
    if (this.specular instanceof THREE.Color)
      data.specular = this.specular.getHex();
    if (this.shininess !== undefined)
      data.shininess = this.shininess;
    if (this.map instanceof THREE.Texture)
      data.map = this.map.toJSON(meta).uuid;
    if (this.alphaMap instanceof THREE.Texture)
      data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap instanceof THREE.Texture)
      data.lightMap = this.lightMap.toJSON(meta).uuid;
    if (this.bumpMap instanceof THREE.Texture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }
    if (this.normalMap instanceof THREE.Texture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap instanceof THREE.Texture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap instanceof THREE.Texture)
      data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap instanceof THREE.Texture)
      data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap instanceof THREE.Texture)
      data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap instanceof THREE.Texture)
      data.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.envMap instanceof THREE.Texture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      data.reflectivity = this.reflectivity;  // Scale behind envMap
    }
    if (this.size !== undefined)
      data.size = this.size;
    if (this.sizeAttenuation !== undefined)
      data.sizeAttenuation = this.sizeAttenuation;
    if (this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors)
      data.vertexColors = this.vertexColors;
    if (this.shading !== undefined && this.shading !== THREE.SmoothShading)
      data.shading = this.shading;
    if (this.blending !== undefined && this.blending !== THREE.NormalBlending)
      data.blending = this.blending;
    if (this.side !== undefined && this.side !== THREE.FrontSide)
      data.side = this.side;
    if (this.opacity < 1)
      data.opacity = this.opacity;
    if (this.transparent === true)
      data.transparent = this.transparent;
    if (this.alphaTest > 0)
      data.alphaTest = this.alphaTest;
    if (this.premultipliedAlpha === true)
      data.premultipliedAlpha = this.premultipliedAlpha;
    if (this.wireframe === true)
      data.wireframe = this.wireframe;
    if (this.wireframeLinewidth > 1)
      data.wireframeLinewidth = this.wireframeLinewidth;
    // TODO: Copied from Object3D.toJSON
    function extractFromCache(cache) {
      var values = [];
      for (var key in cache) {
        var data = cache[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
    if (isRoot) {
      var textures = extractFromCache(meta.textures);
      var images = extractFromCache(meta.images);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
    }
    return data;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.name = source.name;
    this.side = source.side;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blending = source.blending;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.alphaTest = source.alphaTest;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.overdraw = source.overdraw;
    this.visible = source.visible;
    return this;
  },
  update: function () {
    this.dispatchEvent({ type: 'update' });
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  }
};
THREE.EventDispatcher.prototype.apply(THREE.Material.prototype);
THREE.MaterialIdCount = 0;
// File:src/materials/LineBasicMaterial.js
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round",
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */
THREE.LineBasicMaterial = function (parameters) {
  THREE.Material.call(this);
  this.type = 'LineBasicMaterial';
  this.color = new THREE.Color(16777215);
  this.linewidth = 1;
  this.linecap = 'round';
  this.linejoin = 'round';
  this.blending = THREE.NormalBlending;
  this.vertexColors = THREE.NoColors;
  this.fog = true;
  this.setValues(parameters);
};
THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;
THREE.LineBasicMaterial.prototype.copy = function (source) {
  THREE.Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.linewidth = source.linewidth;
  this.linecap = source.linecap;
  this.linejoin = source.linejoin;
  this.vertexColors = source.vertexColors;
  this.fog = source.fog;
  return this;
};
// File:src/materials/LineDashedMaterial.js
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  vertexColors: THREE.NoColors / THREE.FaceColors / THREE.VertexColors
 *
 *  fog: <bool>
 * }
 */
THREE.LineDashedMaterial = function (parameters) {
  THREE.Material.call(this);
  this.type = 'LineDashedMaterial';
  this.color = new THREE.Color(16777215);
  this.linewidth = 1;
  this.scale = 1;
  this.dashSize = 3;
  this.gapSize = 1;
  this.blending = THREE.NormalBlending;
  this.vertexColors = THREE.NoColors;
  this.fog = true;
  this.setValues(parameters);
};
THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;
THREE.LineDashedMaterial.prototype.copy = function (source) {
  THREE.Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.linewidth = source.linewidth;
  this.scale = source.scale;
  this.dashSize = source.dashSize;
  this.gapSize = source.gapSize;
  this.vertexColors = source.vertexColors;
  this.fog = source.fog;
  return this;
};
// File:src/materials/MeshBasicMaterial.js
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  fog: <bool>
 * }
 */
THREE.MeshBasicMaterial = function (parameters) {
  THREE.Material.call(this);
  this.type = 'MeshBasicMaterial';
  this.color = new THREE.Color(16777215);
  // emissive
  this.map = null;
  this.aoMap = null;
  this.aoMapIntensity = 1;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.fog = true;
  this.shading = THREE.SmoothShading;
  this.blending = THREE.NormalBlending;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.vertexColors = THREE.NoColors;
  this.skinning = false;
  this.morphTargets = false;
  this.setValues(parameters);
};
THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;
THREE.MeshBasicMaterial.prototype.copy = function (source) {
  THREE.Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.specularMap = source.specularMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;
  this.fog = source.fog;
  this.shading = source.shading;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.vertexColors = source.vertexColors;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  return this;
};
// File:src/materials/MeshLambertMaterial.js
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */
THREE.MeshLambertMaterial = function (parameters) {
  THREE.Material.call(this);
  this.type = 'MeshLambertMaterial';
  this.color = new THREE.Color(16777215);
  // diffuse
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1;
  this.aoMap = null;
  this.aoMapIntensity = 1;
  this.emissive = new THREE.Color(0);
  this.emissiveIntensity = 1;
  this.emissiveMap = null;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.fog = true;
  this.blending = THREE.NormalBlending;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.vertexColors = THREE.NoColors;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
};
THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;
THREE.MeshLambertMaterial.prototype.copy = function (source) {
  THREE.Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.specularMap = source.specularMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;
  this.fog = source.fog;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.vertexColors = source.vertexColors;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
// File:src/materials/MeshPhongMaterial.js
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */
THREE.MeshPhongMaterial = function (parameters) {
  THREE.Material.call(this);
  this.type = 'MeshPhongMaterial';
  this.color = new THREE.Color(16777215);
  // diffuse
  this.specular = new THREE.Color(1118481);
  this.shininess = 30;
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1;
  this.aoMap = null;
  this.aoMapIntensity = 1;
  this.emissive = new THREE.Color(0);
  this.emissiveIntensity = 1;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalScale = new THREE.Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.fog = true;
  this.shading = THREE.SmoothShading;
  this.blending = THREE.NormalBlending;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.vertexColors = THREE.NoColors;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
};
THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;
THREE.MeshPhongMaterial.prototype.copy = function (source) {
  THREE.Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.specular.copy(source.specular);
  this.shininess = source.shininess;
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.specularMap = source.specularMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;
  this.fog = source.fog;
  this.shading = source.shading;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.vertexColors = source.vertexColors;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
// File:src/materials/MeshStandardMaterial.js
/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */
THREE.MeshStandardMaterial = function (parameters) {
  THREE.Material.call(this);
  this.type = 'MeshStandardMaterial';
  this.color = new THREE.Color(16777215);
  // diffuse
  this.roughness = 0.5;
  this.metalness = 0.5;
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1;
  this.aoMap = null;
  this.aoMapIntensity = 1;
  this.emissive = new THREE.Color(0);
  this.emissiveIntensity = 1;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalScale = new THREE.Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.roughnessMap = null;
  this.metalnessMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.envMapIntensity = 1;
  this.refractionRatio = 0.98;
  this.fog = true;
  this.shading = THREE.SmoothShading;
  this.blending = THREE.NormalBlending;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.vertexColors = THREE.NoColors;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
};
THREE.MeshStandardMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshStandardMaterial.prototype.constructor = THREE.MeshStandardMaterial;
THREE.MeshStandardMaterial.prototype.copy = function (source) {
  THREE.Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.roughness = source.roughness;
  this.metalness = source.metalness;
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.roughnessMap = source.roughnessMap;
  this.metalnessMap = source.metalnessMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.envMapIntensity = source.envMapIntensity;
  this.refractionRatio = source.refractionRatio;
  this.fog = source.fog;
  this.shading = source.shading;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.vertexColors = source.vertexColors;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
// File:src/materials/MeshDepthMaterial.js
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */
THREE.MeshDepthMaterial = function (parameters) {
  THREE.Material.call(this);
  this.type = 'MeshDepthMaterial';
  this.morphTargets = false;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.setValues(parameters);
};
THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;
THREE.MeshDepthMaterial.prototype.copy = function (source) {
  THREE.Material.prototype.copy.call(this, source);
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  return this;
};
// File:src/materials/MeshNormalMaterial.js
/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */
THREE.MeshNormalMaterial = function (parameters) {
  THREE.Material.call(this, parameters);
  this.type = 'MeshNormalMaterial';
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.morphTargets = false;
  this.setValues(parameters);
};
THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;
THREE.MeshNormalMaterial.prototype.copy = function (source) {
  THREE.Material.prototype.copy.call(this, source);
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  return this;
};
// File:src/materials/MultiMaterial.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
THREE.MultiMaterial = function (materials) {
  this.uuid = THREE.Math.generateUUID();
  this.type = 'MultiMaterial';
  this.materials = materials instanceof Array ? materials : [];
  this.visible = true;
};
THREE.MultiMaterial.prototype = {
  constructor: THREE.MultiMaterial,
  toJSON: function (meta) {
    var output = {
      metadata: {
        version: 4.2,
        type: 'material',
        generator: 'MaterialExporter'
      },
      uuid: this.uuid,
      type: this.type,
      materials: []
    };
    var materials = this.materials;
    for (var i = 0, l = materials.length; i < l; i++) {
      var material = materials[i].toJSON(meta);
      delete material.metadata;
      output.materials.push(material);
    }
    output.visible = this.visible;
    return output;
  },
  clone: function () {
    var material = new this.constructor();
    for (var i = 0; i < this.materials.length; i++) {
      material.materials.push(this.materials[i].clone());
    }
    material.visible = this.visible;
    return material;
  }
};
// File:src/materials/PointsMaterial.js
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  vertexColors: <bool>,
 *
 *  fog: <bool>
 * }
 */
THREE.PointsMaterial = function (parameters) {
  THREE.Material.call(this);
  this.type = 'PointsMaterial';
  this.color = new THREE.Color(16777215);
  this.map = null;
  this.size = 1;
  this.sizeAttenuation = true;
  this.blending = THREE.NormalBlending;
  this.vertexColors = THREE.NoColors;
  this.fog = true;
  this.setValues(parameters);
};
THREE.PointsMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;
THREE.PointsMaterial.prototype.copy = function (source) {
  THREE.Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.size = source.size;
  this.sizeAttenuation = source.sizeAttenuation;
  this.vertexColors = source.vertexColors;
  this.fog = source.fog;
  return this;
};
// File:src/materials/ShaderMaterial.js
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  shading: THREE.SmoothShading,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */
THREE.ShaderMaterial = function (parameters) {
  THREE.Material.call(this);
  this.type = 'ShaderMaterial';
  this.defines = {};
  this.uniforms = {};
  this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
  this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';
  this.shading = THREE.SmoothShading;
  this.linewidth = 1;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  // set to use scene fog
  this.lights = false;
  // set to use scene lights
  this.vertexColors = THREE.NoColors;
  // set to use "color" attribute stream
  this.skinning = false;
  // set to use skinning attribute streams
  this.morphTargets = false;
  // set to use morph targets
  this.morphNormals = false;
  // set to use morph normals
  this.extensions = {
    derivatives: false,
    // set to use derivatives
    fragDepth: false,
    // set to use fragment depth values
    drawBuffers: false,
    // set to use draw buffers
    shaderTextureLOD: false  // set to use shader texture LOD
  };
  // When rendered geometry doesn't include these attributes but the material does,
  // use these default values in WebGL. This avoids errors when buffer data is missing.
  this.defaultAttributeValues = {
    'color': [
      1,
      1,
      1
    ],
    'uv': [
      0,
      0
    ],
    'uv2': [
      0,
      0
    ]
  };
  this.index0AttributeName = undefined;
  if (parameters !== undefined) {
    if (parameters.attributes !== undefined) {
      console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
    }
    this.setValues(parameters);
  }
};
THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;
THREE.ShaderMaterial.prototype.copy = function (source) {
  THREE.Material.prototype.copy.call(this, source);
  this.fragmentShader = source.fragmentShader;
  this.vertexShader = source.vertexShader;
  this.uniforms = THREE.UniformsUtils.clone(source.uniforms);
  this.defines = source.defines;
  this.shading = source.shading;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.fog = source.fog;
  this.lights = source.lights;
  this.vertexColors = source.vertexColors;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  this.extensions = source.extensions;
  return this;
};
THREE.ShaderMaterial.prototype.toJSON = function (meta) {
  var data = THREE.Material.prototype.toJSON.call(this, meta);
  data.uniforms = this.uniforms;
  data.vertexShader = this.vertexShader;
  data.fragmentShader = this.fragmentShader;
  return data;
};
// File:src/materials/RawShaderMaterial.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
THREE.RawShaderMaterial = function (parameters) {
  THREE.ShaderMaterial.call(this, parameters);
  this.type = 'RawShaderMaterial';
};
THREE.RawShaderMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;
// File:src/textures/Texture.js
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */
THREE.Texture = function (image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
  Object.defineProperty(this, 'id', { value: THREE.TextureIdCount++ });
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.sourceFile = '';
  this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
  this.mipmaps = [];
  this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;
  this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
  this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;
  this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
  this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;
  this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
  this.format = format !== undefined ? format : THREE.RGBAFormat;
  this.type = type !== undefined ? type : THREE.UnsignedByteType;
  this.offset = new THREE.Vector2(0, 0);
  this.repeat = new THREE.Vector2(1, 1);
  this.generateMipmaps = true;
  this.premultiplyAlpha = false;
  this.flipY = true;
  this.unpackAlignment = 4;
  // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
  // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
  //
  // Also changing the encoding after already used by a Material will not automatically make the Material
  // update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
  this.encoding = THREE.LinearEncoding;
  this.version = 0;
  this.onUpdate = null;
};
THREE.Texture.DEFAULT_IMAGE = undefined;
THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;
THREE.Texture.prototype = {
  constructor: THREE.Texture,
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.image = source.image;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.encoding = source.encoding;
    return this;
  },
  toJSON: function (meta) {
    if (meta.textures[this.uuid] !== undefined) {
      return meta.textures[this.uuid];
    }
    function getDataURL(image) {
      var canvas;
      if (image.toDataURL !== undefined) {
        canvas = image;
      } else {
        canvas = document.createElement('canvas');
        canvas.width = image.width;
        canvas.height = image.height;
        canvas.getContext('2d').drawImage(image, 0, 0, image.width, image.height);
      }
      if (canvas.width > 2048 || canvas.height > 2048) {
        return canvas.toDataURL('image/jpeg', 0.6);
      } else {
        return canvas.toDataURL('image/png');
      }
    }
    var output = {
      metadata: {
        version: 4.4,
        type: 'Texture',
        generator: 'Texture.toJSON'
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [
        this.repeat.x,
        this.repeat.y
      ],
      offset: [
        this.offset.x,
        this.offset.y
      ],
      wrap: [
        this.wrapS,
        this.wrapT
      ],
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy
    };
    if (this.image !== undefined) {
      // TODO: Move to THREE.Image
      var image = this.image;
      if (image.uuid === undefined) {
        image.uuid = THREE.Math.generateUUID();  // UGH
      }
      if (meta.images[image.uuid] === undefined) {
        meta.images[image.uuid] = {
          uuid: image.uuid,
          url: getDataURL(image)
        };
      }
      output.image = image.uuid;
    }
    meta.textures[this.uuid] = output;
    return output;
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  },
  transformUv: function (uv) {
    if (this.mapping !== THREE.UVMapping)
      return;
    uv.multiply(this.repeat);
    uv.add(this.offset);
    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
      case THREE.RepeatWrapping:
        uv.x = uv.x - Math.floor(uv.x);
        break;
      case THREE.ClampToEdgeWrapping:
        uv.x = uv.x < 0 ? 0 : 1;
        break;
      case THREE.MirroredRepeatWrapping:
        if (Math.abs(Math.floor(uv.x) % 2) === 1) {
          uv.x = Math.ceil(uv.x) - uv.x;
        } else {
          uv.x = uv.x - Math.floor(uv.x);
        }
        break;
      }
    }
    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
      case THREE.RepeatWrapping:
        uv.y = uv.y - Math.floor(uv.y);
        break;
      case THREE.ClampToEdgeWrapping:
        uv.y = uv.y < 0 ? 0 : 1;
        break;
      case THREE.MirroredRepeatWrapping:
        if (Math.abs(Math.floor(uv.y) % 2) === 1) {
          uv.y = Math.ceil(uv.y) - uv.y;
        } else {
          uv.y = uv.y - Math.floor(uv.y);
        }
        break;
      }
    }
    if (this.flipY) {
      uv.y = 1 - uv.y;
    }
  }
};
THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype);
THREE.TextureIdCount = 0;
// File:src/textures/CanvasTexture.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
THREE.CanvasTexture = function (canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
  THREE.Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.needsUpdate = true;
};
THREE.CanvasTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;
// File:src/textures/CubeTexture.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
THREE.CubeTexture = function (images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
  images = images !== undefined ? images : [];
  mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;
  THREE.Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.flipY = false;
};
THREE.CubeTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;
Object.defineProperty(THREE.CubeTexture.prototype, 'images', {
  get: function () {
    return this.image;
  },
  set: function (value) {
    this.image = value;
  }
});
// File:src/textures/CompressedTexture.js
/**
 * @author alteredq / http://alteredqualia.com/
 */
THREE.CompressedTexture = function (mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy) {
  THREE.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.image = {
    width: width,
    height: height
  };
  this.mipmaps = mipmaps;
  // no flipping for cube textures
  // (also flipping doesn't work for compressed textures )
  this.flipY = false;
  // can't generate mipmaps for compressed textures
  // mips must be embedded in DDS files
  this.generateMipmaps = false;
};
THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;
// File:src/textures/DataTexture.js
/**
 * @author alteredq / http://alteredqualia.com/
 */
THREE.DataTexture = function (data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy) {
  THREE.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.image = {
    data: data,
    width: width,
    height: height
  };
  this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;
  this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;
  this.flipY = false;
  this.generateMipmaps = false;
};
THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.DataTexture.prototype.constructor = THREE.DataTexture;
// File:src/objects/Group.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
THREE.Group = function () {
  THREE.Object3D.call(this);
  this.type = 'Group';
};
THREE.Group.prototype = Object.create(THREE.Object3D.prototype);
THREE.Group.prototype.constructor = THREE.Group;
// File:src/objects/Points.js
/**
 * @author alteredq / http://alteredqualia.com/
 */
THREE.Points = function (geometry, material) {
  THREE.Object3D.call(this);
  this.type = 'Points';
  this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
  this.material = material !== undefined ? material : new THREE.PointsMaterial({ color: Math.random() * 16777215 });
};
THREE.Points.prototype = Object.create(THREE.Object3D.prototype);
THREE.Points.prototype.constructor = THREE.Points;
THREE.Points.prototype.raycast = function () {
  var inverseMatrix = new THREE.Matrix4();
  var ray = new THREE.Ray();
  var sphere = new THREE.Sphere();
  return function raycast(raycaster, intersects) {
    var object = this;
    var geometry = this.geometry;
    var matrixWorld = this.matrixWorld;
    var threshold = raycaster.params.Points.threshold;
    // Checking boundingSphere distance to ray
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    sphere.copy(geometry.boundingSphere);
    sphere.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(sphere) === false)
      return;
    //
    inverseMatrix.getInverse(matrixWorld);
    ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
    var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    var localThresholdSq = localThreshold * localThreshold;
    var position = new THREE.Vector3();
    function testPoint(point, index) {
      var rayPointDistanceSq = ray.distanceSqToPoint(point);
      if (rayPointDistanceSq < localThresholdSq) {
        var intersectPoint = ray.closestPointToPoint(point);
        intersectPoint.applyMatrix4(matrixWorld);
        var distance = raycaster.ray.origin.distanceTo(intersectPoint);
        if (distance < raycaster.near || distance > raycaster.far)
          return;
        intersects.push({
          distance: distance,
          distanceToRay: Math.sqrt(rayPointDistanceSq),
          point: intersectPoint.clone(),
          index: index,
          face: null,
          object: object
        });
      }
    }
    if (geometry instanceof THREE.BufferGeometry) {
      var index = geometry.index;
      var attributes = geometry.attributes;
      var positions = attributes.position.array;
      if (index !== null) {
        var indices = index.array;
        for (var i = 0, il = indices.length; i < il; i++) {
          var a = indices[i];
          position.fromArray(positions, a * 3);
          testPoint(position, a);
        }
      } else {
        for (var i = 0, l = positions.length / 3; i < l; i++) {
          position.fromArray(positions, i * 3);
          testPoint(position, i);
        }
      }
    } else {
      var vertices = geometry.vertices;
      for (var i = 0, l = vertices.length; i < l; i++) {
        testPoint(vertices[i], i);
      }
    }
  };
}();
THREE.Points.prototype.clone = function () {
  return new this.constructor(this.geometry, this.material).copy(this);
};
// File:src/objects/Line.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
THREE.Line = function (geometry, material, mode) {
  if (mode === 1) {
    console.warn('THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.');
    return new THREE.LineSegments(geometry, material);
  }
  THREE.Object3D.call(this);
  this.type = 'Line';
  this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
  this.material = material !== undefined ? material : new THREE.LineBasicMaterial({ color: Math.random() * 16777215 });
};
THREE.Line.prototype = Object.create(THREE.Object3D.prototype);
THREE.Line.prototype.constructor = THREE.Line;
THREE.Line.prototype.raycast = function () {
  var inverseMatrix = new THREE.Matrix4();
  var ray = new THREE.Ray();
  var sphere = new THREE.Sphere();
  return function raycast(raycaster, intersects) {
    var precision = raycaster.linePrecision;
    var precisionSq = precision * precision;
    var geometry = this.geometry;
    var matrixWorld = this.matrixWorld;
    // Checking boundingSphere distance to ray
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    sphere.copy(geometry.boundingSphere);
    sphere.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(sphere) === false)
      return;
    //
    inverseMatrix.getInverse(matrixWorld);
    ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
    var vStart = new THREE.Vector3();
    var vEnd = new THREE.Vector3();
    var interSegment = new THREE.Vector3();
    var interRay = new THREE.Vector3();
    var step = this instanceof THREE.LineSegments ? 2 : 1;
    if (geometry instanceof THREE.BufferGeometry) {
      var index = geometry.index;
      var attributes = geometry.attributes;
      var positions = attributes.position.array;
      if (index !== null) {
        var indices = index.array;
        for (var i = 0, l = indices.length - 1; i < l; i += step) {
          var a = indices[i];
          var b = indices[i + 1];
          vStart.fromArray(positions, a * 3);
          vEnd.fromArray(positions, b * 3);
          var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > precisionSq)
            continue;
          interRay.applyMatrix4(this.matrixWorld);
          //Move back to world space for distance calculation
          var distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far)
            continue;
          intersects.push({
            distance: distance,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else {
        for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {
          vStart.fromArray(positions, 3 * i);
          vEnd.fromArray(positions, 3 * i + 3);
          var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > precisionSq)
            continue;
          interRay.applyMatrix4(this.matrixWorld);
          //Move back to world space for distance calculation
          var distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far)
            continue;
          intersects.push({
            distance: distance,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    } else if (geometry instanceof THREE.Geometry) {
      var vertices = geometry.vertices;
      var nbVertices = vertices.length;
      for (var i = 0; i < nbVertices - 1; i += step) {
        var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
        if (distSq > precisionSq)
          continue;
        interRay.applyMatrix4(this.matrixWorld);
        //Move back to world space for distance calculation
        var distance = raycaster.ray.origin.distanceTo(interRay);
        if (distance < raycaster.near || distance > raycaster.far)
          continue;
        intersects.push({
          distance: distance,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: interSegment.clone().applyMatrix4(this.matrixWorld),
          index: i,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    }
  };
}();
THREE.Line.prototype.clone = function () {
  return new this.constructor(this.geometry, this.material).copy(this);
};
// DEPRECATED
THREE.LineStrip = 0;
THREE.LinePieces = 1;
// File:src/objects/LineSegments.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
THREE.LineSegments = function (geometry, material) {
  THREE.Line.call(this, geometry, material);
  this.type = 'LineSegments';
};
THREE.LineSegments.prototype = Object.create(THREE.Line.prototype);
THREE.LineSegments.prototype.constructor = THREE.LineSegments;
// File:src/objects/Mesh.js
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */
THREE.Mesh = function (geometry, material) {
  THREE.Object3D.call(this);
  this.type = 'Mesh';
  this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
  this.material = material !== undefined ? material : new THREE.MeshBasicMaterial({ color: Math.random() * 16777215 });
  this.drawMode = THREE.TrianglesDrawMode;
  this.updateMorphTargets();
};
THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype);
THREE.Mesh.prototype.constructor = THREE.Mesh;
THREE.Mesh.prototype.setDrawMode = function (value) {
  this.drawMode = value;
};
THREE.Mesh.prototype.updateMorphTargets = function () {
  if (this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0) {
    this.morphTargetBase = -1;
    this.morphTargetInfluences = [];
    this.morphTargetDictionary = {};
    for (var m = 0, ml = this.geometry.morphTargets.length; m < ml; m++) {
      this.morphTargetInfluences.push(0);
      this.morphTargetDictionary[this.geometry.morphTargets[m].name] = m;
    }
  }
};
THREE.Mesh.prototype.getMorphTargetIndexByName = function (name) {
  if (this.morphTargetDictionary[name] !== undefined) {
    return this.morphTargetDictionary[name];
  }
  console.warn('THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.');
  return 0;
};
THREE.Mesh.prototype.raycast = function () {
  var inverseMatrix = new THREE.Matrix4();
  var ray = new THREE.Ray();
  var sphere = new THREE.Sphere();
  var vA = new THREE.Vector3();
  var vB = new THREE.Vector3();
  var vC = new THREE.Vector3();
  var tempA = new THREE.Vector3();
  var tempB = new THREE.Vector3();
  var tempC = new THREE.Vector3();
  var uvA = new THREE.Vector2();
  var uvB = new THREE.Vector2();
  var uvC = new THREE.Vector2();
  var barycoord = new THREE.Vector3();
  var intersectionPoint = new THREE.Vector3();
  var intersectionPointWorld = new THREE.Vector3();
  function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {
    THREE.Triangle.barycoordFromPoint(point, p1, p2, p3, barycoord);
    uv1.multiplyScalar(barycoord.x);
    uv2.multiplyScalar(barycoord.y);
    uv3.multiplyScalar(barycoord.z);
    uv1.add(uv2).add(uv3);
    return uv1.clone();
  }
  function checkIntersection(object, raycaster, ray, pA, pB, pC, point) {
    var intersect;
    var material = object.material;
    if (material.side === THREE.BackSide) {
      intersect = ray.intersectTriangle(pC, pB, pA, true, point);
    } else {
      intersect = ray.intersectTriangle(pA, pB, pC, material.side !== THREE.DoubleSide, point);
    }
    if (intersect === null)
      return null;
    intersectionPointWorld.copy(point);
    intersectionPointWorld.applyMatrix4(object.matrixWorld);
    var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);
    if (distance < raycaster.near || distance > raycaster.far)
      return null;
    return {
      distance: distance,
      point: intersectionPointWorld.clone(),
      object: object
    };
  }
  function checkBufferGeometryIntersection(object, raycaster, ray, positions, uvs, a, b, c) {
    vA.fromArray(positions, a * 3);
    vB.fromArray(positions, b * 3);
    vC.fromArray(positions, c * 3);
    var intersection = checkIntersection(object, raycaster, ray, vA, vB, vC, intersectionPoint);
    if (intersection) {
      if (uvs) {
        uvA.fromArray(uvs, a * 2);
        uvB.fromArray(uvs, b * 2);
        uvC.fromArray(uvs, c * 2);
        intersection.uv = uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC);
      }
      intersection.face = new THREE.Face3(a, b, c, THREE.Triangle.normal(vA, vB, vC));
      intersection.faceIndex = a;
    }
    return intersection;
  }
  return function raycast(raycaster, intersects) {
    var geometry = this.geometry;
    var material = this.material;
    var matrixWorld = this.matrixWorld;
    if (material === undefined)
      return;
    // Checking boundingSphere distance to ray
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    sphere.copy(geometry.boundingSphere);
    sphere.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(sphere) === false)
      return;
    //
    inverseMatrix.getInverse(matrixWorld);
    ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
    // Check boundingBox before continuing
    if (geometry.boundingBox !== null) {
      if (ray.intersectsBox(geometry.boundingBox) === false)
        return;
    }
    var uvs, intersection;
    if (geometry instanceof THREE.BufferGeometry) {
      var a, b, c;
      var index = geometry.index;
      var attributes = geometry.attributes;
      var positions = attributes.position.array;
      if (attributes.uv !== undefined) {
        uvs = attributes.uv.array;
      }
      if (index !== null) {
        var indices = index.array;
        for (var i = 0, l = indices.length; i < l; i += 3) {
          a = indices[i];
          b = indices[i + 1];
          c = indices[i + 2];
          intersection = checkBufferGeometryIntersection(this, raycaster, ray, positions, uvs, a, b, c);
          if (intersection) {
            intersection.faceIndex = Math.floor(i / 3);
            // triangle number in indices buffer semantics
            intersects.push(intersection);
          }
        }
      } else {
        for (var i = 0, l = positions.length; i < l; i += 9) {
          a = i / 3;
          b = a + 1;
          c = a + 2;
          intersection = checkBufferGeometryIntersection(this, raycaster, ray, positions, uvs, a, b, c);
          if (intersection) {
            intersection.index = a;
            // triangle number in positions buffer semantics
            intersects.push(intersection);
          }
        }
      }
    } else if (geometry instanceof THREE.Geometry) {
      var fvA, fvB, fvC;
      var isFaceMaterial = material instanceof THREE.MultiMaterial;
      var materials = isFaceMaterial === true ? material.materials : null;
      var vertices = geometry.vertices;
      var faces = geometry.faces;
      var faceVertexUvs = geometry.faceVertexUvs[0];
      if (faceVertexUvs.length > 0)
        uvs = faceVertexUvs;
      for (var f = 0, fl = faces.length; f < fl; f++) {
        var face = faces[f];
        var faceMaterial = isFaceMaterial === true ? materials[face.materialIndex] : material;
        if (faceMaterial === undefined)
          continue;
        fvA = vertices[face.a];
        fvB = vertices[face.b];
        fvC = vertices[face.c];
        if (faceMaterial.morphTargets === true) {
          var morphTargets = geometry.morphTargets;
          var morphInfluences = this.morphTargetInfluences;
          vA.set(0, 0, 0);
          vB.set(0, 0, 0);
          vC.set(0, 0, 0);
          for (var t = 0, tl = morphTargets.length; t < tl; t++) {
            var influence = morphInfluences[t];
            if (influence === 0)
              continue;
            var targets = morphTargets[t].vertices;
            vA.addScaledVector(tempA.subVectors(targets[face.a], fvA), influence);
            vB.addScaledVector(tempB.subVectors(targets[face.b], fvB), influence);
            vC.addScaledVector(tempC.subVectors(targets[face.c], fvC), influence);
          }
          vA.add(fvA);
          vB.add(fvB);
          vC.add(fvC);
          fvA = vA;
          fvB = vB;
          fvC = vC;
        }
        intersection = checkIntersection(this, raycaster, ray, fvA, fvB, fvC, intersectionPoint);
        if (intersection) {
          if (uvs) {
            var uvs_f = uvs[f];
            uvA.copy(uvs_f[0]);
            uvB.copy(uvs_f[1]);
            uvC.copy(uvs_f[2]);
            intersection.uv = uvIntersection(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC);
          }
          intersection.face = face;
          intersection.faceIndex = f;
          intersects.push(intersection);
        }
      }
    }
  };
}();
THREE.Mesh.prototype.clone = function () {
  return new this.constructor(this.geometry, this.material).copy(this);
};
// File:src/objects/Bone.js
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */
THREE.Bone = function (skin) {
  THREE.Object3D.call(this);
  this.type = 'Bone';
  this.skin = skin;
};
THREE.Bone.prototype = Object.create(THREE.Object3D.prototype);
THREE.Bone.prototype.constructor = THREE.Bone;
THREE.Bone.prototype.copy = function (source) {
  THREE.Object3D.prototype.copy.call(this, source);
  this.skin = source.skin;
  return this;
};
// File:src/objects/Skeleton.js
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */
THREE.Skeleton = function (bones, boneInverses, useVertexTexture) {
  this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;
  this.identityMatrix = new THREE.Matrix4();
  // copy the bone array
  bones = bones || [];
  this.bones = bones.slice(0);
  // create a bone texture or an array of floats
  if (this.useVertexTexture) {
    // layout (1 matrix = 4 pixels)
    //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
    //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
    //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
    //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
    //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
    var size = Math.sqrt(this.bones.length * 4);
    // 4 pixels needed for 1 matrix
    size = THREE.Math.nextPowerOfTwo(Math.ceil(size));
    size = Math.max(size, 4);
    this.boneTextureWidth = size;
    this.boneTextureHeight = size;
    this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4);
    // 4 floats per RGBA pixel
    this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType);
  } else {
    this.boneMatrices = new Float32Array(16 * this.bones.length);
  }
  // use the supplied bone inverses or calculate the inverses
  if (boneInverses === undefined) {
    this.calculateInverses();
  } else {
    if (this.bones.length === boneInverses.length) {
      this.boneInverses = boneInverses.slice(0);
    } else {
      console.warn('THREE.Skeleton bonInverses is the wrong length.');
      this.boneInverses = [];
      for (var b = 0, bl = this.bones.length; b < bl; b++) {
        this.boneInverses.push(new THREE.Matrix4());
      }
    }
  }
};
THREE.Skeleton.prototype.calculateInverses = function () {
  this.boneInverses = [];
  for (var b = 0, bl = this.bones.length; b < bl; b++) {
    var inverse = new THREE.Matrix4();
    if (this.bones[b]) {
      inverse.getInverse(this.bones[b].matrixWorld);
    }
    this.boneInverses.push(inverse);
  }
};
THREE.Skeleton.prototype.pose = function () {
  var bone;
  // recover the bind-time world matrices
  for (var b = 0, bl = this.bones.length; b < bl; b++) {
    bone = this.bones[b];
    if (bone) {
      bone.matrixWorld.getInverse(this.boneInverses[b]);
    }
  }
  // compute the local matrices, positions, rotations and scales
  for (var b = 0, bl = this.bones.length; b < bl; b++) {
    bone = this.bones[b];
    if (bone) {
      if (bone.parent) {
        bone.matrix.getInverse(bone.parent.matrixWorld);
        bone.matrix.multiply(bone.matrixWorld);
      } else {
        bone.matrix.copy(bone.matrixWorld);
      }
      bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
    }
  }
};
THREE.Skeleton.prototype.update = function () {
  var offsetMatrix = new THREE.Matrix4();
  return function update() {
    // flatten bone matrices to array
    for (var b = 0, bl = this.bones.length; b < bl; b++) {
      // compute the offset between the current and the original transform
      var matrix = this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix;
      offsetMatrix.multiplyMatrices(matrix, this.boneInverses[b]);
      offsetMatrix.flattenToArrayOffset(this.boneMatrices, b * 16);
    }
    if (this.useVertexTexture) {
      this.boneTexture.needsUpdate = true;
    }
  };
}();
THREE.Skeleton.prototype.clone = function () {
  return new THREE.Skeleton(this.bones, this.boneInverses, this.useVertexTexture);
};
// File:src/objects/SkinnedMesh.js
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */
THREE.SkinnedMesh = function (geometry, material, useVertexTexture) {
  THREE.Mesh.call(this, geometry, material);
  this.type = 'SkinnedMesh';
  this.bindMode = 'attached';
  this.bindMatrix = new THREE.Matrix4();
  this.bindMatrixInverse = new THREE.Matrix4();
  // init bones
  // TODO: remove bone creation as there is no reason (other than
  // convenience) for THREE.SkinnedMesh to do this.
  var bones = [];
  if (this.geometry && this.geometry.bones !== undefined) {
    var bone, gbone;
    for (var b = 0, bl = this.geometry.bones.length; b < bl; ++b) {
      gbone = this.geometry.bones[b];
      bone = new THREE.Bone(this);
      bones.push(bone);
      bone.name = gbone.name;
      bone.position.fromArray(gbone.pos);
      bone.quaternion.fromArray(gbone.rotq);
      if (gbone.scl !== undefined)
        bone.scale.fromArray(gbone.scl);
    }
    for (var b = 0, bl = this.geometry.bones.length; b < bl; ++b) {
      gbone = this.geometry.bones[b];
      if (gbone.parent !== -1 && gbone.parent !== null) {
        bones[gbone.parent].add(bones[b]);
      } else {
        this.add(bones[b]);
      }
    }
  }
  this.normalizeSkinWeights();
  this.updateMatrixWorld(true);
  this.bind(new THREE.Skeleton(bones, undefined, useVertexTexture), this.matrixWorld);
};
THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype);
THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;
THREE.SkinnedMesh.prototype.bind = function (skeleton, bindMatrix) {
  this.skeleton = skeleton;
  if (bindMatrix === undefined) {
    this.updateMatrixWorld(true);
    this.skeleton.calculateInverses();
    bindMatrix = this.matrixWorld;
  }
  this.bindMatrix.copy(bindMatrix);
  this.bindMatrixInverse.getInverse(bindMatrix);
};
THREE.SkinnedMesh.prototype.pose = function () {
  this.skeleton.pose();
};
THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {
  if (this.geometry instanceof THREE.Geometry) {
    for (var i = 0; i < this.geometry.skinWeights.length; i++) {
      var sw = this.geometry.skinWeights[i];
      var scale = 1 / sw.lengthManhattan();
      if (scale !== Infinity) {
        sw.multiplyScalar(scale);
      } else {
        sw.set(1, 0, 0, 0);  // do something reasonable
      }
    }
  } else if (this.geometry instanceof THREE.BufferGeometry) {
    var vec = new THREE.Vector4();
    var skinWeight = this.geometry.attributes.skinWeight;
    for (var i = 0; i < skinWeight.count; i++) {
      vec.x = skinWeight.getX(i);
      vec.y = skinWeight.getY(i);
      vec.z = skinWeight.getZ(i);
      vec.w = skinWeight.getW(i);
      var scale = 1 / vec.lengthManhattan();
      if (scale !== Infinity) {
        vec.multiplyScalar(scale);
      } else {
        vec.set(1, 0, 0, 0);  // do something reasonable
      }
      skinWeight.setXYZW(i, vec.x, vec.y, vec.z, vec.w);
    }
  }
};
THREE.SkinnedMesh.prototype.updateMatrixWorld = function (force) {
  THREE.Mesh.prototype.updateMatrixWorld.call(this, true);
  if (this.bindMode === 'attached') {
    this.bindMatrixInverse.getInverse(this.matrixWorld);
  } else if (this.bindMode === 'detached') {
    this.bindMatrixInverse.getInverse(this.bindMatrix);
  } else {
    console.warn('THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode);
  }
};
THREE.SkinnedMesh.prototype.clone = function () {
  return new this.constructor(this.geometry, this.material, this.useVertexTexture).copy(this);
};
// File:src/objects/LOD.js
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */
THREE.LOD = function () {
  THREE.Object3D.call(this);
  this.type = 'LOD';
  Object.defineProperties(this, {
    levels: {
      enumerable: true,
      value: []
    },
    objects: {
      get: function () {
        console.warn('THREE.LOD: .objects has been renamed to .levels.');
        return this.levels;
      }
    }
  });
};
THREE.LOD.prototype = Object.create(THREE.Object3D.prototype);
THREE.LOD.prototype.constructor = THREE.LOD;
THREE.LOD.prototype.addLevel = function (object, distance) {
  if (distance === undefined)
    distance = 0;
  distance = Math.abs(distance);
  var levels = this.levels;
  for (var l = 0; l < levels.length; l++) {
    if (distance < levels[l].distance) {
      break;
    }
  }
  levels.splice(l, 0, {
    distance: distance,
    object: object
  });
  this.add(object);
};
THREE.LOD.prototype.getObjectForDistance = function (distance) {
  var levels = this.levels;
  for (var i = 1, l = levels.length; i < l; i++) {
    if (distance < levels[i].distance) {
      break;
    }
  }
  return levels[i - 1].object;
};
THREE.LOD.prototype.raycast = function () {
  var matrixPosition = new THREE.Vector3();
  return function raycast(raycaster, intersects) {
    matrixPosition.setFromMatrixPosition(this.matrixWorld);
    var distance = raycaster.ray.origin.distanceTo(matrixPosition);
    this.getObjectForDistance(distance).raycast(raycaster, intersects);
  };
}();
THREE.LOD.prototype.update = function () {
  var v1 = new THREE.Vector3();
  var v2 = new THREE.Vector3();
  return function update(camera) {
    var levels = this.levels;
    if (levels.length > 1) {
      v1.setFromMatrixPosition(camera.matrixWorld);
      v2.setFromMatrixPosition(this.matrixWorld);
      var distance = v1.distanceTo(v2);
      levels[0].object.visible = true;
      for (var i = 1, l = levels.length; i < l; i++) {
        if (distance >= levels[i].distance) {
          levels[i - 1].object.visible = false;
          levels[i].object.visible = true;
        } else {
          break;
        }
      }
      for (; i < l; i++) {
        levels[i].object.visible = false;
      }
    }
  };
}();
THREE.LOD.prototype.copy = function (source) {
  THREE.Object3D.prototype.copy.call(this, source, false);
  var levels = source.levels;
  for (var i = 0, l = levels.length; i < l; i++) {
    var level = levels[i];
    this.addLevel(level.object.clone(), level.distance);
  }
  return this;
};
THREE.LOD.prototype.toJSON = function (meta) {
  var data = THREE.Object3D.prototype.toJSON.call(this, meta);
  data.object.levels = [];
  var levels = this.levels;
  for (var i = 0, l = levels.length; i < l; i++) {
    var level = levels[i];
    data.object.levels.push({
      object: level.object.uuid,
      distance: level.distance
    });
  }
  return data;
};
// File:src/objects/Sprite.js
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */
THREE.Sprite = function () {
  var indices = new Uint16Array([
    0,
    1,
    2,
    0,
    2,
    3
  ]);
  var vertices = new Float32Array([
    -0.5,
    -0.5,
    0,
    0.5,
    -0.5,
    0,
    0.5,
    0.5,
    0,
    -0.5,
    0.5,
    0
  ]);
  var uvs = new Float32Array([
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1
  ]);
  var geometry = new THREE.BufferGeometry();
  geometry.setIndex(new THREE.BufferAttribute(indices, 1));
  geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
  geometry.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));
  return function Sprite(material) {
    THREE.Object3D.call(this);
    this.type = 'Sprite';
    this.geometry = geometry;
    this.material = material !== undefined ? material : new THREE.SpriteMaterial();
  };
}();
THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype);
THREE.Sprite.prototype.constructor = THREE.Sprite;
THREE.Sprite.prototype.raycast = function () {
  var matrixPosition = new THREE.Vector3();
  return function raycast(raycaster, intersects) {
    matrixPosition.setFromMatrixPosition(this.matrixWorld);
    var distanceSq = raycaster.ray.distanceSqToPoint(matrixPosition);
    var guessSizeSq = this.scale.x * this.scale.y;
    if (distanceSq > guessSizeSq) {
      return;
    }
    intersects.push({
      distance: Math.sqrt(distanceSq),
      point: this.position,
      face: null,
      object: this
    });
  };
}();
THREE.Sprite.prototype.clone = function () {
  return new this.constructor(this.material).copy(this);
};
// Backwards compatibility
THREE.Particle = THREE.Sprite;
// File:src/objects/LensFlare.js
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */
THREE.LensFlare = function (texture, size, distance, blending, color) {
  THREE.Object3D.call(this);
  this.lensFlares = [];
  this.positionScreen = new THREE.Vector3();
  this.customUpdateCallback = undefined;
  if (texture !== undefined) {
    this.add(texture, size, distance, blending, color);
  }
};
THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype);
THREE.LensFlare.prototype.constructor = THREE.LensFlare;
/*
 * Add: adds another flare
 */
THREE.LensFlare.prototype.add = function (texture, size, distance, blending, color, opacity) {
  if (size === undefined)
    size = -1;
  if (distance === undefined)
    distance = 0;
  if (opacity === undefined)
    opacity = 1;
  if (color === undefined)
    color = new THREE.Color(16777215);
  if (blending === undefined)
    blending = THREE.NormalBlending;
  distance = Math.min(distance, Math.max(0, distance));
  this.lensFlares.push({
    texture: texture,
    // THREE.Texture
    size: size,
    // size in pixels (-1 = use texture.width)
    distance: distance,
    // distance (0-1) from light source (0=at light source)
    x: 0,
    y: 0,
    z: 0,
    // screen position (-1 => 1) z = 0 is in front z = 1 is back
    scale: 1,
    // scale
    rotation: 0,
    // rotation
    opacity: opacity,
    // opacity
    color: color,
    // color
    blending: blending  // blending
  });
};
/*
 * Update lens flares update positions on all flares based on the screen position
 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
 */
THREE.LensFlare.prototype.updateLensFlares = function () {
  var f, fl = this.lensFlares.length;
  var flare;
  var vecX = -this.positionScreen.x * 2;
  var vecY = -this.positionScreen.y * 2;
  for (f = 0; f < fl; f++) {
    flare = this.lensFlares[f];
    flare.x = this.positionScreen.x + vecX * flare.distance;
    flare.y = this.positionScreen.y + vecY * flare.distance;
    flare.wantedRotation = flare.x * Math.PI * 0.25;
    flare.rotation += (flare.wantedRotation - flare.rotation) * 0.25;
  }
};
THREE.LensFlare.prototype.copy = function (source) {
  THREE.Object3D.prototype.copy.call(this, source);
  this.positionScreen.copy(source.positionScreen);
  this.customUpdateCallback = source.customUpdateCallback;
  for (var i = 0, l = source.lensFlares.length; i < l; i++) {
    this.lensFlares.push(source.lensFlares[i]);
  }
  return this;
};
// File:src/scenes/Scene.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
THREE.Scene = function () {
  THREE.Object3D.call(this);
  this.type = 'Scene';
  this.fog = null;
  this.overrideMaterial = null;
  this.autoUpdate = true;  // checked by the renderer
};
THREE.Scene.prototype = Object.create(THREE.Object3D.prototype);
THREE.Scene.prototype.constructor = THREE.Scene;
THREE.Scene.prototype.copy = function (source, recursive) {
  THREE.Object3D.prototype.copy.call(this, source, recursive);
  if (source.fog !== null)
    this.fog = source.fog.clone();
  if (source.overrideMaterial !== null)
    this.overrideMaterial = source.overrideMaterial.clone();
  this.autoUpdate = source.autoUpdate;
  this.matrixAutoUpdate = source.matrixAutoUpdate;
  return this;
};
// File:src/scenes/Fog.js
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */
THREE.Fog = function (color, near, far) {
  this.name = '';
  this.color = new THREE.Color(color);
  this.near = near !== undefined ? near : 1;
  this.far = far !== undefined ? far : 1000;
};
THREE.Fog.prototype.clone = function () {
  return new THREE.Fog(this.color.getHex(), this.near, this.far);
};
// File:src/scenes/FogExp2.js
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */
THREE.FogExp2 = function (color, density) {
  this.name = '';
  this.color = new THREE.Color(color);
  this.density = density !== undefined ? density : 0.00025;
};
THREE.FogExp2.prototype.clone = function () {
  return new THREE.FogExp2(this.color.getHex(), this.density);
};
// File:src/renderers/shaders/ShaderChunk.js
THREE.ShaderChunk = {};
// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl
THREE.ShaderChunk['alphamap_fragment'] = '#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl
THREE.ShaderChunk['alphamap_pars_fragment'] = '#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl
THREE.ShaderChunk['alphatest_fragment'] = '#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl
THREE.ShaderChunk['aomap_fragment'] = '#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl
THREE.ShaderChunk['aomap_pars_fragment'] = '#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif';
// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl
THREE.ShaderChunk['begin_vertex'] = '\nvec3 transformed = vec3( position );\n';
// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl
THREE.ShaderChunk['beginnormal_vertex'] = '\nvec3 objectNormal = vec3( normal );\n';
// File:src/renderers/shaders/ShaderChunk/bsdfs.glsl
THREE.ShaderChunk['bsdfs'] = 'bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_Smith( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n';
// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl
THREE.ShaderChunk['bumpmap_pars_fragment'] = '#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl
THREE.ShaderChunk['color_fragment'] = '#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif';
// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl
THREE.ShaderChunk['color_pars_fragment'] = '#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl
THREE.ShaderChunk['color_pars_vertex'] = '#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif';
// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl
THREE.ShaderChunk['color_vertex'] = '#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif';
// File:src/renderers/shaders/ShaderChunk/common.glsl
THREE.ShaderChunk['common'] = '#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n';
// File:src/renderers/shaders/ShaderChunk/cube_uv_reflection_fragment.glsl
THREE.ShaderChunk['cube_uv_reflection_fragment'] = '#ifdef ENVMAP_TYPE_CUBE_UV\nconst float cubeUV_textureSize = 1024.0;\nint getFaceFromDirection(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    int face = -1;\n    if( absDirection.x > absDirection.z ) {\n        if(absDirection.x > absDirection.y )\n            face = direction.x > 0.0 ? 0 : 3;\n        else\n            face = direction.y > 0.0 ? 1 : 4;\n    }\n    else {\n        if(absDirection.z > absDirection.y )\n            face = direction.z > 0.0 ? 2 : 5;\n        else\n            face = direction.y > 0.0 ? 1 : 4;\n    }\n    return face;\n}\nconst float cubeUV_maxLods1 = log2(cubeUV_textureSize*0.25) - 1.0;\nconst float cubeUV_rangeClamp = exp2((6.0 - 1.0) * 2.0);\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n    float scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n    float dxRoughness = dFdx(roughness);\n    float dyRoughness = dFdy(roughness);\n    vec3 dx = dFdx( vec * scale * dxRoughness );\n    vec3 dy = dFdy( vec * scale * dyRoughness );\n    float d = max( dot( dx, dx ), dot( dy, dy ) );\n    d = clamp(d, 1.0, cubeUV_rangeClamp);\n    float mipLevel = 0.5 * log2(d);\n    return vec2(floor(mipLevel), fract(mipLevel));\n}\nconst float cubeUV_maxLods2 = log2(cubeUV_textureSize*0.25) - 2.0;\nconst float cubeUV_rcpTextureSize = 1.0 / cubeUV_textureSize;\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n    mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n    float a = 16.0 * cubeUV_rcpTextureSize;\n    vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n    vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n    float powScale = exp2_packed.x * exp2_packed.y;\n    float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n    float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n    bool bRes = mipLevel == 0.0;\n    scale =  bRes && (scale < a) ? a : scale;\n    vec3 r;\n    vec2 offset;\n    int face = getFaceFromDirection(direction);\n    float rcpPowScale = 1.0 / powScale;\n    if( face == 0) {\n        r = vec3(direction.x, -direction.z, direction.y);\n        offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n        offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n    }\n    else if( face == 1) {\n        r = vec3(direction.y, direction.x, direction.z);\n        offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n        offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n    }\n    else if( face == 2) {\n        r = vec3(direction.z, direction.x, direction.y);\n        offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n        offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n    }\n    else if( face == 3) {\n        r = vec3(direction.x, direction.z, direction.y);\n        offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n        offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n    }\n    else if( face == 4) {\n        r = vec3(direction.y, direction.x, -direction.z);\n        offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n        offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n    }\n    else {\n        r = vec3(direction.z, -direction.x, direction.y);\n        offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n        offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n    }\n    r = normalize(r);\n    float texelOffset = 0.5 * cubeUV_rcpTextureSize;\n    vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n    vec2 base = offset + vec2( texelOffset );\n    return base + s * ( scale - 2.0 * texelOffset );\n}\nconst float cubeUV_maxLods3 = log2(cubeUV_textureSize*0.25) - 3.0;\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n    float roughnessVal = roughness* cubeUV_maxLods3;\n    float r1 = floor(roughnessVal);\n    float r2 = r1 + 1.0;\n    float t = fract(roughnessVal);\n    vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n    float s = mipInfo.y;\n    float level0 = mipInfo.x;\n    float level1 = level0 + 1.0;\n    level1 = level1 > 5.0 ? 5.0 : level1;\n    level0 += min( floor( s + 0.5 ), 5.0 );\n    vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n    vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n    vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n    vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n    vec4 result = mix(color10, color20, t);\n    return vec4(result.rgb, 1.0);\n}\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl
THREE.ShaderChunk['defaultnormal_vertex'] = '#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n';
// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl
THREE.ShaderChunk['displacementmap_vertex'] = '#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl
THREE.ShaderChunk['displacementmap_pars_vertex'] = '#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl
THREE.ShaderChunk['emissivemap_fragment'] = '#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl
THREE.ShaderChunk['emissivemap_pars_fragment'] = '#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/encodings_pars_fragment.glsl
THREE.ShaderChunk['encodings_pars_fragment'] = '\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n';
// File:src/renderers/shaders/ShaderChunk/encodings_fragment.glsl
THREE.ShaderChunk['encodings_fragment'] = '  gl_FragColor = linearToOutputTexel( gl_FragColor );\n';
// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl
THREE.ShaderChunk['envmap_fragment'] = '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#else\n\t\tfloat flipNormal = 1.0;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl
THREE.ShaderChunk['envmap_pars_fragment'] = '#if defined( USE_ENVMAP ) || defined( STANDARD )\n\tuniform float reflectivity;\n\tuniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( STANDARD )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl
THREE.ShaderChunk['envmap_pars_vertex'] = '#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG ) && ! defined( STANDARD )\n\tvarying vec3 vReflect;\n\tuniform float refractionRatio;\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl
THREE.ShaderChunk['envmap_vertex'] = '#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG ) && ! defined( STANDARD )\n\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t#ifdef ENVMAP_MODE_REFLECTION\n\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t#else\n\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t#endif\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl
THREE.ShaderChunk['fog_fragment'] = '#ifdef USE_FOG\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl
THREE.ShaderChunk['fog_pars_fragment'] = '#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif';
// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl
THREE.ShaderChunk['lightmap_fragment'] = '#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl
THREE.ShaderChunk['lightmap_pars_fragment'] = '#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif';
// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl
THREE.ShaderChunk['lights_lambert_vertex'] = 'vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tdirectLight = getPointDirectLightIrradiance( pointLights[ i ], geometry );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tdirectLight = getSpotDirectLightIrradiance( spotLights[ i ], geometry );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectLight = getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/lights_pars.glsl
THREE.ShaderChunk['lights_pars'] = 'uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tIncidentLight getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry ) {\n\t\tIncidentLight directLight;\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t\treturn directLight;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tIncidentLight getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry ) {\n\t\tIncidentLight directLight;\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\n\t\t\tdirectLight.color = pointLight.color;\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t\treturn directLight;\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tIncidentLight getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry ) {\n\t\tIncidentLight directLight;\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t\treturn directLight;\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( STANDARD )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#else\n\t\t\tfloat flipNormal = 1.0;\n\t\t#endif\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#else\n\t\t\tfloat flipNormal = 1.0;\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t#endif\n\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl
THREE.ShaderChunk['lights_phong_fragment'] = 'BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n';
// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl
THREE.ShaderChunk['lights_phong_pars_fragment'] = '#ifdef USE_ENVMAP\n\tvarying vec3 vWorldPosition;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n';
// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl
THREE.ShaderChunk['lights_phong_pars_vertex'] = '#ifdef USE_ENVMAP\n\tvarying vec3 vWorldPosition;\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl
THREE.ShaderChunk['lights_phong_vertex'] = '#ifdef USE_ENVMAP\n\tvWorldPosition = worldPosition.xyz;\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/lights_standard_fragment.glsl
THREE.ShaderChunk['lights_standard_fragment'] = 'StandardMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\nmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n';
// File:src/renderers/shaders/ShaderChunk/lights_standard_pars_fragment.glsl
THREE.ShaderChunk['lights_standard_pars_fragment'] = 'struct StandardMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n};\nvoid RE_Direct_Standard( const in IncidentLight directLight, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n}\nvoid RE_IndirectDiffuse_Standard( const in vec3 irradiance, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Standard( const in vec3 radiance, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Standard\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Standard\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Standard\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n';
// File:src/renderers/shaders/ShaderChunk/lights_template.glsl
THREE.ShaderChunk['lights_template'] = '\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tdirectLight = getPointDirectLightIrradiance( pointLight, geometry );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tdirectLight = getSpotDirectLightIrradiance( spotLight, geometry );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tdirectLight = getDirectionalDirectLightIrradiance( directionalLight, geometry );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\tRE_IndirectSpecular( radiance, geometry, material, reflectedLight );\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl
THREE.ShaderChunk['logdepthbuf_fragment'] = '#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif';
// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl
THREE.ShaderChunk['logdepthbuf_pars_fragment'] = '#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl
THREE.ShaderChunk['logdepthbuf_pars_vertex'] = '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif';
// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl
THREE.ShaderChunk['logdepthbuf_vertex'] = '#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl
THREE.ShaderChunk['map_fragment'] = '#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl
THREE.ShaderChunk['map_pars_fragment'] = '#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl
THREE.ShaderChunk['map_particle_fragment'] = '#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl
THREE.ShaderChunk['map_particle_pars_fragment'] = '#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl
THREE.ShaderChunk['metalnessmap_fragment'] = 'float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl
THREE.ShaderChunk['metalnessmap_pars_fragment'] = '#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif';
// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl
THREE.ShaderChunk['morphnormal_vertex'] = '#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl
THREE.ShaderChunk['morphtarget_pars_vertex'] = '#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif';
// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl
THREE.ShaderChunk['morphtarget_vertex'] = '#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/normal_fragment.glsl
THREE.ShaderChunk['normal_fragment'] = '#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\t#endif\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl
THREE.ShaderChunk['normalmap_pars_fragment'] = '#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/premultiplied_alpha_fragment.glsl
THREE.ShaderChunk['premultiplied_alpha_fragment'] = '#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl
THREE.ShaderChunk['project_vertex'] = '#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n';
// File:src/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl
THREE.ShaderChunk['roughnessmap_fragment'] = 'float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl
THREE.ShaderChunk['roughnessmap_pars_fragment'] = '#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif';
// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl
THREE.ShaderChunk['shadowmap_pars_fragment'] = '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat unpackDepth( const in vec4 rgba_depth ) {\n\t\tconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n\t\treturn dot( rgba_depth, bit_shift );\n\t}\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl
THREE.ShaderChunk['shadowmap_pars_vertex'] = '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl
THREE.ShaderChunk['shadowmap_vertex'] = '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl
THREE.ShaderChunk['shadowmask_pars_fragment'] = 'float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n';
// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl
THREE.ShaderChunk['skinbase_vertex'] = '#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif';
// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl
THREE.ShaderChunk['skinning_pars_vertex'] = '#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneGlobalMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl
THREE.ShaderChunk['skinning_vertex'] = '#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl
THREE.ShaderChunk['skinnormal_vertex'] = '#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl
THREE.ShaderChunk['specularmap_fragment'] = 'float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif';
// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl
THREE.ShaderChunk['specularmap_pars_fragment'] = '#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif';
// File:src/renderers/shaders/ShaderChunk/tonemapping_fragment.glsl
THREE.ShaderChunk['tonemapping_fragment'] = '#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/tonemapping_pars_fragment.glsl
THREE.ShaderChunk['tonemapping_pars_fragment'] = '#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n';
// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl
THREE.ShaderChunk['uv2_pars_fragment'] = '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif';
// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl
THREE.ShaderChunk['uv2_pars_vertex'] = '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif';
// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl
THREE.ShaderChunk['uv2_vertex'] = '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif';
// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl
THREE.ShaderChunk['uv_pars_fragment'] = '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif';
// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl
THREE.ShaderChunk['uv_pars_vertex'] = '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n';
// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl
THREE.ShaderChunk['uv_vertex'] = '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif';
// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl
THREE.ShaderChunk['worldpos_vertex'] = '#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( STANDARD ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n';
// File:src/renderers/shaders/UniformsUtils.js
/**
 * Uniform Utilities
 */
THREE.UniformsUtils = {
  merge: function (uniforms) {
    var merged = {};
    for (var u = 0; u < uniforms.length; u++) {
      var tmp = this.clone(uniforms[u]);
      for (var p in tmp) {
        merged[p] = tmp[p];
      }
    }
    return merged;
  },
  clone: function (uniforms_src) {
    var uniforms_dst = {};
    for (var u in uniforms_src) {
      uniforms_dst[u] = {};
      for (var p in uniforms_src[u]) {
        var parameter_src = uniforms_src[u][p];
        if (parameter_src instanceof THREE.Color || parameter_src instanceof THREE.Vector2 || parameter_src instanceof THREE.Vector3 || parameter_src instanceof THREE.Vector4 || parameter_src instanceof THREE.Matrix3 || parameter_src instanceof THREE.Matrix4 || parameter_src instanceof THREE.Texture) {
          uniforms_dst[u][p] = parameter_src.clone();
        } else if (Array.isArray(parameter_src)) {
          uniforms_dst[u][p] = parameter_src.slice();
        } else {
          uniforms_dst[u][p] = parameter_src;
        }
      }
    }
    return uniforms_dst;
  }
};
// File:src/renderers/shaders/UniformsLib.js
/**
 * Uniforms library for shared webgl shaders
 */
THREE.UniformsLib = {
  common: {
    'diffuse': {
      type: 'c',
      value: new THREE.Color(15658734)
    },
    'opacity': {
      type: 'f',
      value: 1
    },
    'map': {
      type: 't',
      value: null
    },
    'offsetRepeat': {
      type: 'v4',
      value: new THREE.Vector4(0, 0, 1, 1)
    },
    'specularMap': {
      type: 't',
      value: null
    },
    'alphaMap': {
      type: 't',
      value: null
    },
    'envMap': {
      type: 't',
      value: null
    },
    'flipEnvMap': {
      type: 'f',
      value: -1
    },
    'reflectivity': {
      type: 'f',
      value: 1
    },
    'refractionRatio': {
      type: 'f',
      value: 0.98
    }
  },
  aomap: {
    'aoMap': {
      type: 't',
      value: null
    },
    'aoMapIntensity': {
      type: 'f',
      value: 1
    }
  },
  lightmap: {
    'lightMap': {
      type: 't',
      value: null
    },
    'lightMapIntensity': {
      type: 'f',
      value: 1
    }
  },
  emissivemap: {
    'emissiveMap': {
      type: 't',
      value: null
    }
  },
  bumpmap: {
    'bumpMap': {
      type: 't',
      value: null
    },
    'bumpScale': {
      type: 'f',
      value: 1
    }
  },
  normalmap: {
    'normalMap': {
      type: 't',
      value: null
    },
    'normalScale': {
      type: 'v2',
      value: new THREE.Vector2(1, 1)
    }
  },
  displacementmap: {
    'displacementMap': {
      type: 't',
      value: null
    },
    'displacementScale': {
      type: 'f',
      value: 1
    },
    'displacementBias': {
      type: 'f',
      value: 0
    }
  },
  roughnessmap: {
    'roughnessMap': {
      type: 't',
      value: null
    }
  },
  metalnessmap: {
    'metalnessMap': {
      type: 't',
      value: null
    }
  },
  fog: {
    'fogDensity': {
      type: 'f',
      value: 0.00025
    },
    'fogNear': {
      type: 'f',
      value: 1
    },
    'fogFar': {
      type: 'f',
      value: 2000
    },
    'fogColor': {
      type: 'c',
      value: new THREE.Color(16777215)
    }
  },
  lights: {
    'ambientLightColor': {
      type: 'fv',
      value: []
    },
    'directionalLights': {
      type: 'sa',
      value: [],
      properties: {
        'direction': { type: 'v3' },
        'color': { type: 'c' },
        'shadow': { type: 'i' },
        'shadowBias': { type: 'f' },
        'shadowRadius': { type: 'f' },
        'shadowMapSize': { type: 'v2' }
      }
    },
    'directionalShadowMap': {
      type: 'tv',
      value: []
    },
    'directionalShadowMatrix': {
      type: 'm4v',
      value: []
    },
    'spotLights': {
      type: 'sa',
      value: [],
      properties: {
        'color': { type: 'c' },
        'position': { type: 'v3' },
        'direction': { type: 'v3' },
        'distance': { type: 'f' },
        'coneCos': { type: 'f' },
        'penumbraCos': { type: 'f' },
        'decay': { type: 'f' },
        'shadow': { type: 'i' },
        'shadowBias': { type: 'f' },
        'shadowRadius': { type: 'f' },
        'shadowMapSize': { type: 'v2' }
      }
    },
    'spotShadowMap': {
      type: 'tv',
      value: []
    },
    'spotShadowMatrix': {
      type: 'm4v',
      value: []
    },
    'pointLights': {
      type: 'sa',
      value: [],
      properties: {
        'color': { type: 'c' },
        'position': { type: 'v3' },
        'decay': { type: 'f' },
        'distance': { type: 'f' },
        'shadow': { type: 'i' },
        'shadowBias': { type: 'f' },
        'shadowRadius': { type: 'f' },
        'shadowMapSize': { type: 'v2' }
      }
    },
    'pointShadowMap': {
      type: 'tv',
      value: []
    },
    'pointShadowMatrix': {
      type: 'm4v',
      value: []
    },
    'hemisphereLights': {
      type: 'sa',
      value: [],
      properties: {
        'direction': { type: 'v3' },
        'skyColor': { type: 'c' },
        'groundColor': { type: 'c' }
      }
    }
  },
  points: {
    'diffuse': {
      type: 'c',
      value: new THREE.Color(15658734)
    },
    'opacity': {
      type: 'f',
      value: 1
    },
    'size': {
      type: 'f',
      value: 1
    },
    'scale': {
      type: 'f',
      value: 1
    },
    'map': {
      type: 't',
      value: null
    },
    'offsetRepeat': {
      type: 'v4',
      value: new THREE.Vector4(0, 0, 1, 1)
    }
  }
};
// File:src/renderers/shaders/ShaderLib/depthRGBA_frag.glsl
THREE.ShaderChunk['depthRGBA_frag'] = '#include <common>\n#include <logdepthbuf_pars_fragment>\nvec4 pack_depth( const in float depth ) {\n\tconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n\tconst vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n\tvec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tgl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );\n\t#else\n\t\tgl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\n\t#endif\n}\n';
// File:src/renderers/shaders/ShaderLib/depthRGBA_vert.glsl
THREE.ShaderChunk['depthRGBA_vert'] = '#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n}\n';
// File:src/renderers/shaders/ShaderLib/distanceRGBA_frag.glsl
THREE.ShaderChunk['distanceRGBA_frag'] = 'uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\nvec4 pack1K ( float depth ) {\n\tdepth /= 1000.0;\n\tconst vec4 bitSh = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n\tconst vec4 bitMsk = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n\tvec4 res = mod( depth * bitSh * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n\tres -= res.xxyz * bitMsk;\n\treturn res;\n}\nfloat unpack1K ( vec4 color ) {\n\tconst vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n\treturn dot( color, bitSh ) * 1000.0;\n}\nvoid main () {\n\tgl_FragColor = pack1K( length( vWorldPosition.xyz - lightPos.xyz ) );\n}\n';
// File:src/renderers/shaders/ShaderLib/distanceRGBA_vert.glsl
THREE.ShaderChunk['distanceRGBA_vert'] = 'varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\tvWorldPosition = worldPosition;\n}\n';
// File:src/renderers/shaders/ShaderLib/linedashed_frag.glsl
THREE.ShaderChunk['linedashed_frag'] = 'uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n';
// File:src/renderers/shaders/ShaderLib/linedashed_vert.glsl
THREE.ShaderChunk['linedashed_vert'] = 'uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n}\n';
// File:src/renderers/shaders/ShaderLib/meshbasic_frag.glsl
THREE.ShaderChunk['meshbasic_frag'] = 'uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight;\n\treflectedLight.directDiffuse = vec3( 0.0 );\n\treflectedLight.directSpecular = vec3( 0.0 );\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\n\treflectedLight.indirectSpecular = vec3( 0.0 );\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n';
// File:src/renderers/shaders/ShaderLib/meshbasic_vert.glsl
THREE.ShaderChunk['meshbasic_vert'] = '#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n}\n';
// File:src/renderers/shaders/ShaderLib/meshlambert_frag.glsl
THREE.ShaderChunk['meshlambert_frag'] = 'uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n';
// File:src/renderers/shaders/ShaderLib/meshlambert_vert.glsl
THREE.ShaderChunk['meshlambert_vert'] = '#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n}\n';
// File:src/renderers/shaders/ShaderLib/meshphong_frag.glsl
THREE.ShaderChunk['meshphong_frag'] = '#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n';
// File:src/renderers/shaders/ShaderLib/meshphong_vert.glsl
THREE.ShaderChunk['meshphong_vert'] = '#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <lights_phong_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_phong_vertex>\n\t#include <shadowmap_vertex>\n}\n';
// File:src/renderers/shaders/ShaderLib/meshstandard_frag.glsl
THREE.ShaderChunk['meshstandard_frag'] = '#define STANDARD\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_standard_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_standard_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n';
// File:src/renderers/shaders/ShaderLib/meshstandard_vert.glsl
THREE.ShaderChunk['meshstandard_vert'] = '#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n}\n';
// File:src/renderers/shaders/ShaderLib.js
/**
 * Webgl Shader Library for three.js
 *
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */
THREE.ShaderLib = {
  'basic': {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib['common'],
      THREE.UniformsLib['aomap'],
      THREE.UniformsLib['fog']
    ]),
    vertexShader: THREE.ShaderChunk['meshbasic_vert'],
    fragmentShader: THREE.ShaderChunk['meshbasic_frag']
  },
  'lambert': {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib['common'],
      THREE.UniformsLib['aomap'],
      THREE.UniformsLib['lightmap'],
      THREE.UniformsLib['emissivemap'],
      THREE.UniformsLib['fog'],
      THREE.UniformsLib['lights'],
      {
        'emissive': {
          type: 'c',
          value: new THREE.Color(0)
        }
      }
    ]),
    vertexShader: THREE.ShaderChunk['meshlambert_vert'],
    fragmentShader: THREE.ShaderChunk['meshlambert_frag']
  },
  'phong': {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib['common'],
      THREE.UniformsLib['aomap'],
      THREE.UniformsLib['lightmap'],
      THREE.UniformsLib['emissivemap'],
      THREE.UniformsLib['bumpmap'],
      THREE.UniformsLib['normalmap'],
      THREE.UniformsLib['displacementmap'],
      THREE.UniformsLib['fog'],
      THREE.UniformsLib['lights'],
      {
        'emissive': {
          type: 'c',
          value: new THREE.Color(0)
        },
        'specular': {
          type: 'c',
          value: new THREE.Color(1118481)
        },
        'shininess': {
          type: 'f',
          value: 30
        }
      }
    ]),
    vertexShader: THREE.ShaderChunk['meshphong_vert'],
    fragmentShader: THREE.ShaderChunk['meshphong_frag']
  },
  'standard': {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib['common'],
      THREE.UniformsLib['aomap'],
      THREE.UniformsLib['lightmap'],
      THREE.UniformsLib['emissivemap'],
      THREE.UniformsLib['bumpmap'],
      THREE.UniformsLib['normalmap'],
      THREE.UniformsLib['displacementmap'],
      THREE.UniformsLib['roughnessmap'],
      THREE.UniformsLib['metalnessmap'],
      THREE.UniformsLib['fog'],
      THREE.UniformsLib['lights'],
      {
        'emissive': {
          type: 'c',
          value: new THREE.Color(0)
        },
        'roughness': {
          type: 'f',
          value: 0.5
        },
        'metalness': {
          type: 'f',
          value: 0
        },
        'envMapIntensity': {
          type: 'f',
          value: 1
        }  // temporary
      }
    ]),
    vertexShader: THREE.ShaderChunk['meshstandard_vert'],
    fragmentShader: THREE.ShaderChunk['meshstandard_frag']
  },
  'points': {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib['points'],
      THREE.UniformsLib['fog']
    ]),
    vertexShader: THREE.ShaderChunk['points_vert'],
    fragmentShader: THREE.ShaderChunk['points_frag']
  },
  'dashed': {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib['common'],
      THREE.UniformsLib['fog'],
      {
        'scale': {
          type: 'f',
          value: 1
        },
        'dashSize': {
          type: 'f',
          value: 1
        },
        'totalSize': {
          type: 'f',
          value: 2
        }
      }
    ]),
    vertexShader: THREE.ShaderChunk['linedashed_vert'],
    fragmentShader: THREE.ShaderChunk['linedashed_frag']
  },
  'depth': {
    uniforms: {
      'mNear': {
        type: 'f',
        value: 1
      },
      'mFar': {
        type: 'f',
        value: 2000
      },
      'opacity': {
        type: 'f',
        value: 1
      }
    },
    vertexShader: THREE.ShaderChunk['depth_vert'],
    fragmentShader: THREE.ShaderChunk['depth_frag']
  },
  'normal': {
    uniforms: {
      'opacity': {
        type: 'f',
        value: 1
      }
    },
    vertexShader: THREE.ShaderChunk['normal_vert'],
    fragmentShader: THREE.ShaderChunk['normal_frag']
  },
  /* -------------------------------------------------------------------------
  	//	Cube map shader
  	 ------------------------------------------------------------------------- */
  'cube': {
    uniforms: {
      'tCube': {
        type: 't',
        value: null
      },
      'tFlip': {
        type: 'f',
        value: -1
      }
    },
    vertexShader: THREE.ShaderChunk['cube_vert'],
    fragmentShader: THREE.ShaderChunk['cube_frag']
  },
  /* -------------------------------------------------------------------------
  	//	Cube map shader
  	 ------------------------------------------------------------------------- */
  'equirect': {
    uniforms: {
      'tEquirect': {
        type: 't',
        value: null
      },
      'tFlip': {
        type: 'f',
        value: -1
      }
    },
    vertexShader: THREE.ShaderChunk['equirect_vert'],
    fragmentShader: THREE.ShaderChunk['equirect_frag']
  },
  /* Depth encoding into RGBA texture
  *
  * based on SpiderGL shadow map example
  * http://spidergl.org/example.php?id=6
  *
  * originally from
  * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
  *
  * see also
  * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
  */
  'depthRGBA': {
    uniforms: {},
    vertexShader: THREE.ShaderChunk['depthRGBA_vert'],
    fragmentShader: THREE.ShaderChunk['depthRGBA_frag']
  },
  'distanceRGBA': {
    uniforms: {
      'lightPos': {
        type: 'v3',
        value: new THREE.Vector3(0, 0, 0)
      }
    },
    vertexShader: THREE.ShaderChunk['distanceRGBA_vert'],
    fragmentShader: THREE.ShaderChunk['distanceRGBA_frag']
  }
};
// File:src/renderers/WebGLRenderer.js
/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */
THREE.WebGLRenderer = function (parameters) {
  console.log('THREE.WebGLRenderer', THREE.REVISION);
  parameters = parameters || {};
  var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement('canvas'), _context = parameters.context !== undefined ? parameters.context : null, _alpha = parameters.alpha !== undefined ? parameters.alpha : false, _depth = parameters.depth !== undefined ? parameters.depth : true, _stencil = parameters.stencil !== undefined ? parameters.stencil : true, _antialias = parameters.antialias !== undefined ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;
  var lights = [];
  var opaqueObjects = [];
  var opaqueObjectsLastIndex = -1;
  var transparentObjects = [];
  var transparentObjectsLastIndex = -1;
  var morphInfluences = new Float32Array(8);
  var sprites = [];
  var lensFlares = [];
  // public properties
  this.domElement = _canvas;
  this.context = null;
  // clearing
  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true;
  // scene graph
  this.sortObjects = true;
  // physically based shading
  this.gammaFactor = 2;
  // for backwards compatibility
  this.gammaInput = false;
  this.gammaOutput = false;
  // physical lights
  this.physicallyCorrectLights = false;
  // tone mapping
  this.toneMapping = THREE.LinearToneMapping;
  this.toneMappingExposure = 1;
  this.toneMappingWhitePoint = 1;
  // morphs
  this.maxMorphTargets = 8;
  this.maxMorphNormals = 4;
  // flags
  this.autoScaleCubemaps = true;
  // internal properties
  var _this = this,
    // internal state cache
    _currentProgram = null, _currentRenderTarget = null, _currentFramebuffer = null, _currentMaterialId = -1, _currentGeometryProgram = '', _currentCamera = null, _currentScissor = new THREE.Vector4(), _currentScissorTest = null, _currentViewport = new THREE.Vector4(),
    //
    _usedTextureUnits = 0,
    //
    _clearColor = new THREE.Color(0), _clearAlpha = 0, _width = _canvas.width, _height = _canvas.height, _pixelRatio = 1, _scissor = new THREE.Vector4(0, 0, _width, _height), _scissorTest = false, _viewport = new THREE.Vector4(0, 0, _width, _height),
    // frustum
    _frustum = new THREE.Frustum(),
    // camera matrices cache
    _projScreenMatrix = new THREE.Matrix4(), _vector3 = new THREE.Vector3(),
    // light arrays cache
    _lights = {
      hash: '',
      ambient: [
        0,
        0,
        0
      ],
      directional: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotShadowMap: [],
      spotShadowMatrix: [],
      point: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      shadows: [],
      shadowsPointLight: 0
    },
    // info
    _infoMemory = {
      geometries: 0,
      textures: 0
    }, _infoRender = {
      calls: 0,
      vertices: 0,
      faces: 0,
      points: 0
    };
  this.info = {
    render: _infoRender,
    memory: _infoMemory,
    programs: null
  };
  // initialize
  var _gl;
  try {
    var attributes = {
      alpha: _alpha,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer
    };
    _gl = _context || _canvas.getContext('webgl', attributes) || _canvas.getContext('experimental-webgl', attributes);
    if (_gl === null) {
      if (_canvas.getContext('webgl') !== null) {
        throw 'Error creating WebGL context with your selected attributes.';
      } else {
        throw 'Error creating WebGL context.';
      }
    }
    // Some experimental-webgl implementations do not have getShaderPrecisionFormat
    if (_gl.getShaderPrecisionFormat === undefined) {
      _gl.getShaderPrecisionFormat = function () {
        return {
          'rangeMin': 1,
          'rangeMax': 1,
          'precision': 1
        };
      };
    }
    _canvas.addEventListener('webglcontextlost', onContextLost, false);
  } catch (error) {
    console.error('THREE.WebGLRenderer: ' + error);
  }
  var extensions = new THREE.WebGLExtensions(_gl);
  extensions.get('OES_texture_float');
  extensions.get('OES_texture_float_linear');
  extensions.get('OES_texture_half_float');
  extensions.get('OES_texture_half_float_linear');
  extensions.get('OES_standard_derivatives');
  extensions.get('ANGLE_instanced_arrays');
  if (extensions.get('OES_element_index_uint')) {
    THREE.BufferGeometry.MaxIndex = 4294967296;
  }
  var capabilities = new THREE.WebGLCapabilities(_gl, extensions, parameters);
  var state = new THREE.WebGLState(_gl, extensions, paramThreeToGL);
  var properties = new THREE.WebGLProperties();
  var objects = new THREE.WebGLObjects(_gl, properties, this.info);
  var programCache = new THREE.WebGLPrograms(this, capabilities);
  var lightCache = new THREE.WebGLLights();
  this.info.programs = programCache.programs;
  var bufferRenderer = new THREE.WebGLBufferRenderer(_gl, extensions, _infoRender);
  var indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer(_gl, extensions, _infoRender);
  //
  function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1;
  }
  function glClearColor(r, g, b, a) {
    if (_premultipliedAlpha === true) {
      r *= a;
      g *= a;
      b *= a;
    }
    state.clearColor(r, g, b, a);
  }
  function setDefaultGLState() {
    state.init();
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));
    glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
  }
  function resetGLState() {
    _currentProgram = null;
    _currentCamera = null;
    _currentGeometryProgram = '';
    _currentMaterialId = -1;
    state.reset();
  }
  setDefaultGLState();
  this.context = _gl;
  this.capabilities = capabilities;
  this.extensions = extensions;
  this.properties = properties;
  this.state = state;
  // shadow map
  var shadowMap = new THREE.WebGLShadowMap(this, _lights, objects);
  this.shadowMap = shadowMap;
  // Plugins
  var spritePlugin = new THREE.SpritePlugin(this, sprites);
  var lensFlarePlugin = new THREE.LensFlarePlugin(this, lensFlares);
  // API
  this.getContext = function () {
    return _gl;
  };
  this.getContextAttributes = function () {
    return _gl.getContextAttributes();
  };
  this.forceContextLoss = function () {
    extensions.get('WEBGL_lose_context').loseContext();
  };
  this.getMaxAnisotropy = function () {
    var value;
    return function getMaxAnisotropy() {
      if (value !== undefined)
        return value;
      var extension = extensions.get('EXT_texture_filter_anisotropic');
      if (extension !== null) {
        value = _gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      } else {
        value = 0;
      }
      return value;
    };
  }();
  this.getPrecision = function () {
    return capabilities.precision;
  };
  this.getPixelRatio = function () {
    return _pixelRatio;
  };
  this.setPixelRatio = function (value) {
    if (value === undefined)
      return;
    _pixelRatio = value;
    this.setSize(_viewport.z, _viewport.w, false);
  };
  this.getSize = function () {
    return {
      width: _width,
      height: _height
    };
  };
  this.setSize = function (width, height, updateStyle) {
    _width = width;
    _height = height;
    _canvas.width = width * _pixelRatio;
    _canvas.height = height * _pixelRatio;
    if (updateStyle !== false) {
      _canvas.style.width = width + 'px';
      _canvas.style.height = height + 'px';
    }
    this.setViewport(0, 0, width, height);
  };
  this.setViewport = function (x, y, width, height) {
    state.viewport(_viewport.set(x, y, width, height));
  };
  this.setScissor = function (x, y, width, height) {
    state.scissor(_scissor.set(x, y, width, height));
  };
  this.setScissorTest = function (boolean) {
    state.setScissorTest(_scissorTest = boolean);
  };
  // Clearing
  this.getClearColor = function () {
    return _clearColor;
  };
  this.setClearColor = function (color, alpha) {
    _clearColor.set(color);
    _clearAlpha = alpha !== undefined ? alpha : 1;
    glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
  };
  this.getClearAlpha = function () {
    return _clearAlpha;
  };
  this.setClearAlpha = function (alpha) {
    _clearAlpha = alpha;
    glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
  };
  this.clear = function (color, depth, stencil) {
    var bits = 0;
    if (color === undefined || color)
      bits |= _gl.COLOR_BUFFER_BIT;
    if (depth === undefined || depth)
      bits |= _gl.DEPTH_BUFFER_BIT;
    if (stencil === undefined || stencil)
      bits |= _gl.STENCIL_BUFFER_BIT;
    _gl.clear(bits);
  };
  this.clearColor = function () {
    this.clear(true, false, false);
  };
  this.clearDepth = function () {
    this.clear(false, true, false);
  };
  this.clearStencil = function () {
    this.clear(false, false, true);
  };
  this.clearTarget = function (renderTarget, color, depth, stencil) {
    this.setRenderTarget(renderTarget);
    this.clear(color, depth, stencil);
  };
  // Reset
  this.resetGLState = resetGLState;
  this.dispose = function () {
    _canvas.removeEventListener('webglcontextlost', onContextLost, false);
  };
  // Events
  function onContextLost(event) {
    event.preventDefault();
    resetGLState();
    setDefaultGLState();
    properties.clear();
  }
  function onTextureDispose(event) {
    var texture = event.target;
    texture.removeEventListener('dispose', onTextureDispose);
    deallocateTexture(texture);
    _infoMemory.textures--;
  }
  function onRenderTargetDispose(event) {
    var renderTarget = event.target;
    renderTarget.removeEventListener('dispose', onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
    _infoMemory.textures--;
  }
  function onMaterialDispose(event) {
    var material = event.target;
    material.removeEventListener('dispose', onMaterialDispose);
    deallocateMaterial(material);
  }
  // Buffer deallocation
  function deallocateTexture(texture) {
    var textureProperties = properties.get(texture);
    if (texture.image && textureProperties.__image__webglTextureCube) {
      // cube texture
      _gl.deleteTexture(textureProperties.__image__webglTextureCube);
    } else {
      // 2D texture
      if (textureProperties.__webglInit === undefined)
        return;
      _gl.deleteTexture(textureProperties.__webglTexture);
    }
    // remove all webgl properties
    properties.delete(texture);
  }
  function deallocateRenderTarget(renderTarget) {
    var renderTargetProperties = properties.get(renderTarget);
    var textureProperties = properties.get(renderTarget.texture);
    if (!renderTarget || textureProperties.__webglTexture === undefined)
      return;
    _gl.deleteTexture(textureProperties.__webglTexture);
    if (renderTarget instanceof THREE.WebGLRenderTargetCube) {
      for (var i = 0; i < 6; i++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
    }
    properties.delete(renderTarget.texture);
    properties.delete(renderTarget);
  }
  function deallocateMaterial(material) {
    releaseMaterialProgramReference(material);
    properties.delete(material);
  }
  function releaseMaterialProgramReference(material) {
    var programInfo = properties.get(material).program;
    material.program = undefined;
    if (programInfo !== undefined) {
      programCache.releaseProgram(programInfo);
    }
  }
  // Buffer rendering
  this.renderBufferImmediate = function (object, program, material) {
    state.initAttributes();
    var buffers = properties.get(object);
    if (object.hasPositions && !buffers.position)
      buffers.position = _gl.createBuffer();
    if (object.hasNormals && !buffers.normal)
      buffers.normal = _gl.createBuffer();
    if (object.hasUvs && !buffers.uv)
      buffers.uv = _gl.createBuffer();
    if (object.hasColors && !buffers.color)
      buffers.color = _gl.createBuffer();
    var attributes = program.getAttributes();
    if (object.hasPositions) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);
      _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);
      state.enableAttribute(attributes.position);
      _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, false, 0, 0);
    }
    if (object.hasNormals) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);
      if (material.type !== 'MeshPhongMaterial' && material.type !== 'MeshStandardMaterial' && material.shading === THREE.FlatShading) {
        for (var i = 0, l = object.count * 3; i < l; i += 9) {
          var array = object.normalArray;
          var nx = (array[i + 0] + array[i + 3] + array[i + 6]) / 3;
          var ny = (array[i + 1] + array[i + 4] + array[i + 7]) / 3;
          var nz = (array[i + 2] + array[i + 5] + array[i + 8]) / 3;
          array[i + 0] = nx;
          array[i + 1] = ny;
          array[i + 2] = nz;
          array[i + 3] = nx;
          array[i + 4] = ny;
          array[i + 5] = nz;
          array[i + 6] = nx;
          array[i + 7] = ny;
          array[i + 8] = nz;
        }
      }
      _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);
      state.enableAttribute(attributes.normal);
      _gl.vertexAttribPointer(attributes.normal, 3, _gl.FLOAT, false, 0, 0);
    }
    if (object.hasUvs && material.map) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);
      _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);
      state.enableAttribute(attributes.uv);
      _gl.vertexAttribPointer(attributes.uv, 2, _gl.FLOAT, false, 0, 0);
    }
    if (object.hasColors && material.vertexColors !== THREE.NoColors) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);
      _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);
      state.enableAttribute(attributes.color);
      _gl.vertexAttribPointer(attributes.color, 3, _gl.FLOAT, false, 0, 0);
    }
    state.disableUnusedAttributes();
    _gl.drawArrays(_gl.TRIANGLES, 0, object.count);
    object.count = 0;
  };
  this.renderBufferDirect = function (camera, fog, geometry, material, object, group) {
    setMaterial(material);
    var program = setProgram(camera, fog, material, object);
    var updateBuffers = false;
    var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;
    if (geometryProgram !== _currentGeometryProgram) {
      _currentGeometryProgram = geometryProgram;
      updateBuffers = true;
    }
    // morph targets
    var morphTargetInfluences = object.morphTargetInfluences;
    if (morphTargetInfluences !== undefined) {
      var activeInfluences = [];
      for (var i = 0, l = morphTargetInfluences.length; i < l; i++) {
        var influence = morphTargetInfluences[i];
        activeInfluences.push([
          influence,
          i
        ]);
      }
      activeInfluences.sort(absNumericalSort);
      if (activeInfluences.length > 8) {
        activeInfluences.length = 8;
      }
      var morphAttributes = geometry.morphAttributes;
      for (var i = 0, l = activeInfluences.length; i < l; i++) {
        var influence = activeInfluences[i];
        morphInfluences[i] = influence[0];
        if (influence[0] !== 0) {
          var index = influence[1];
          if (material.morphTargets === true && morphAttributes.position)
            geometry.addAttribute('morphTarget' + i, morphAttributes.position[index]);
          if (material.morphNormals === true && morphAttributes.normal)
            geometry.addAttribute('morphNormal' + i, morphAttributes.normal[index]);
        } else {
          if (material.morphTargets === true)
            geometry.removeAttribute('morphTarget' + i);
          if (material.morphNormals === true)
            geometry.removeAttribute('morphNormal' + i);
        }
      }
      var uniforms = program.getUniforms();
      if (uniforms.morphTargetInfluences !== null) {
        _gl.uniform1fv(uniforms.morphTargetInfluences, morphInfluences);
      }
      updateBuffers = true;
    }
    //
    var index = geometry.index;
    var position = geometry.attributes.position;
    if (material.wireframe === true) {
      index = objects.getWireframeAttribute(geometry);
    }
    var renderer;
    if (index !== null) {
      renderer = indexedBufferRenderer;
      renderer.setIndex(index);
    } else {
      renderer = bufferRenderer;
    }
    if (updateBuffers) {
      setupVertexAttributes(material, program, geometry);
      if (index !== null) {
        _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer(index));
      }
    }
    //
    var dataStart = 0;
    var dataCount = Infinity;
    if (index !== null) {
      dataCount = index.count;
    } else if (position !== undefined) {
      dataCount = position.count;
    }
    var rangeStart = geometry.drawRange.start;
    var rangeCount = geometry.drawRange.count;
    var groupStart = group !== null ? group.start : 0;
    var groupCount = group !== null ? group.count : Infinity;
    var drawStart = Math.max(dataStart, rangeStart, groupStart);
    var drawEnd = Math.min(dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
    var drawCount = Math.max(0, drawEnd - drawStart + 1);
    //
    if (object instanceof THREE.Mesh) {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
        renderer.setMode(_gl.LINES);
      } else {
        switch (object.drawMode) {
        case THREE.TrianglesDrawMode:
          renderer.setMode(_gl.TRIANGLES);
          break;
        case THREE.TriangleStripDrawMode:
          renderer.setMode(_gl.TRIANGLE_STRIP);
          break;
        case THREE.TriangleFanDrawMode:
          renderer.setMode(_gl.TRIANGLE_FAN);
          break;
        }
      }
    } else if (object instanceof THREE.Line) {
      var lineWidth = material.linewidth;
      if (lineWidth === undefined)
        lineWidth = 1;
      // Not using Line*Material
      state.setLineWidth(lineWidth * getTargetPixelRatio());
      if (object instanceof THREE.LineSegments) {
        renderer.setMode(_gl.LINES);
      } else {
        renderer.setMode(_gl.LINE_STRIP);
      }
    } else if (object instanceof THREE.Points) {
      renderer.setMode(_gl.POINTS);
    }
    if (geometry instanceof THREE.InstancedBufferGeometry) {
      if (geometry.maxInstancedCount > 0) {
        renderer.renderInstances(geometry, drawStart, drawCount);
      }
    } else {
      renderer.render(drawStart, drawCount);
    }
  };
  function setupVertexAttributes(material, program, geometry, startIndex) {
    var extension;
    if (geometry instanceof THREE.InstancedBufferGeometry) {
      extension = extensions.get('ANGLE_instanced_arrays');
      if (extension === null) {
        console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
        return;
      }
    }
    if (startIndex === undefined)
      startIndex = 0;
    state.initAttributes();
    var geometryAttributes = geometry.attributes;
    var programAttributes = program.getAttributes();
    var materialDefaultAttributeValues = material.defaultAttributeValues;
    for (var name in programAttributes) {
      var programAttribute = programAttributes[name];
      if (programAttribute >= 0) {
        var geometryAttribute = geometryAttributes[name];
        if (geometryAttribute !== undefined) {
          var size = geometryAttribute.itemSize;
          var buffer = objects.getAttributeBuffer(geometryAttribute);
          if (geometryAttribute instanceof THREE.InterleavedBufferAttribute) {
            var data = geometryAttribute.data;
            var stride = data.stride;
            var offset = geometryAttribute.offset;
            if (data instanceof THREE.InstancedInterleavedBuffer) {
              state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute, extension);
              if (geometry.maxInstancedCount === undefined) {
                geometry.maxInstancedCount = data.meshPerAttribute * data.count;
              }
            } else {
              state.enableAttribute(programAttribute);
            }
            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
            _gl.vertexAttribPointer(programAttribute, size, _gl.FLOAT, false, stride * data.array.BYTES_PER_ELEMENT, (startIndex * stride + offset) * data.array.BYTES_PER_ELEMENT);
          } else {
            if (geometryAttribute instanceof THREE.InstancedBufferAttribute) {
              state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute, extension);
              if (geometry.maxInstancedCount === undefined) {
                geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              state.enableAttribute(programAttribute);
            }
            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
            _gl.vertexAttribPointer(programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4);  // 4 bytes per Float32
          }
        } else if (materialDefaultAttributeValues !== undefined) {
          var value = materialDefaultAttributeValues[name];
          if (value !== undefined) {
            switch (value.length) {
            case 2:
              _gl.vertexAttrib2fv(programAttribute, value);
              break;
            case 3:
              _gl.vertexAttrib3fv(programAttribute, value);
              break;
            case 4:
              _gl.vertexAttrib4fv(programAttribute, value);
              break;
            default:
              _gl.vertexAttrib1fv(programAttribute, value);
            }
          }
        }
      }
    }
    state.disableUnusedAttributes();
  }
  // Sorting
  function absNumericalSort(a, b) {
    return Math.abs(b[0]) - Math.abs(a[0]);
  }
  function painterSortStable(a, b) {
    if (a.object.renderOrder !== b.object.renderOrder) {
      return a.object.renderOrder - b.object.renderOrder;
    } else if (a.material.id !== b.material.id) {
      return a.material.id - b.material.id;
    } else if (a.z !== b.z) {
      return a.z - b.z;
    } else {
      return a.id - b.id;
    }
  }
  function reversePainterSortStable(a, b) {
    if (a.object.renderOrder !== b.object.renderOrder) {
      return a.object.renderOrder - b.object.renderOrder;
    }
    if (a.z !== b.z) {
      return b.z - a.z;
    } else {
      return a.id - b.id;
    }
  }
  // Rendering
  this.render = function (scene, camera, renderTarget, forceClear) {
    if (camera instanceof THREE.Camera === false) {
      console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
      return;
    }
    var fog = scene.fog;
    // reset caching for this frame
    _currentGeometryProgram = '';
    _currentMaterialId = -1;
    _currentCamera = null;
    // update scene graph
    if (scene.autoUpdate === true)
      scene.updateMatrixWorld();
    // update camera matrices and frustum
    if (camera.parent === null)
      camera.updateMatrixWorld();
    camera.matrixWorldInverse.getInverse(camera.matrixWorld);
    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    _frustum.setFromMatrix(_projScreenMatrix);
    lights.length = 0;
    opaqueObjectsLastIndex = -1;
    transparentObjectsLastIndex = -1;
    sprites.length = 0;
    lensFlares.length = 0;
    projectObject(scene, camera);
    opaqueObjects.length = opaqueObjectsLastIndex + 1;
    transparentObjects.length = transparentObjectsLastIndex + 1;
    if (_this.sortObjects === true) {
      opaqueObjects.sort(painterSortStable);
      transparentObjects.sort(reversePainterSortStable);
    }
    setupLights(lights, camera);
    //
    shadowMap.render(scene, camera);
    //
    _infoRender.calls = 0;
    _infoRender.vertices = 0;
    _infoRender.faces = 0;
    _infoRender.points = 0;
    if (renderTarget === undefined) {
      renderTarget = null;
    }
    this.setRenderTarget(renderTarget);
    if (this.autoClear || forceClear) {
      this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
    }
    //
    if (scene.overrideMaterial) {
      var overrideMaterial = scene.overrideMaterial;
      renderObjects(opaqueObjects, camera, fog, overrideMaterial);
      renderObjects(transparentObjects, camera, fog, overrideMaterial);
    } else {
      // opaque pass (front-to-back order)
      state.setBlending(THREE.NoBlending);
      renderObjects(opaqueObjects, camera, fog);
      // transparent pass (back-to-front order)
      renderObjects(transparentObjects, camera, fog);
    }
    // custom render plugins (post pass)
    spritePlugin.render(scene, camera);
    lensFlarePlugin.render(scene, camera, _currentViewport);
    // Generate mipmap if we're using any kind of mipmap filtering
    if (renderTarget) {
      var texture = renderTarget.texture;
      if (texture.generateMipmaps && isPowerOfTwo(renderTarget) && texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter) {
        updateRenderTargetMipmap(renderTarget);
      }
    }
    // Ensure depth buffer writing is enabled so it can be cleared on next render
    state.setDepthTest(true);
    state.setDepthWrite(true);
    state.setColorWrite(true);  // _gl.finish();
  };
  function pushRenderItem(object, geometry, material, z, group) {
    var array, index;
    // allocate the next position in the appropriate array
    if (material.transparent) {
      array = transparentObjects;
      index = ++transparentObjectsLastIndex;
    } else {
      array = opaqueObjects;
      index = ++opaqueObjectsLastIndex;
    }
    // recycle existing render item or grow the array
    var renderItem = array[index];
    if (renderItem !== undefined) {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.z = _vector3.z;
      renderItem.group = group;
    } else {
      renderItem = {
        id: object.id,
        object: object,
        geometry: geometry,
        material: material,
        z: _vector3.z,
        group: group
      };
      // assert( index === array.length );
      array.push(renderItem);
    }
  }
  function projectObject(object, camera) {
    if (object.visible === false)
      return;
    if (object.layers.test(camera.layers)) {
      if (object instanceof THREE.Light) {
        lights.push(object);
      } else if (object instanceof THREE.Sprite) {
        if (object.frustumCulled === false || _frustum.intersectsObject(object) === true) {
          sprites.push(object);
        }
      } else if (object instanceof THREE.LensFlare) {
        lensFlares.push(object);
      } else if (object instanceof THREE.ImmediateRenderObject) {
        if (_this.sortObjects === true) {
          _vector3.setFromMatrixPosition(object.matrixWorld);
          _vector3.applyProjection(_projScreenMatrix);
        }
        pushRenderItem(object, null, object.material, _vector3.z, null);
      } else if (object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points) {
        if (object instanceof THREE.SkinnedMesh) {
          object.skeleton.update();
        }
        if (object.frustumCulled === false || _frustum.intersectsObject(object) === true) {
          var material = object.material;
          if (material.visible === true) {
            if (_this.sortObjects === true) {
              _vector3.setFromMatrixPosition(object.matrixWorld);
              _vector3.applyProjection(_projScreenMatrix);
            }
            var geometry = objects.update(object);
            if (material instanceof THREE.MultiMaterial) {
              var groups = geometry.groups;
              var materials = material.materials;
              for (var i = 0, l = groups.length; i < l; i++) {
                var group = groups[i];
                var groupMaterial = materials[group.materialIndex];
                if (groupMaterial.visible === true) {
                  pushRenderItem(object, geometry, groupMaterial, _vector3.z, group);
                }
              }
            } else {
              pushRenderItem(object, geometry, material, _vector3.z, null);
            }
          }
        }
      }
    }
    var children = object.children;
    for (var i = 0, l = children.length; i < l; i++) {
      projectObject(children[i], camera);
    }
  }
  function renderObjects(renderList, camera, fog, overrideMaterial) {
    for (var i = 0, l = renderList.length; i < l; i++) {
      var renderItem = renderList[i];
      var object = renderItem.object;
      var geometry = renderItem.geometry;
      var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
      var group = renderItem.group;
      object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
      object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
      if (object instanceof THREE.ImmediateRenderObject) {
        setMaterial(material);
        var program = setProgram(camera, fog, material, object);
        _currentGeometryProgram = '';
        object.render(function (object) {
          _this.renderBufferImmediate(object, program, material);
        });
      } else {
        _this.renderBufferDirect(camera, fog, geometry, material, object, group);
      }
    }
  }
  function initMaterial(material, fog, object) {
    var materialProperties = properties.get(material);
    var parameters = programCache.getParameters(material, _lights, fog, object);
    var code = programCache.getProgramCode(material, parameters);
    var program = materialProperties.program;
    var programChange = true;
    if (program === undefined) {
      // new material
      material.addEventListener('dispose', onMaterialDispose);
    } else if (program.code !== code) {
      // changed glsl or parameters
      releaseMaterialProgramReference(material);
    } else if (parameters.shaderID !== undefined) {
      // same glsl and uniform list
      return;
    } else {
      // only rebuild uniform list
      programChange = false;
    }
    if (programChange) {
      if (parameters.shaderID) {
        var shader = THREE.ShaderLib[parameters.shaderID];
        materialProperties.__webglShader = {
          name: material.type,
          uniforms: THREE.UniformsUtils.clone(shader.uniforms),
          vertexShader: shader.vertexShader,
          fragmentShader: shader.fragmentShader
        };
      } else {
        materialProperties.__webglShader = {
          name: material.type,
          uniforms: material.uniforms,
          vertexShader: material.vertexShader,
          fragmentShader: material.fragmentShader
        };
      }
      material.__webglShader = materialProperties.__webglShader;
      program = programCache.acquireProgram(material, parameters, code);
      materialProperties.program = program;
      material.program = program;
    }
    var attributes = program.getAttributes();
    if (material.morphTargets) {
      material.numSupportedMorphTargets = 0;
      for (var i = 0; i < _this.maxMorphTargets; i++) {
        if (attributes['morphTarget' + i] >= 0) {
          material.numSupportedMorphTargets++;
        }
      }
    }
    if (material.morphNormals) {
      material.numSupportedMorphNormals = 0;
      for (var i = 0; i < _this.maxMorphNormals; i++) {
        if (attributes['morphNormal' + i] >= 0) {
          material.numSupportedMorphNormals++;
        }
      }
    }
    materialProperties.uniformsList = [];
    var uniforms = materialProperties.__webglShader.uniforms, uniformLocations = materialProperties.program.getUniforms();
    for (var u in uniforms) {
      var location = uniformLocations[u];
      if (location) {
        materialProperties.uniformsList.push([
          materialProperties.__webglShader.uniforms[u],
          location
        ]);
      }
    }
    if (material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshStandardMaterial || material.lights) {
      // store the light setup it was created for
      materialProperties.lightsHash = _lights.hash;
      // wire up the material to this renderer's lighting state
      uniforms.ambientLightColor.value = _lights.ambient;
      uniforms.directionalLights.value = _lights.directional;
      uniforms.spotLights.value = _lights.spot;
      uniforms.pointLights.value = _lights.point;
      uniforms.hemisphereLights.value = _lights.hemi;
      uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
      uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
      uniforms.spotShadowMap.value = _lights.spotShadowMap;
      uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
      uniforms.pointShadowMap.value = _lights.pointShadowMap;
      uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;
    }
    // detect dynamic uniforms
    materialProperties.hasDynamicUniforms = false;
    for (var j = 0, jl = materialProperties.uniformsList.length; j < jl; j++) {
      var uniform = materialProperties.uniformsList[j][0];
      if (uniform.dynamic === true) {
        materialProperties.hasDynamicUniforms = true;
        break;
      }
    }
  }
  function setMaterial(material) {
    setMaterialFaces(material);
    if (material.transparent === true) {
      state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    } else {
      state.setBlending(THREE.NoBlending);
    }
    state.setDepthFunc(material.depthFunc);
    state.setDepthTest(material.depthTest);
    state.setDepthWrite(material.depthWrite);
    state.setColorWrite(material.colorWrite);
    state.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
  }
  function setMaterialFaces(material) {
    material.side !== THREE.DoubleSide ? state.enable(_gl.CULL_FACE) : state.disable(_gl.CULL_FACE);
    state.setFlipSided(material.side === THREE.BackSide);
  }
  function setProgram(camera, fog, material, object) {
    _usedTextureUnits = 0;
    var materialProperties = properties.get(material);
    if (materialProperties.program === undefined) {
      material.needsUpdate = true;
    }
    if (materialProperties.lightsHash !== undefined && materialProperties.lightsHash !== _lights.hash) {
      material.needsUpdate = true;
    }
    if (material.needsUpdate) {
      initMaterial(material, fog, object);
      material.needsUpdate = false;
    }
    var refreshProgram = false;
    var refreshMaterial = false;
    var refreshLights = false;
    var program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.__webglShader.uniforms;
    if (program.id !== _currentProgram) {
      _gl.useProgram(program.program);
      _currentProgram = program.id;
      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;
    }
    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }
    if (refreshProgram || camera !== _currentCamera) {
      _gl.uniformMatrix4fv(p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
      if (capabilities.logarithmicDepthBuffer) {
        _gl.uniform1f(p_uniforms.logDepthBufFC, 2 / (Math.log(camera.far + 1) / Math.LN2));
      }
      if (camera !== _currentCamera) {
        _currentCamera = camera;
        // lighting uniforms depend on the camera so enforce an update
        // now, in case this material supports lights - or later, when
        // the next material that does gets activated:
        refreshMaterial = true;
        // set to true on material change
        refreshLights = true;  // remains set until update done
      }
      // load material specific uniforms
      // (shader material also gets them for the sake of genericity)
      if (material instanceof THREE.ShaderMaterial || material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshStandardMaterial || material.envMap) {
        if (p_uniforms.cameraPosition !== undefined) {
          _vector3.setFromMatrixPosition(camera.matrixWorld);
          _gl.uniform3f(p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z);
        }
      }
      if (material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshStandardMaterial || material instanceof THREE.ShaderMaterial || material.skinning) {
        if (p_uniforms.viewMatrix !== undefined) {
          _gl.uniformMatrix4fv(p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements);
        }
      }
      if (p_uniforms.toneMappingExposure !== undefined) {
        _gl.uniform1f(p_uniforms.toneMappingExposure, _this.toneMappingExposure);
      }
      if (p_uniforms.toneMappingWhitePoint !== undefined) {
        _gl.uniform1f(p_uniforms.toneMappingWhitePoint, _this.toneMappingWhitePoint);
      }
    }
    // skinning uniforms must be set even if material didn't change
    // auto-setting of texture unit for bone texture must go before other textures
    // not sure why, but otherwise weird things happen
    if (material.skinning) {
      if (object.bindMatrix && p_uniforms.bindMatrix !== undefined) {
        _gl.uniformMatrix4fv(p_uniforms.bindMatrix, false, object.bindMatrix.elements);
      }
      if (object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== undefined) {
        _gl.uniformMatrix4fv(p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements);
      }
      if (capabilities.floatVertexTextures && object.skeleton && object.skeleton.useVertexTexture) {
        if (p_uniforms.boneTexture !== undefined) {
          var textureUnit = getTextureUnit();
          _gl.uniform1i(p_uniforms.boneTexture, textureUnit);
          _this.setTexture(object.skeleton.boneTexture, textureUnit);
        }
        if (p_uniforms.boneTextureWidth !== undefined) {
          _gl.uniform1i(p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth);
        }
        if (p_uniforms.boneTextureHeight !== undefined) {
          _gl.uniform1i(p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight);
        }
      } else if (object.skeleton && object.skeleton.boneMatrices) {
        if (p_uniforms.boneGlobalMatrices !== undefined) {
          _gl.uniformMatrix4fv(p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices);
        }
      }
    }
    if (refreshMaterial) {
      if (material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshStandardMaterial || material.lights) {
        // the current material requires lighting info
        // note: all lighting uniforms are always set correctly
        // they simply reference the renderer's state for their
        // values
        //
        // use the current material's .needsUpdate flags to set
        // the GL state when required
        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
      }
      // refresh uniforms common to several materials
      if (fog && material.fog) {
        refreshUniformsFog(m_uniforms, fog);
      }
      if (material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshStandardMaterial) {
        refreshUniformsCommon(m_uniforms, material);
      }
      // refresh single material specific uniforms
      if (material instanceof THREE.LineBasicMaterial) {
        refreshUniformsLine(m_uniforms, material);
      } else if (material instanceof THREE.LineDashedMaterial) {
        refreshUniformsLine(m_uniforms, material);
        refreshUniformsDash(m_uniforms, material);
      } else if (material instanceof THREE.PointsMaterial) {
        refreshUniformsPoints(m_uniforms, material);
      } else if (material instanceof THREE.MeshLambertMaterial) {
        refreshUniformsLambert(m_uniforms, material);
      } else if (material instanceof THREE.MeshPhongMaterial) {
        refreshUniformsPhong(m_uniforms, material);
      } else if (material instanceof THREE.MeshStandardMaterial) {
        refreshUniformsStandard(m_uniforms, material);
      } else if (material instanceof THREE.MeshDepthMaterial) {
        m_uniforms.mNear.value = camera.near;
        m_uniforms.mFar.value = camera.far;
        m_uniforms.opacity.value = material.opacity;
      } else if (material instanceof THREE.MeshNormalMaterial) {
        m_uniforms.opacity.value = material.opacity;
      }
      // load common uniforms
      loadUniformsGeneric(materialProperties.uniformsList);
    }
    loadUniformsMatrices(p_uniforms, object);
    if (p_uniforms.modelMatrix !== undefined) {
      _gl.uniformMatrix4fv(p_uniforms.modelMatrix, false, object.matrixWorld.elements);
    }
    if (materialProperties.hasDynamicUniforms === true) {
      updateDynamicUniforms(materialProperties.uniformsList, object, camera);
    }
    return program;
  }
  function updateDynamicUniforms(uniforms, object, camera) {
    var dynamicUniforms = [];
    for (var j = 0, jl = uniforms.length; j < jl; j++) {
      var uniform = uniforms[j][0];
      var onUpdateCallback = uniform.onUpdateCallback;
      if (onUpdateCallback !== undefined) {
        onUpdateCallback.bind(uniform)(object, camera);
        dynamicUniforms.push(uniforms[j]);
      }
    }
    loadUniformsGeneric(dynamicUniforms);
  }
  // Uniforms (refresh uniforms objects)
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    uniforms.diffuse.value = material.color;
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    uniforms.map.value = material.map;
    uniforms.specularMap.value = material.specularMap;
    uniforms.alphaMap.value = material.alphaMap;
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
    }
    // uv repeat and offset setting priorities
    // 1. color map
    // 2. specular map
    // 3. normal map
    // 4. bump map
    // 5. alpha map
    // 6. emissive map
    var uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.displacementMap) {
      uvScaleMap = material.displacementMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    } else if (material.roughnessMap) {
      uvScaleMap = material.roughnessMap;
    } else if (material.metalnessMap) {
      uvScaleMap = material.metalnessMap;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    } else if (material.emissiveMap) {
      uvScaleMap = material.emissiveMap;
    }
    if (uvScaleMap !== undefined) {
      if (uvScaleMap instanceof THREE.WebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture;
      }
      var offset = uvScaleMap.offset;
      var repeat = uvScaleMap.repeat;
      uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
    }
    uniforms.envMap.value = material.envMap;
    uniforms.flipEnvMap.value = material.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1;
    uniforms.reflectivity.value = material.reflectivity;
    uniforms.refractionRatio.value = material.refractionRatio;
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value = material.color;
    uniforms.opacity.value = material.opacity;
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material) {
    uniforms.diffuse.value = material.color;
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * _pixelRatio;
    uniforms.scale.value = _canvas.clientHeight / 2;
    // TODO: Cache this.
    uniforms.map.value = material.map;
    if (material.map !== null) {
      var offset = material.map.offset;
      var repeat = material.map.repeat;
      uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
    }
  }
  function refreshUniformsFog(uniforms, fog) {
    uniforms.fogColor.value = fog.color;
    if (fog instanceof THREE.Fog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog instanceof THREE.FogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshUniformsLambert(uniforms, material) {
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value = material.specular;
    uniforms.shininess.value = Math.max(material.shininess, 0.0001);
    // to prevent pow( 0.0, 0.0 )
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
    }
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    if (material.envMap) {
      //uniforms.envMap.value = material.envMap; // part of uniforms common
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  // If uniforms are marked as clean, they don't need to be loaded to the GPU.
  function markUniformsLightsNeedsUpdate(uniforms, value) {
    uniforms.ambientLightColor.needsUpdate = value;
    uniforms.directionalLights.needsUpdate = value;
    uniforms.pointLights.needsUpdate = value;
    uniforms.spotLights.needsUpdate = value;
    uniforms.hemisphereLights.needsUpdate = value;
  }
  // Uniforms (load to GPU)
  function loadUniformsMatrices(uniforms, object) {
    _gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, object.modelViewMatrix.elements);
    if (uniforms.invModelViewMatrix) {
      var invMat = new THREE.Matrix4().getInverse(object.modelViewMatrix);
      _gl.uniformMatrix4fv(uniforms.invModelViewMatrix, false, invMat.elements);
    }
    if (uniforms.normalMatrix) {
      _gl.uniformMatrix3fv(uniforms.normalMatrix, false, object.normalMatrix.elements);
    }
  }
  function getTextureUnit() {
    var textureUnit = _usedTextureUnits;
    if (textureUnit >= capabilities.maxTextures) {
      console.warn('WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures);
    }
    _usedTextureUnits += 1;
    return textureUnit;
  }
  function loadUniform(uniform, type, location, value) {
    var texture, textureUnit;
    if (type === '1i') {
      _gl.uniform1i(location, value);
    } else if (type === '1f') {
      _gl.uniform1f(location, value);
    } else if (type === '2f') {
      _gl.uniform2f(location, value[0], value[1]);
    } else if (type === '3f') {
      _gl.uniform3f(location, value[0], value[1], value[2]);
    } else if (type === '4f') {
      _gl.uniform4f(location, value[0], value[1], value[2], value[3]);
    } else if (type === '1iv') {
      _gl.uniform1iv(location, value);
    } else if (type === '3iv') {
      _gl.uniform3iv(location, value);
    } else if (type === '1fv') {
      _gl.uniform1fv(location, value);
    } else if (type === '2fv') {
      _gl.uniform2fv(location, value);
    } else if (type === '3fv') {
      _gl.uniform3fv(location, value);
    } else if (type === '4fv') {
      _gl.uniform4fv(location, value);
    } else if (type === 'Matrix2fv') {
      _gl.uniformMatrix2fv(location, false, value);
    } else if (type === 'Matrix3fv') {
      _gl.uniformMatrix3fv(location, false, value);
    } else if (type === 'Matrix4fv') {
      _gl.uniformMatrix4fv(location, false, value);  //
    } else if (type === 'i') {
      // single integer
      _gl.uniform1i(location, value);
    } else if (type === 'f') {
      // single float
      _gl.uniform1f(location, value);
    } else if (type === 'v2') {
      // single THREE.Vector2
      _gl.uniform2f(location, value.x, value.y);
    } else if (type === 'v3') {
      // single THREE.Vector3
      _gl.uniform3f(location, value.x, value.y, value.z);
    } else if (type === 'v4') {
      // single THREE.Vector4
      _gl.uniform4f(location, value.x, value.y, value.z, value.w);
    } else if (type === 'c') {
      // single THREE.Color
      _gl.uniform3f(location, value.r, value.g, value.b);
    } else if (type === 's') {
      // TODO: Optimize this
      var properties = uniform.properties;
      for (var name in properties) {
        var property = properties[name];
        var locationProperty = location[name];
        var valueProperty = value[name];
        loadUniform(property, property.type, locationProperty, valueProperty);
      }
    } else if (type === 'sa') {
      // TODO: Optimize this
      var properties = uniform.properties;
      for (var i = 0, l = value.length; i < l; i++) {
        for (var name in properties) {
          var property = properties[name];
          var locationProperty = location[i][name];
          var valueProperty = value[i][name];
          loadUniform(property, property.type, locationProperty, valueProperty);
        }
      }
    } else if (type === 'iv1') {
      // flat array of integers (JS or typed array)
      _gl.uniform1iv(location, value);
    } else if (type === 'iv') {
      // flat array of integers with 3 x N size (JS or typed array)
      _gl.uniform3iv(location, value);
    } else if (type === 'fv1') {
      // flat array of floats (JS or typed array)
      _gl.uniform1fv(location, value);
    } else if (type === 'fv') {
      // flat array of floats with 3 x N size (JS or typed array)
      _gl.uniform3fv(location, value);
    } else if (type === 'v2v') {
      // array of THREE.Vector2
      if (uniform._array === undefined) {
        uniform._array = new Float32Array(2 * value.length);
      }
      for (var i = 0, i2 = 0, il = value.length; i < il; i++, i2 += 2) {
        uniform._array[i2 + 0] = value[i].x;
        uniform._array[i2 + 1] = value[i].y;
      }
      _gl.uniform2fv(location, uniform._array);
    } else if (type === 'v3v') {
      // array of THREE.Vector3
      if (uniform._array === undefined) {
        uniform._array = new Float32Array(3 * value.length);
      }
      for (var i = 0, i3 = 0, il = value.length; i < il; i++, i3 += 3) {
        uniform._array[i3 + 0] = value[i].x;
        uniform._array[i3 + 1] = value[i].y;
        uniform._array[i3 + 2] = value[i].z;
      }
      _gl.uniform3fv(location, uniform._array);
    } else if (type === 'v4v') {
      // array of THREE.Vector4
      if (uniform._array === undefined) {
        uniform._array = new Float32Array(4 * value.length);
      }
      for (var i = 0, i4 = 0, il = value.length; i < il; i++, i4 += 4) {
        uniform._array[i4 + 0] = value[i].x;
        uniform._array[i4 + 1] = value[i].y;
        uniform._array[i4 + 2] = value[i].z;
        uniform._array[i4 + 3] = value[i].w;
      }
      _gl.uniform4fv(location, uniform._array);
    } else if (type === 'm2') {
      // single THREE.Matrix2
      _gl.uniformMatrix2fv(location, false, value.elements);
    } else if (type === 'm3') {
      // single THREE.Matrix3
      _gl.uniformMatrix3fv(location, false, value.elements);
    } else if (type === 'm3v') {
      // array of THREE.Matrix3
      if (uniform._array === undefined) {
        uniform._array = new Float32Array(9 * value.length);
      }
      for (var i = 0, il = value.length; i < il; i++) {
        value[i].flattenToArrayOffset(uniform._array, i * 9);
      }
      _gl.uniformMatrix3fv(location, false, uniform._array);
    } else if (type === 'm4') {
      // single THREE.Matrix4
      _gl.uniformMatrix4fv(location, false, value.elements);
    } else if (type === 'm4v') {
      // array of THREE.Matrix4
      if (uniform._array === undefined) {
        uniform._array = new Float32Array(16 * value.length);
      }
      for (var i = 0, il = value.length; i < il; i++) {
        value[i].flattenToArrayOffset(uniform._array, i * 16);
      }
      _gl.uniformMatrix4fv(location, false, uniform._array);
    } else if (type === 't') {
      // single THREE.Texture (2d or cube)
      texture = value;
      textureUnit = getTextureUnit();
      _gl.uniform1i(location, textureUnit);
      if (!texture)
        return;
      if (texture instanceof THREE.CubeTexture || Array.isArray(texture.image) && texture.image.length === 6) {
        // CompressedTexture can have Array in image :/
        setCubeTexture(texture, textureUnit);
      } else if (texture instanceof THREE.WebGLRenderTargetCube) {
        setCubeTextureDynamic(texture.texture, textureUnit);
      } else if (texture instanceof THREE.WebGLRenderTarget) {
        _this.setTexture(texture.texture, textureUnit);
      } else {
        _this.setTexture(texture, textureUnit);
      }
    } else if (type === 'tv') {
      // array of THREE.Texture (2d or cube)
      if (uniform._array === undefined) {
        uniform._array = [];
      }
      for (var i = 0, il = uniform.value.length; i < il; i++) {
        uniform._array[i] = getTextureUnit();
      }
      _gl.uniform1iv(location, uniform._array);
      for (var i = 0, il = uniform.value.length; i < il; i++) {
        texture = uniform.value[i];
        textureUnit = uniform._array[i];
        if (!texture)
          continue;
        if (texture instanceof THREE.CubeTexture || texture.image instanceof Array && texture.image.length === 6) {
          // CompressedTexture can have Array in image :/
          setCubeTexture(texture, textureUnit);
        } else if (texture instanceof THREE.WebGLRenderTarget) {
          _this.setTexture(texture.texture, textureUnit);
        } else if (texture instanceof THREE.WebGLRenderTargetCube) {
          setCubeTextureDynamic(texture.texture, textureUnit);
        } else {
          _this.setTexture(texture, textureUnit);
        }
      }
    } else {
      console.warn('THREE.WebGLRenderer: Unknown uniform type: ' + type);
    }
  }
  function loadUniformsGeneric(uniforms) {
    for (var i = 0, l = uniforms.length; i < l; i++) {
      var uniform = uniforms[i][0];
      // needsUpdate property is not added to all uniforms.
      if (uniform.needsUpdate === false)
        continue;
      var type = uniform.type;
      var location = uniforms[i][1];
      var value = uniform.value;
      loadUniform(uniform, type, location, value);
    }
  }
  function setupLights(lights, camera) {
    var l, ll, light, r = 0, g = 0, b = 0, color, intensity, distance, viewMatrix = camera.matrixWorldInverse, directionalLength = 0, pointLength = 0, spotLength = 0, hemiLength = 0, shadowsLength = 0;
    _lights.shadowsPointLight = 0;
    for (l = 0, ll = lights.length; l < ll; l++) {
      light = lights[l];
      color = light.color;
      intensity = light.intensity;
      distance = light.distance;
      if (light instanceof THREE.AmbientLight) {
        r += color.r * intensity;
        g += color.g * intensity;
        b += color.b * intensity;
      } else if (light instanceof THREE.DirectionalLight) {
        var uniforms = lightCache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        _vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(_vector3);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.shadow = light.castShadow;
        if (light.castShadow) {
          uniforms.shadowBias = light.shadow.bias;
          uniforms.shadowRadius = light.shadow.radius;
          uniforms.shadowMapSize = light.shadow.mapSize;
          _lights.shadows[shadowsLength++] = light;
        }
        _lights.directionalShadowMap[directionalLength] = light.shadow.map;
        _lights.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
        _lights.directional[directionalLength++] = uniforms;
      } else if (light instanceof THREE.SpotLight) {
        var uniforms = lightCache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.distance = distance;
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        _vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(_vector3);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.distance === 0 ? 0 : light.decay;
        uniforms.shadow = light.castShadow;
        if (light.castShadow) {
          uniforms.shadowBias = light.shadow.bias;
          uniforms.shadowRadius = light.shadow.radius;
          uniforms.shadowMapSize = light.shadow.mapSize;
          _lights.shadows[shadowsLength++] = light;
        }
        _lights.spotShadowMap[spotLength] = light.shadow.map;
        _lights.spotShadowMatrix[spotLength] = light.shadow.matrix;
        _lights.spot[spotLength++] = uniforms;
      } else if (light instanceof THREE.PointLight) {
        var uniforms = lightCache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.distance = light.distance;
        uniforms.decay = light.distance === 0 ? 0 : light.decay;
        uniforms.shadow = light.castShadow;
        if (light.castShadow) {
          uniforms.shadowBias = light.shadow.bias;
          uniforms.shadowRadius = light.shadow.radius;
          uniforms.shadowMapSize = light.shadow.mapSize;
          _lights.shadows[shadowsLength++] = light;
        }
        _lights.pointShadowMap[pointLength] = light.shadow.map;
        if (_lights.pointShadowMatrix[pointLength] === undefined) {
          _lights.pointShadowMatrix[pointLength] = new THREE.Matrix4();
        }
        // for point lights we set the shadow matrix to be a translation-only matrix
        // equal to inverse of the light's position
        _vector3.setFromMatrixPosition(light.matrixWorld).negate();
        _lights.pointShadowMatrix[pointLength].identity().setPosition(_vector3);
        _lights.point[pointLength++] = uniforms;
      } else if (light instanceof THREE.HemisphereLight) {
        var uniforms = lightCache.get(light);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.direction.normalize();
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
        _lights.hemi[hemiLength++] = uniforms;
      }
    }
    _lights.ambient[0] = r;
    _lights.ambient[1] = g;
    _lights.ambient[2] = b;
    _lights.directional.length = directionalLength;
    _lights.spot.length = spotLength;
    _lights.point.length = pointLength;
    _lights.hemi.length = hemiLength;
    _lights.shadows.length = shadowsLength;
    _lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + shadowsLength;
  }
  // GL state setting
  this.setFaceCulling = function (cullFace, frontFaceDirection) {
    if (cullFace === THREE.CullFaceNone) {
      state.disable(_gl.CULL_FACE);
    } else {
      if (frontFaceDirection === THREE.FrontFaceDirectionCW) {
        _gl.frontFace(_gl.CW);
      } else {
        _gl.frontFace(_gl.CCW);
      }
      if (cullFace === THREE.CullFaceBack) {
        _gl.cullFace(_gl.BACK);
      } else if (cullFace === THREE.CullFaceFront) {
        _gl.cullFace(_gl.FRONT);
      } else {
        _gl.cullFace(_gl.FRONT_AND_BACK);
      }
      state.enable(_gl.CULL_FACE);
    }
  };
  // Textures
  function setTextureParameters(textureType, texture, isPowerOfTwoImage) {
    var extension;
    if (isPowerOfTwoImage) {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL(texture.wrapS));
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL(texture.wrapT));
      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL(texture.magFilter));
      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL(texture.minFilter));
    } else {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
      if (texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping) {
        console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture);
      }
      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
      if (texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter) {
        console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture);
      }
    }
    extension = extensions.get('EXT_texture_filter_anisotropic');
    if (extension) {
      if (texture.type === THREE.FloatType && extensions.get('OES_texture_float_linear') === null)
        return;
      if (texture.type === THREE.HalfFloatType && extensions.get('OES_texture_half_float_linear') === null)
        return;
      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, _this.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function uploadTexture(textureProperties, texture, slot) {
    if (textureProperties.__webglInit === undefined) {
      textureProperties.__webglInit = true;
      texture.addEventListener('dispose', onTextureDispose);
      textureProperties.__webglTexture = _gl.createTexture();
      _infoMemory.textures++;
    }
    state.activeTexture(_gl.TEXTURE0 + slot);
    state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
    _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
    _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
    var image = clampToMaxSize(texture.image, capabilities.maxTextureSize);
    if (textureNeedsPowerOfTwo(texture) && isPowerOfTwo(image) === false) {
      image = makePowerOfTwo(image);
    }
    var isPowerOfTwoImage = isPowerOfTwo(image), glFormat = paramThreeToGL(texture.format), glType = paramThreeToGL(texture.type);
    setTextureParameters(_gl.TEXTURE_2D, texture, isPowerOfTwoImage);
    var mipmap, mipmaps = texture.mipmaps;
    if (texture instanceof THREE.DataTexture) {
      // use manually created mipmaps if available
      // if there are no manual mipmaps
      // set 0 level mipmap and then use GL to generate other mipmap levels
      if (mipmaps.length > 0 && isPowerOfTwoImage) {
        for (var i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
        texture.generateMipmaps = false;
      } else {
        state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data);
      }
    } else if (texture instanceof THREE.CompressedTexture) {
      for (var i = 0, il = mipmaps.length; i < il; i++) {
        mipmap = mipmaps[i];
        if (texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat) {
          if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
            state.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
          } else {
            console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
          }
        } else {
          state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
      }
    } else {
      // regular Texture (image, video, canvas)
      // use manually created mipmaps if available
      // if there are no manual mipmaps
      // set 0 level mipmap and then use GL to generate other mipmap levels
      if (mipmaps.length > 0 && isPowerOfTwoImage) {
        for (var i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          state.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);
        }
        texture.generateMipmaps = false;
      } else {
        state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image);
      }
    }
    if (texture.generateMipmaps && isPowerOfTwoImage)
      _gl.generateMipmap(_gl.TEXTURE_2D);
    textureProperties.__version = texture.version;
    if (texture.onUpdate)
      texture.onUpdate(texture);
  }
  this.setTexture = function (texture, slot) {
    var textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      var image = texture.image;
      if (image === undefined) {
        console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined', texture);
        return;
      }
      if (image.complete === false) {
        console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture);
        return;
      }
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(_gl.TEXTURE0 + slot);
    state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
  };
  function clampToMaxSize(image, maxSize) {
    if (image.width > maxSize || image.height > maxSize) {
      // Warning: Scaling through the canvas will only work with images that use
      // premultiplied alpha.
      var scale = maxSize / Math.max(image.width, image.height);
      var canvas = document.createElement('canvas');
      canvas.width = Math.floor(image.width * scale);
      canvas.height = Math.floor(image.height * scale);
      var context = canvas.getContext('2d');
      context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
      console.warn('THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image);
      return canvas;
    }
    return image;
  }
  function isPowerOfTwo(image) {
    return THREE.Math.isPowerOfTwo(image.width) && THREE.Math.isPowerOfTwo(image.height);
  }
  function textureNeedsPowerOfTwo(texture) {
    if (texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping)
      return true;
    if (texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter)
      return true;
    return false;
  }
  function makePowerOfTwo(image) {
    if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement) {
      var canvas = document.createElement('canvas');
      canvas.width = THREE.Math.nearestPowerOfTwo(image.width);
      canvas.height = THREE.Math.nearestPowerOfTwo(image.height);
      var context = canvas.getContext('2d');
      context.drawImage(image, 0, 0, canvas.width, canvas.height);
      console.warn('THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image);
      return canvas;
    }
    return image;
  }
  function setCubeTexture(texture, slot) {
    var textureProperties = properties.get(texture);
    if (texture.image.length === 6) {
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        if (!textureProperties.__image__webglTextureCube) {
          texture.addEventListener('dispose', onTextureDispose);
          textureProperties.__image__webglTextureCube = _gl.createTexture();
          _infoMemory.textures++;
        }
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
        var isCompressed = texture instanceof THREE.CompressedTexture;
        var isDataTexture = texture.image[0] instanceof THREE.DataTexture;
        var cubeImage = [];
        for (var i = 0; i < 6; i++) {
          if (_this.autoScaleCubemaps && !isCompressed && !isDataTexture) {
            cubeImage[i] = clampToMaxSize(texture.image[i], capabilities.maxCubemapSize);
          } else {
            cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
          }
        }
        var image = cubeImage[0], isPowerOfTwoImage = isPowerOfTwo(image), glFormat = paramThreeToGL(texture.format), glType = paramThreeToGL(texture.type);
        setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage);
        for (var i = 0; i < 6; i++) {
          if (!isCompressed) {
            if (isDataTexture) {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
            } else {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);
            }
          } else {
            var mipmap, mipmaps = cubeImage[i].mipmaps;
            for (var j = 0, jl = mipmaps.length; j < jl; j++) {
              mipmap = mipmaps[j];
              if (texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat) {
                if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                  state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                } else {
                  console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()');
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
        if (texture.generateMipmaps && isPowerOfTwoImage) {
          _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
        }
        textureProperties.__version = texture.version;
        if (texture.onUpdate)
          texture.onUpdate(texture);
      } else {
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
      }
    }
  }
  function setCubeTextureDynamic(texture, slot) {
    state.activeTexture(_gl.TEXTURE0 + slot);
    state.bindTexture(_gl.TEXTURE_CUBE_MAP, properties.get(texture).__webglTexture);
  }
  // Render targets
  // Setup storage for target texture and bind it to correct framebuffer
  function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
    var glFormat = paramThreeToGL(renderTarget.texture.format);
    var glType = paramThreeToGL(renderTarget.texture.type);
    state.texImage2D(textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
    _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
    _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
  function setupRenderBufferStorage(renderbuffer, renderTarget) {
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
    } else {
      // FIXME: We don't support !depth !stencil
      _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height);
    }
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
  }
  // Setup GL resources for a non-texture depth buffer
  function setupDepthRenderbuffer(renderTarget) {
    var renderTargetProperties = properties.get(renderTarget);
    var isCube = renderTarget instanceof THREE.WebGLRenderTargetCube;
    if (isCube) {
      renderTargetProperties.__webglDepthbuffer = [];
      for (var i = 0; i < 6; i++) {
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
        renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);
      }
    } else {
      _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
      renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
      setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
    }
    _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  // Set up GL resources for the render target
  function setupRenderTarget(renderTarget) {
    var renderTargetProperties = properties.get(renderTarget);
    var textureProperties = properties.get(renderTarget.texture);
    renderTarget.addEventListener('dispose', onRenderTargetDispose);
    textureProperties.__webglTexture = _gl.createTexture();
    _infoMemory.textures++;
    var isCube = renderTarget instanceof THREE.WebGLRenderTargetCube;
    var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo(renderTarget.width) && THREE.Math.isPowerOfTwo(renderTarget.height);
    // Setup framebuffer
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (var i = 0; i < 6; i++) {
        renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
    }
    // Setup color buffer
    if (isCube) {
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo);
      for (var i = 0; i < 6; i++) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
      }
      if (renderTarget.texture.generateMipmaps && isTargetPowerOfTwo)
        _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
    } else {
      state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
      setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo);
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);
      if (renderTarget.texture.generateMipmaps && isTargetPowerOfTwo)
        _gl.generateMipmap(_gl.TEXTURE_2D);
      state.bindTexture(_gl.TEXTURE_2D, null);
    }
    // Setup depth and stencil buffers
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  this.getCurrentRenderTarget = function () {
    return _currentRenderTarget;
  };
  this.setRenderTarget = function (renderTarget) {
    _currentRenderTarget = renderTarget;
    if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
      setupRenderTarget(renderTarget);
    }
    var isCube = renderTarget instanceof THREE.WebGLRenderTargetCube;
    var framebuffer;
    if (renderTarget) {
      var renderTargetProperties = properties.get(renderTarget);
      if (isCube) {
        framebuffer = renderTargetProperties.__webglFramebuffer[renderTarget.activeCubeFace];
      } else {
        framebuffer = renderTargetProperties.__webglFramebuffer;
      }
      _currentScissor.copy(renderTarget.scissor);
      _currentScissorTest = renderTarget.scissorTest;
      _currentViewport.copy(renderTarget.viewport);
    } else {
      framebuffer = null;
      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio);
      _currentScissorTest = _scissorTest;
      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);
    }
    if (_currentFramebuffer !== framebuffer) {
      _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
      _currentFramebuffer = framebuffer;
    }
    state.scissor(_currentScissor);
    state.setScissorTest(_currentScissorTest);
    state.viewport(_currentViewport);
    if (isCube) {
      var textureProperties = properties.get(renderTarget.texture);
      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel);
    }
  };
  this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer) {
    if (renderTarget instanceof THREE.WebGLRenderTarget === false) {
      console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
      return;
    }
    var framebuffer = properties.get(renderTarget).__webglFramebuffer;
    if (framebuffer) {
      var restore = false;
      if (framebuffer !== _currentFramebuffer) {
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        restore = true;
      }
      try {
        var texture = renderTarget.texture;
        if (texture.format !== THREE.RGBAFormat && paramThreeToGL(texture.format) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
          return;
        }
        if (texture.type !== THREE.UnsignedByteType && paramThreeToGL(texture.type) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && !(texture.type === THREE.FloatType && extensions.get('WEBGL_color_buffer_float')) && !(texture.type === THREE.HalfFloatType && extensions.get('EXT_color_buffer_half_float'))) {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
          return;
        }
        if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
          _gl.readPixels(x, y, width, height, paramThreeToGL(texture.format), paramThreeToGL(texture.type), buffer);
        } else {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
        }
      } finally {
        if (restore) {
          _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);
        }
      }
    }
  };
  function updateRenderTargetMipmap(renderTarget) {
    var target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
    var texture = properties.get(renderTarget.texture).__webglTexture;
    state.bindTexture(target, texture);
    _gl.generateMipmap(target);
    state.bindTexture(target, null);
  }
  // Fallback filters for non-power-of-2 textures
  function filterFallback(f) {
    if (f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter) {
      return _gl.NEAREST;
    }
    return _gl.LINEAR;
  }
  // Map three.js constants to WebGL constants
  function paramThreeToGL(p) {
    var extension;
    if (p === THREE.RepeatWrapping)
      return _gl.REPEAT;
    if (p === THREE.ClampToEdgeWrapping)
      return _gl.CLAMP_TO_EDGE;
    if (p === THREE.MirroredRepeatWrapping)
      return _gl.MIRRORED_REPEAT;
    if (p === THREE.NearestFilter)
      return _gl.NEAREST;
    if (p === THREE.NearestMipMapNearestFilter)
      return _gl.NEAREST_MIPMAP_NEAREST;
    if (p === THREE.NearestMipMapLinearFilter)
      return _gl.NEAREST_MIPMAP_LINEAR;
    if (p === THREE.LinearFilter)
      return _gl.LINEAR;
    if (p === THREE.LinearMipMapNearestFilter)
      return _gl.LINEAR_MIPMAP_NEAREST;
    if (p === THREE.LinearMipMapLinearFilter)
      return _gl.LINEAR_MIPMAP_LINEAR;
    if (p === THREE.UnsignedByteType)
      return _gl.UNSIGNED_BYTE;
    if (p === THREE.UnsignedShort4444Type)
      return _gl.UNSIGNED_SHORT_4_4_4_4;
    if (p === THREE.UnsignedShort5551Type)
      return _gl.UNSIGNED_SHORT_5_5_5_1;
    if (p === THREE.UnsignedShort565Type)
      return _gl.UNSIGNED_SHORT_5_6_5;
    if (p === THREE.ByteType)
      return _gl.BYTE;
    if (p === THREE.ShortType)
      return _gl.SHORT;
    if (p === THREE.UnsignedShortType)
      return _gl.UNSIGNED_SHORT;
    if (p === THREE.IntType)
      return _gl.INT;
    if (p === THREE.UnsignedIntType)
      return _gl.UNSIGNED_INT;
    if (p === THREE.FloatType)
      return _gl.FLOAT;
    extension = extensions.get('OES_texture_half_float');
    if (extension !== null) {
      if (p === THREE.HalfFloatType)
        return extension.HALF_FLOAT_OES;
    }
    if (p === THREE.AlphaFormat)
      return _gl.ALPHA;
    if (p === THREE.RGBFormat)
      return _gl.RGB;
    if (p === THREE.RGBAFormat)
      return _gl.RGBA;
    if (p === THREE.LuminanceFormat)
      return _gl.LUMINANCE;
    if (p === THREE.LuminanceAlphaFormat)
      return _gl.LUMINANCE_ALPHA;
    if (p === THREE.AddEquation)
      return _gl.FUNC_ADD;
    if (p === THREE.SubtractEquation)
      return _gl.FUNC_SUBTRACT;
    if (p === THREE.ReverseSubtractEquation)
      return _gl.FUNC_REVERSE_SUBTRACT;
    if (p === THREE.ZeroFactor)
      return _gl.ZERO;
    if (p === THREE.OneFactor)
      return _gl.ONE;
    if (p === THREE.SrcColorFactor)
      return _gl.SRC_COLOR;
    if (p === THREE.OneMinusSrcColorFactor)
      return _gl.ONE_MINUS_SRC_COLOR;
    if (p === THREE.SrcAlphaFactor)
      return _gl.SRC_ALPHA;
    if (p === THREE.OneMinusSrcAlphaFactor)
      return _gl.ONE_MINUS_SRC_ALPHA;
    if (p === THREE.DstAlphaFactor)
      return _gl.DST_ALPHA;
    if (p === THREE.OneMinusDstAlphaFactor)
      return _gl.ONE_MINUS_DST_ALPHA;
    if (p === THREE.DstColorFactor)
      return _gl.DST_COLOR;
    if (p === THREE.OneMinusDstColorFactor)
      return _gl.ONE_MINUS_DST_COLOR;
    if (p === THREE.SrcAlphaSaturateFactor)
      return _gl.SRC_ALPHA_SATURATE;
    extension = extensions.get('WEBGL_compressed_texture_s3tc');
    if (extension !== null) {
      if (p === THREE.RGB_S3TC_DXT1_Format)
        return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
      if (p === THREE.RGBA_S3TC_DXT1_Format)
        return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
      if (p === THREE.RGBA_S3TC_DXT3_Format)
        return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
      if (p === THREE.RGBA_S3TC_DXT5_Format)
        return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
    }
    extension = extensions.get('WEBGL_compressed_texture_pvrtc');
    if (extension !== null) {
      if (p === THREE.RGB_PVRTC_4BPPV1_Format)
        return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
      if (p === THREE.RGB_PVRTC_2BPPV1_Format)
        return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
      if (p === THREE.RGBA_PVRTC_4BPPV1_Format)
        return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
      if (p === THREE.RGBA_PVRTC_2BPPV1_Format)
        return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
    }
    extension = extensions.get('WEBGL_compressed_texture_etc1');
    if (extension !== null) {
      if (p === THREE.RGB_ETC1_Format)
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
    }
    extension = extensions.get('EXT_blend_minmax');
    if (extension !== null) {
      if (p === THREE.MinEquation)
        return extension.MIN_EXT;
      if (p === THREE.MaxEquation)
        return extension.MAX_EXT;
    }
    return 0;
  }
};
// File:src/renderers/WebGLRenderTarget.js
/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 * @author Marius Kintel / https://github.com/kintel
 */
/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/
THREE.WebGLRenderTarget = function (width, height, options) {
  this.uuid = THREE.Math.generateUUID();
  this.width = width;
  this.height = height;
  this.scissor = new THREE.Vector4(0, 0, width, height);
  this.scissorTest = false;
  this.viewport = new THREE.Vector4(0, 0, width, height);
  options = options || {};
  if (options.minFilter === undefined)
    options.minFilter = THREE.LinearFilter;
  this.texture = new THREE.Texture(undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy);
  this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
  this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
};
THREE.WebGLRenderTarget.prototype = {
  constructor: THREE.WebGLRenderTarget,
  setSize: function (width, height) {
    if (this.width !== width || this.height !== height) {
      this.width = width;
      this.height = height;
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.width = source.width;
    this.height = source.height;
    this.viewport.copy(source.viewport);
    this.texture = source.texture.clone();
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    return this;
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  }
};
THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype);
// File:src/renderers/WebGLRenderTargetCube.js
/**
 * @author alteredq / http://alteredqualia.com
 */
THREE.WebGLRenderTargetCube = function (width, height, options) {
  THREE.WebGLRenderTarget.call(this, width, height, options);
  this.activeCubeFace = 0;
  // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
  this.activeMipMapLevel = 0;
};
THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype);
THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;
// File:src/renderers/webgl/WebGLBufferRenderer.js
/**
* @author mrdoob / http://mrdoob.com/
*/
THREE.WebGLBufferRenderer = function (_gl, extensions, _infoRender) {
  var mode;
  function setMode(value) {
    mode = value;
  }
  function render(start, count) {
    _gl.drawArrays(mode, start, count);
    _infoRender.calls++;
    _infoRender.vertices += count;
    if (mode === _gl.TRIANGLES)
      _infoRender.faces += count / 3;
  }
  function renderInstances(geometry) {
    var extension = extensions.get('ANGLE_instanced_arrays');
    if (extension === null) {
      console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
      return;
    }
    var position = geometry.attributes.position;
    var count = 0;
    if (position instanceof THREE.InterleavedBufferAttribute) {
      count = position.data.count;
      extension.drawArraysInstancedANGLE(mode, 0, count, geometry.maxInstancedCount);
    } else {
      count = position.count;
      extension.drawArraysInstancedANGLE(mode, 0, count, geometry.maxInstancedCount);
    }
    _infoRender.calls++;
    _infoRender.vertices += count * geometry.maxInstancedCount;
    if (mode === _gl.TRIANGLES)
      _infoRender.faces += geometry.maxInstancedCount * count / 3;
  }
  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
};
// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js
/**
* @author mrdoob / http://mrdoob.com/
*/
THREE.WebGLIndexedBufferRenderer = function (_gl, extensions, _infoRender) {
  var mode;
  function setMode(value) {
    mode = value;
  }
  var type, size;
  function setIndex(index) {
    if (index.array instanceof Uint32Array && extensions.get('OES_element_index_uint')) {
      type = _gl.UNSIGNED_INT;
      size = 4;
    } else {
      type = _gl.UNSIGNED_SHORT;
      size = 2;
    }
  }
  function render(start, count) {
    _gl.drawElements(mode, count, type, start * size);
    _infoRender.calls++;
    _infoRender.vertices += count;
    if (mode === _gl.TRIANGLES)
      _infoRender.faces += count / 3;
  }
  function renderInstances(geometry, start, count) {
    var extension = extensions.get('ANGLE_instanced_arrays');
    if (extension === null) {
      console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
      return;
    }
    extension.drawElementsInstancedANGLE(mode, count, type, start * size, geometry.maxInstancedCount);
    _infoRender.calls++;
    _infoRender.vertices += count * geometry.maxInstancedCount;
    if (mode === _gl.TRIANGLES)
      _infoRender.faces += geometry.maxInstancedCount * count / 3;
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
};
// File:src/renderers/webgl/WebGLExtensions.js
/**
* @author mrdoob / http://mrdoob.com/
*/
THREE.WebGLExtensions = function (gl) {
  var extensions = {};
  this.get = function (name) {
    if (extensions[name] !== undefined) {
      return extensions[name];
    }
    var extension;
    switch (name) {
    case 'EXT_texture_filter_anisotropic':
      extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
      break;
    case 'WEBGL_compressed_texture_s3tc':
      extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
      break;
    case 'WEBGL_compressed_texture_pvrtc':
      extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
      break;
    case 'WEBGL_compressed_texture_etc1':
      extension = gl.getExtension('WEBGL_compressed_texture_etc1');
      break;
    default:
      extension = gl.getExtension(name);
    }
    if (extension === null) {
      console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
    }
    extensions[name] = extension;
    return extension;
  };
};
// File:src/renderers/webgl/WebGLCapabilities.js
THREE.WebGLCapabilities = function (gl, extensions, parameters) {
  function getMaxPrecision(precision) {
    if (precision === 'highp') {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
        return 'highp';
      }
      precision = 'mediump';
    }
    if (precision === 'mediump') {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
        return 'mediump';
      }
    }
    return 'lowp';
  }
  this.getMaxPrecision = getMaxPrecision;
  this.precision = parameters.precision !== undefined ? parameters.precision : 'highp', this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;
  this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
  this.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
  this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
  this.maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
  this.maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  this.maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
  this.maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
  this.maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
  this.vertexTextures = this.maxVertexTextures > 0;
  this.floatFragmentTextures = !!extensions.get('OES_texture_float');
  this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;
  var _maxPrecision = getMaxPrecision(this.precision);
  if (_maxPrecision !== this.precision) {
    console.warn('THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.');
    this.precision = _maxPrecision;
  }
  if (this.logarithmicDepthBuffer) {
    this.logarithmicDepthBuffer = !!extensions.get('EXT_frag_depth');
  }
};
// File:src/renderers/webgl/WebGLGeometries.js
/**
* @author mrdoob / http://mrdoob.com/
*/
THREE.WebGLGeometries = function (gl, properties, info) {
  var geometries = {};
  function get(object) {
    var geometry = object.geometry;
    if (geometries[geometry.id] !== undefined) {
      return geometries[geometry.id];
    }
    geometry.addEventListener('dispose', onGeometryDispose);
    var buffergeometry;
    if (geometry instanceof THREE.BufferGeometry) {
      buffergeometry = geometry;
    } else if (geometry instanceof THREE.Geometry) {
      if (geometry._bufferGeometry === undefined) {
        geometry._bufferGeometry = new THREE.BufferGeometry().setFromObject(object);
      }
      buffergeometry = geometry._bufferGeometry;
    }
    geometries[geometry.id] = buffergeometry;
    info.memory.geometries++;
    return buffergeometry;
  }
  function onGeometryDispose(event) {
    var geometry = event.target;
    var buffergeometry = geometries[geometry.id];
    if (buffergeometry.index !== null) {
      deleteAttribute(buffergeometry.index);
    }
    deleteAttributes(buffergeometry.attributes);
    geometry.removeEventListener('dispose', onGeometryDispose);
    delete geometries[geometry.id];
    // TODO
    var property = properties.get(geometry);
    if (property.wireframe) {
      deleteAttribute(property.wireframe);
    }
    properties.delete(geometry);
    var bufferproperty = properties.get(buffergeometry);
    if (bufferproperty.wireframe) {
      deleteAttribute(bufferproperty.wireframe);
    }
    properties.delete(buffergeometry);
    //
    info.memory.geometries--;
  }
  function getAttributeBuffer(attribute) {
    if (attribute instanceof THREE.InterleavedBufferAttribute) {
      return properties.get(attribute.data).__webglBuffer;
    }
    return properties.get(attribute).__webglBuffer;
  }
  function deleteAttribute(attribute) {
    var buffer = getAttributeBuffer(attribute);
    if (buffer !== undefined) {
      gl.deleteBuffer(buffer);
      removeAttributeBuffer(attribute);
    }
  }
  function deleteAttributes(attributes) {
    for (var name in attributes) {
      deleteAttribute(attributes[name]);
    }
  }
  function removeAttributeBuffer(attribute) {
    if (attribute instanceof THREE.InterleavedBufferAttribute) {
      properties.delete(attribute.data);
    } else {
      properties.delete(attribute);
    }
  }
  this.get = get;
};
// File:src/renderers/webgl/WebGLLights.js
/**
* @author mrdoob / http://mrdoob.com/
*/
THREE.WebGLLights = function () {
  var lights = {};
  this.get = function (light) {
    if (lights[light.id] !== undefined) {
      return lights[light.id];
    }
    var uniforms;
    switch (light.type) {
    case 'DirectionalLight':
      uniforms = {
        direction: new THREE.Vector3(),
        color: new THREE.Color(),
        shadow: false,
        shadowBias: 0,
        shadowRadius: 1,
        shadowMapSize: new THREE.Vector2()
      };
      break;
    case 'SpotLight':
      uniforms = {
        position: new THREE.Vector3(),
        direction: new THREE.Vector3(),
        color: new THREE.Color(),
        distance: 0,
        coneCos: 0,
        penumbraCos: 0,
        decay: 0,
        shadow: false,
        shadowBias: 0,
        shadowRadius: 1,
        shadowMapSize: new THREE.Vector2()
      };
      break;
    case 'PointLight':
      uniforms = {
        position: new THREE.Vector3(),
        color: new THREE.Color(),
        distance: 0,
        decay: 0,
        shadow: false,
        shadowBias: 0,
        shadowRadius: 1,
        shadowMapSize: new THREE.Vector2()
      };
      break;
    case 'HemisphereLight':
      uniforms = {
        direction: new THREE.Vector3(),
        skyColor: new THREE.Color(),
        groundColor: new THREE.Color()
      };
      break;
    }
    lights[light.id] = uniforms;
    return uniforms;
  };
};
// File:src/renderers/webgl/WebGLObjects.js
/**
* @author mrdoob / http://mrdoob.com/
*/
THREE.WebGLObjects = function (gl, properties, info) {
  var geometries = new THREE.WebGLGeometries(gl, properties, info);
  //
  function update(object) {
    // TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.
    var geometry = geometries.get(object);
    if (object.geometry instanceof THREE.Geometry) {
      geometry.updateFromObject(object);
    }
    var index = geometry.index;
    var attributes = geometry.attributes;
    if (index !== null) {
      updateAttribute(index, gl.ELEMENT_ARRAY_BUFFER);
    }
    for (var name in attributes) {
      updateAttribute(attributes[name], gl.ARRAY_BUFFER);
    }
    // morph targets
    var morphAttributes = geometry.morphAttributes;
    for (var name in morphAttributes) {
      var array = morphAttributes[name];
      for (var i = 0, l = array.length; i < l; i++) {
        updateAttribute(array[i], gl.ARRAY_BUFFER);
      }
    }
    return geometry;
  }
  function updateAttribute(attribute, bufferType) {
    var data = attribute instanceof THREE.InterleavedBufferAttribute ? attribute.data : attribute;
    var attributeProperties = properties.get(data);
    if (attributeProperties.__webglBuffer === undefined) {
      createBuffer(attributeProperties, data, bufferType);
    } else if (attributeProperties.version !== data.version) {
      updateBuffer(attributeProperties, data, bufferType);
    }
  }
  function createBuffer(attributeProperties, data, bufferType) {
    attributeProperties.__webglBuffer = gl.createBuffer();
    gl.bindBuffer(bufferType, attributeProperties.__webglBuffer);
    var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
    gl.bufferData(bufferType, data.array, usage);
    attributeProperties.version = data.version;
  }
  function updateBuffer(attributeProperties, data, bufferType) {
    gl.bindBuffer(bufferType, attributeProperties.__webglBuffer);
    if (data.dynamic === false || data.updateRange.count === -1) {
      // Not using update ranges
      gl.bufferSubData(bufferType, 0, data.array);
    } else if (data.updateRange.count === 0) {
      console.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.');
    } else {
      gl.bufferSubData(bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT, data.array.subarray(data.updateRange.offset, data.updateRange.offset + data.updateRange.count));
      data.updateRange.count = 0;  // reset range
    }
    attributeProperties.version = data.version;
  }
  function getAttributeBuffer(attribute) {
    if (attribute instanceof THREE.InterleavedBufferAttribute) {
      return properties.get(attribute.data).__webglBuffer;
    }
    return properties.get(attribute).__webglBuffer;
  }
  function getWireframeAttribute(geometry) {
    var property = properties.get(geometry);
    if (property.wireframe !== undefined) {
      return property.wireframe;
    }
    var indices = [];
    var index = geometry.index;
    var attributes = geometry.attributes;
    var position = attributes.position;
    if (index !== null) {
      var edges = {};
      var array = index.array;
      for (var i = 0, l = array.length; i < l; i += 3) {
        var a = array[i + 0];
        var b = array[i + 1];
        var c = array[i + 2];
        if (checkEdge(edges, a, b))
          indices.push(a, b);
        if (checkEdge(edges, b, c))
          indices.push(b, c);
        if (checkEdge(edges, c, a))
          indices.push(c, a);
      }
    } else {
      var array = attributes.position.array;
      for (var i = 0, l = array.length / 3 - 1; i < l; i += 3) {
        var a = i + 0;
        var b = i + 1;
        var c = i + 2;
        indices.push(a, b, b, c, c, a);
      }
    }
    var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
    var attribute = new THREE.BufferAttribute(new TypeArray(indices), 1);
    updateAttribute(attribute, gl.ELEMENT_ARRAY_BUFFER);
    property.wireframe = attribute;
    return attribute;
  }
  function checkEdge(edges, a, b) {
    if (a > b) {
      var tmp = a;
      a = b;
      b = tmp;
    }
    var list = edges[a];
    if (list === undefined) {
      edges[a] = [b];
      return true;
    } else if (list.indexOf(b) === -1) {
      list.push(b);
      return true;
    }
    return false;
  }
  this.getAttributeBuffer = getAttributeBuffer;
  this.getWireframeAttribute = getWireframeAttribute;
  this.update = update;
};
// File:src/renderers/webgl/WebGLProgram.js
THREE.WebGLProgram = function () {
  var programIdCount = 0;
  // TODO: Combine the regex
  var structRe = /^([\w\d_]+)\.([\w\d_]+)$/;
  var arrayStructRe = /^([\w\d_]+)\[(\d+)\]\.([\w\d_]+)$/;
  var arrayRe = /^([\w\d_]+)\[0\]$/;
  function getEncodingComponents(encoding) {
    switch (encoding) {
    case THREE.LinearEncoding:
      return [
        'Linear',
        '( value )'
      ];
    case THREE.sRGBEncoding:
      return [
        'sRGB',
        '( value )'
      ];
    case THREE.RGBEEncoding:
      return [
        'RGBE',
        '( value )'
      ];
    case THREE.RGBM7Encoding:
      return [
        'RGBM',
        '( value, 7.0 )'
      ];
    case THREE.RGBM16Encoding:
      return [
        'RGBM',
        '( value, 16.0 )'
      ];
    case THREE.RGBDEncoding:
      return [
        'RGBD',
        '( value, 256.0 )'
      ];
    case THREE.GammaEncoding:
      return [
        'Gamma',
        '( value, float( GAMMA_FACTOR ) )'
      ];
    default:
      throw new Error('unsupported encoding: ' + encoding);
    }
  }
  function getTexelDecodingFunction(functionName, encoding) {
    var components = getEncodingComponents(encoding);
    return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
  }
  function getTexelEncodingFunction(functionName, encoding) {
    var components = getEncodingComponents(encoding);
    return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
  }
  function getToneMappingFunction(functionName, toneMapping) {
    var toneMappingName;
    switch (toneMapping) {
    case THREE.LinearToneMapping:
      toneMappingName = 'Linear';
      break;
    case THREE.ReinhardToneMapping:
      toneMappingName = 'Reinhard';
      break;
    case THREE.Uncharted2ToneMapping:
      toneMappingName = 'Uncharted2';
      break;
    case THREE.CineonToneMapping:
      toneMappingName = 'OptimizedCineon';
      break;
    default:
      throw new Error('unsupported toneMapping: ' + toneMapping);
    }
    return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
  }
  function generateExtensions(extensions, parameters, rendererExtensions) {
    extensions = extensions || {};
    var chunks = [
      extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ? '#extension GL_OES_standard_derivatives : enable' : '',
      (extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get('EXT_frag_depth') ? '#extension GL_EXT_frag_depth : enable' : '',
      extensions.drawBuffers && rendererExtensions.get('WEBGL_draw_buffers') ? '#extension GL_EXT_draw_buffers : require' : '',
      (extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get('EXT_shader_texture_lod') ? '#extension GL_EXT_shader_texture_lod : enable' : ''
    ];
    return chunks.filter(filterEmptyLine).join('\n');
  }
  function generateDefines(defines) {
    var chunks = [];
    for (var name in defines) {
      var value = defines[name];
      if (value === false)
        continue;
      chunks.push('#define ' + name + ' ' + value);
    }
    return chunks.join('\n');
  }
  function fetchUniformLocations(gl, program, identifiers) {
    var uniforms = {};
    var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (var i = 0; i < n; i++) {
      var info = gl.getActiveUniform(program, i);
      var name = info.name;
      var location = gl.getUniformLocation(program, name);
      var matches = structRe.exec(name);
      if (matches) {
        var structName = matches[1];
        var structProperty = matches[2];
        var uniformsStruct = uniforms[structName];
        if (!uniformsStruct) {
          uniformsStruct = uniforms[structName] = {};
        }
        uniformsStruct[structProperty] = location;
        continue;
      }
      matches = arrayStructRe.exec(name);
      if (matches) {
        var arrayName = matches[1];
        var arrayIndex = matches[2];
        var arrayProperty = matches[3];
        var uniformsArray = uniforms[arrayName];
        if (!uniformsArray) {
          uniformsArray = uniforms[arrayName] = [];
        }
        var uniformsArrayIndex = uniformsArray[arrayIndex];
        if (!uniformsArrayIndex) {
          uniformsArrayIndex = uniformsArray[arrayIndex] = {};
        }
        uniformsArrayIndex[arrayProperty] = location;
        continue;
      }
      matches = arrayRe.exec(name);
      if (matches) {
        var arrayName = matches[1];
        uniforms[arrayName] = location;
        continue;
      }
      uniforms[name] = location;
    }
    return uniforms;
  }
  function fetchAttributeLocations(gl, program, identifiers) {
    var attributes = {};
    var n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (var i = 0; i < n; i++) {
      var info = gl.getActiveAttrib(program, i);
      var name = info.name;
      attributes[name] = gl.getAttribLocation(program, name);
    }
    return attributes;
  }
  function filterEmptyLine(string) {
    return string !== '';
  }
  function replaceLightNums(string, parameters) {
    return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights);
  }
  function parseIncludes(string) {
    var pattern = /#include +<([\w\d.]+)>/g;
    function replace(match, include) {
      var replace = THREE.ShaderChunk[include];
      if (replace === undefined) {
        throw new Error('Can not resolve #include <' + include + '>');
      }
      return parseIncludes(replace);
    }
    return string.replace(pattern, replace);
  }
  function unrollLoops(string) {
    var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
    function replace(match, start, end, snippet) {
      var unroll = '';
      for (var i = parseInt(start); i < parseInt(end); i++) {
        unroll += snippet.replace(/\[ i \]/g, '[ ' + i + ' ]');
      }
      return unroll;
    }
    return string.replace(pattern, replace);
  }
  return function WebGLProgram(renderer, code, material, parameters) {
    var gl = renderer.context;
    var extensions = material.extensions;
    var defines = material.defines;
    var vertexShader = material.__webglShader.vertexShader;
    var fragmentShader = material.__webglShader.fragmentShader;
    var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
    if (parameters.shadowMapType === THREE.PCFShadowMap) {
      shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
    } else if (parameters.shadowMapType === THREE.PCFSoftShadowMap) {
      shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
    }
    var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
    var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
    var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
    if (parameters.envMap) {
      switch (material.envMap.mapping) {
      case THREE.CubeReflectionMapping:
      case THREE.CubeRefractionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
        break;
      case THREE.CubeUVReflectionMapping:
      case THREE.CubeUVRefractionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
        break;
      case THREE.EquirectangularReflectionMapping:
      case THREE.EquirectangularRefractionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
        break;
      case THREE.SphericalReflectionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
        break;
      }
      switch (material.envMap.mapping) {
      case THREE.CubeRefractionMapping:
      case THREE.EquirectangularRefractionMapping:
        envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
        break;
      }
      switch (material.combine) {
      case THREE.MultiplyOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
        break;
      case THREE.MixOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
        break;
      case THREE.AddOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
        break;
      }
    }
    var gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
    //
    var customExtensions = generateExtensions(extensions, parameters, renderer.extensions);
    var customDefines = generateDefines(defines);
    //
    var program = gl.createProgram();
    var prefixVertex, prefixFragment;
    if (material instanceof THREE.RawShaderMaterial) {
      prefixVertex = '';
      prefixFragment = '';
    } else {
      prefixVertex = [
        'precision ' + parameters.precision + ' float;',
        'precision ' + parameters.precision + ' int;',
        '#define SHADER_NAME ' + material.__webglShader.name,
        customDefines,
        parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
        '#define GAMMA_FACTOR ' + gammaFactorDefine,
        '#define MAX_BONES ' + parameters.maxBones,
        parameters.map ? '#define USE_MAP' : '',
        parameters.envMap ? '#define USE_ENVMAP' : '',
        parameters.envMap ? '#define ' + envMapModeDefine : '',
        parameters.lightMap ? '#define USE_LIGHTMAP' : '',
        parameters.aoMap ? '#define USE_AOMAP' : '',
        parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
        parameters.bumpMap ? '#define USE_BUMPMAP' : '',
        parameters.normalMap ? '#define USE_NORMALMAP' : '',
        parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
        parameters.specularMap ? '#define USE_SPECULARMAP' : '',
        parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
        parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
        parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
        parameters.vertexColors ? '#define USE_COLOR' : '',
        parameters.flatShading ? '#define FLAT_SHADED' : '',
        parameters.skinning ? '#define USE_SKINNING' : '',
        parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',
        parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
        parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
        parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
        parameters.flipSided ? '#define FLIP_SIDED' : '',
        parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
        parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '',
        parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
        parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '',
        'uniform mat4 modelMatrix;',
        'uniform mat4 modelViewMatrix;',
        'uniform mat4 projectionMatrix;',
        'uniform mat4 viewMatrix;',
        'uniform mat3 normalMatrix;',
        'uniform vec3 cameraPosition;',
        'attribute vec3 position;',
        'attribute vec3 normal;',
        'attribute vec2 uv;',
        '#ifdef USE_COLOR',
        '\tattribute vec3 color;',
        '#endif',
        '#ifdef USE_MORPHTARGETS',
        '\tattribute vec3 morphTarget0;',
        '\tattribute vec3 morphTarget1;',
        '\tattribute vec3 morphTarget2;',
        '\tattribute vec3 morphTarget3;',
        '\t#ifdef USE_MORPHNORMALS',
        '\t\tattribute vec3 morphNormal0;',
        '\t\tattribute vec3 morphNormal1;',
        '\t\tattribute vec3 morphNormal2;',
        '\t\tattribute vec3 morphNormal3;',
        '\t#else',
        '\t\tattribute vec3 morphTarget4;',
        '\t\tattribute vec3 morphTarget5;',
        '\t\tattribute vec3 morphTarget6;',
        '\t\tattribute vec3 morphTarget7;',
        '\t#endif',
        '#endif',
        '#ifdef USE_SKINNING',
        '\tattribute vec4 skinIndex;',
        '\tattribute vec4 skinWeight;',
        '#endif',
        '\n'
      ].filter(filterEmptyLine).join('\n');
      prefixFragment = [
        customExtensions,
        'precision ' + parameters.precision + ' float;',
        'precision ' + parameters.precision + ' int;',
        '#define SHADER_NAME ' + material.__webglShader.name,
        customDefines,
        parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',
        '#define GAMMA_FACTOR ' + gammaFactorDefine,
        parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
        parameters.useFog && parameters.fogExp ? '#define FOG_EXP2' : '',
        parameters.map ? '#define USE_MAP' : '',
        parameters.envMap ? '#define USE_ENVMAP' : '',
        parameters.envMap ? '#define ' + envMapTypeDefine : '',
        parameters.envMap ? '#define ' + envMapModeDefine : '',
        parameters.envMap ? '#define ' + envMapBlendingDefine : '',
        parameters.lightMap ? '#define USE_LIGHTMAP' : '',
        parameters.aoMap ? '#define USE_AOMAP' : '',
        parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
        parameters.bumpMap ? '#define USE_BUMPMAP' : '',
        parameters.normalMap ? '#define USE_NORMALMAP' : '',
        parameters.specularMap ? '#define USE_SPECULARMAP' : '',
        parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
        parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
        parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
        parameters.vertexColors ? '#define USE_COLOR' : '',
        parameters.flatShading ? '#define FLAT_SHADED' : '',
        parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
        parameters.flipSided ? '#define FLIP_SIDED' : '',
        parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
        parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '',
        parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
        parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',
        parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '',
        parameters.envMap && renderer.extensions.get('EXT_shader_texture_lod') ? '#define TEXTURE_LOD_EXT' : '',
        'uniform mat4 viewMatrix;',
        'uniform vec3 cameraPosition;',
        parameters.toneMapping !== THREE.NoToneMapping ? '#define TONE_MAPPING' : '',
        parameters.toneMapping !== THREE.NoToneMapping ? THREE.ShaderChunk['tonemapping_pars_fragment'] : '',
        // this code is required here because it is used by the toneMapping() function defined below
        parameters.toneMapping !== THREE.NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '',
        parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ? THREE.ShaderChunk['encodings_pars_fragment'] : '',
        // this code is required here because it is used by the various encoding/decoding function defined below
        parameters.mapEncoding ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '',
        parameters.envMapEncoding ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '',
        parameters.emissiveMapEncoding ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '',
        parameters.outputEncoding ? getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding) : '',
        '\n'
      ].filter(filterEmptyLine).join('\n');
    }
    vertexShader = parseIncludes(vertexShader, parameters);
    vertexShader = replaceLightNums(vertexShader, parameters);
    fragmentShader = parseIncludes(fragmentShader, parameters);
    fragmentShader = replaceLightNums(fragmentShader, parameters);
    if (material instanceof THREE.ShaderMaterial === false) {
      vertexShader = unrollLoops(vertexShader);
      fragmentShader = unrollLoops(fragmentShader);
    }
    var vertexGlsl = prefixVertex + vertexShader;
    var fragmentGlsl = prefixFragment + fragmentShader;
    var glVertexShader = THREE.WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
    var glFragmentShader = THREE.WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
    gl.attachShader(program, glVertexShader);
    gl.attachShader(program, glFragmentShader);
    // Force a particular attribute to index 0.
    if (material.index0AttributeName !== undefined) {
      gl.bindAttribLocation(program, 0, material.index0AttributeName);
    } else if (parameters.morphTargets === true) {
      // programs with morphTargets displace position out of attribute 0
      gl.bindAttribLocation(program, 0, 'position');
    }
    gl.linkProgram(program);
    var programLog = gl.getProgramInfoLog(program);
    var vertexLog = gl.getShaderInfoLog(glVertexShader);
    var fragmentLog = gl.getShaderInfoLog(glFragmentShader);
    var runnable = true;
    var haveDiagnostics = true;
    if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
      runnable = false;
      console.error('THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog);
    } else if (programLog !== '') {
      console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
    } else if (vertexLog === '' || fragmentLog === '') {
      haveDiagnostics = false;
    }
    if (haveDiagnostics) {
      this.diagnostics = {
        runnable: runnable,
        material: material,
        programLog: programLog,
        vertexShader: {
          log: vertexLog,
          prefix: prefixVertex
        },
        fragmentShader: {
          log: fragmentLog,
          prefix: prefixFragment
        }
      };
    }
    // clean up
    gl.deleteShader(glVertexShader);
    gl.deleteShader(glFragmentShader);
    // set up caching for uniform locations
    var cachedUniforms;
    this.getUniforms = function () {
      if (cachedUniforms === undefined) {
        cachedUniforms = fetchUniformLocations(gl, program);
      }
      return cachedUniforms;
    };
    // set up caching for attribute locations
    var cachedAttributes;
    this.getAttributes = function () {
      if (cachedAttributes === undefined) {
        cachedAttributes = fetchAttributeLocations(gl, program);
      }
      return cachedAttributes;
    };
    // free resource
    this.destroy = function () {
      gl.deleteProgram(program);
      this.program = undefined;
    };
    // DEPRECATED
    Object.defineProperties(this, {
      uniforms: {
        get: function () {
          console.warn('THREE.WebGLProgram: .uniforms is now .getUniforms().');
          return this.getUniforms();
        }
      },
      attributes: {
        get: function () {
          console.warn('THREE.WebGLProgram: .attributes is now .getAttributes().');
          return this.getAttributes();
        }
      }
    });
    //
    this.id = programIdCount++;
    this.code = code;
    this.usedTimes = 1;
    this.program = program;
    this.vertexShader = glVertexShader;
    this.fragmentShader = glFragmentShader;
    return this;
  };
}();
// File:src/renderers/webgl/WebGLPrograms.js
THREE.WebGLPrograms = function (renderer, capabilities) {
  var programs = [];
  var shaderIDs = {
    MeshDepthMaterial: 'depth',
    MeshNormalMaterial: 'normal',
    MeshBasicMaterial: 'basic',
    MeshLambertMaterial: 'lambert',
    MeshPhongMaterial: 'phong',
    MeshStandardMaterial: 'standard',
    LineBasicMaterial: 'basic',
    LineDashedMaterial: 'dashed',
    PointsMaterial: 'points'
  };
  var parameterNames = [
    'precision',
    'supportsVertexTextures',
    'map',
    'mapEncoding',
    'envMap',
    'envMapMode',
    'envMapEncoding',
    'lightMap',
    'aoMap',
    'emissiveMap',
    'emissiveMapEncoding',
    'bumpMap',
    'normalMap',
    'displacementMap',
    'specularMap',
    'roughnessMap',
    'metalnessMap',
    'alphaMap',
    'combine',
    'vertexColors',
    'fog',
    'useFog',
    'fogExp',
    'flatShading',
    'sizeAttenuation',
    'logarithmicDepthBuffer',
    'skinning',
    'maxBones',
    'useVertexTexture',
    'morphTargets',
    'morphNormals',
    'maxMorphTargets',
    'maxMorphNormals',
    'premultipliedAlpha',
    'numDirLights',
    'numPointLights',
    'numSpotLights',
    'numHemiLights',
    'shadowMapEnabled',
    'pointLightShadows',
    'toneMapping',
    'physicallyCorrectLights',
    'shadowMapType',
    'alphaTest',
    'doubleSided',
    'flipSided'
  ];
  function allocateBones(object) {
    if (capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture) {
      return 1024;
    } else {
      // default for when object is not specified
      // ( for example when prebuilding shader to be used with multiple objects )
      //
      //  - leave some extra space for other uniforms
      //  - limit here is ANGLE's 254 max uniform vectors
      //    (up to 54 should be safe)
      var nVertexUniforms = capabilities.maxVertexUniforms;
      var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      var maxBones = nVertexMatrices;
      if (object !== undefined && object instanceof THREE.SkinnedMesh) {
        maxBones = Math.min(object.skeleton.bones.length, maxBones);
        if (maxBones < object.skeleton.bones.length) {
          console.warn('WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)');
        }
      }
      return maxBones;
    }
  }
  function getTextureEncodingFromMap(map, gammaOverrideLinear) {
    var encoding;
    if (!map) {
      encoding = THREE.LinearEncoding;
    } else if (map instanceof THREE.Texture) {
      encoding = map.encoding;
    } else if (map instanceof THREE.WebGLRenderTarget) {
      encoding = map.texture.encoding;
    }
    // add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
    if (encoding === THREE.LinearEncoding && gammaOverrideLinear) {
      encoding = THREE.GammaEncoding;
    }
    return encoding;
  }
  this.getParameters = function (material, lights, fog, object) {
    var shaderID = shaderIDs[material.type];
    // heuristics to create shader parameters according to lights in the scene
    // (not to blow over maxLights budget)
    var maxBones = allocateBones(object);
    var precision = renderer.getPrecision();
    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
      }
    }
    var parameters = {
      shaderID: shaderID,
      precision: precision,
      supportsVertexTextures: capabilities.vertexTextures,
      outputEncoding: getTextureEncodingFromMap(renderer.getCurrentRenderTarget(), renderer.gammaOutput),
      map: !!material.map,
      mapEncoding: getTextureEncodingFromMap(material.map, renderer.gammaInput),
      envMap: !!material.envMap,
      envMapMode: material.envMap && material.envMap.mapping,
      envMapEncoding: getTextureEncodingFromMap(material.envMap, renderer.gammaInput),
      envMapCubeUV: !!material.envMap && (material.envMap.mapping === THREE.CubeUVReflectionMapping || material.envMap.mapping === THREE.CubeUVRefractionMapping),
      lightMap: !!material.lightMap,
      aoMap: !!material.aoMap,
      emissiveMap: !!material.emissiveMap,
      emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap, renderer.gammaInput),
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      displacementMap: !!material.displacementMap,
      roughnessMap: !!material.roughnessMap,
      metalnessMap: !!material.metalnessMap,
      specularMap: !!material.specularMap,
      alphaMap: !!material.alphaMap,
      combine: material.combine,
      vertexColors: material.vertexColors,
      fog: fog,
      useFog: material.fog,
      fogExp: fog instanceof THREE.FogExp2,
      flatShading: material.shading === THREE.FlatShading,
      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
      skinning: material.skinning,
      maxBones: maxBones,
      useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,
      morphTargets: material.morphTargets,
      morphNormals: material.morphNormals,
      maxMorphTargets: renderer.maxMorphTargets,
      maxMorphNormals: renderer.maxMorphNormals,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numHemiLights: lights.hemi.length,
      pointLightShadows: lights.shadowsPointLight,
      shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping: renderer.toneMapping,
      physicallyCorrectLights: renderer.physicallyCorrectLights,
      premultipliedAlpha: material.premultipliedAlpha,
      alphaTest: material.alphaTest,
      doubleSided: material.side === THREE.DoubleSide,
      flipSided: material.side === THREE.BackSide
    };
    return parameters;
  };
  this.getProgramCode = function (material, parameters) {
    var chunks = [];
    if (parameters.shaderID) {
      chunks.push(parameters.shaderID);
    } else {
      chunks.push(material.fragmentShader);
      chunks.push(material.vertexShader);
    }
    if (material.defines !== undefined) {
      for (var name in material.defines) {
        chunks.push(name);
        chunks.push(material.defines[name]);
      }
    }
    for (var i = 0; i < parameterNames.length; i++) {
      var parameterName = parameterNames[i];
      chunks.push(parameterName);
      chunks.push(parameters[parameterName]);
    }
    return chunks.join();
  };
  this.acquireProgram = function (material, parameters, code) {
    var program;
    // Check if code has been already compiled
    for (var p = 0, pl = programs.length; p < pl; p++) {
      var programInfo = programs[p];
      if (programInfo.code === code) {
        program = programInfo;
        ++program.usedTimes;
        break;
      }
    }
    if (program === undefined) {
      program = new THREE.WebGLProgram(renderer, code, material, parameters);
      programs.push(program);
    }
    return program;
  };
  this.releaseProgram = function (program) {
    if (--program.usedTimes === 0) {
      // Remove from unordered set
      var i = programs.indexOf(program);
      programs[i] = programs[programs.length - 1];
      programs.pop();
      // Free WebGL resources
      program.destroy();
    }
  };
  // Exposed for resource monitoring & error feedback via renderer.info:
  this.programs = programs;
};
// File:src/renderers/webgl/WebGLProperties.js
/**
* @author fordacious / fordacious.github.io
*/
THREE.WebGLProperties = function () {
  var properties = {};
  this.get = function (object) {
    var uuid = object.uuid;
    var map = properties[uuid];
    if (map === undefined) {
      map = {};
      properties[uuid] = map;
    }
    return map;
  };
  this.delete = function (object) {
    delete properties[object.uuid];
  };
  this.clear = function () {
    properties = {};
  };
};
// File:src/renderers/webgl/WebGLShader.js
THREE.WebGLShader = function () {
  function addLineNumbers(string) {
    var lines = string.split('\n');
    for (var i = 0; i < lines.length; i++) {
      lines[i] = i + 1 + ': ' + lines[i];
    }
    return lines.join('\n');
  }
  return function WebGLShader(gl, type, string) {
    var shader = gl.createShader(type);
    gl.shaderSource(shader, string);
    gl.compileShader(shader);
    if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
      console.error('THREE.WebGLShader: Shader couldn\'t compile.');
    }
    if (gl.getShaderInfoLog(shader) !== '') {
      console.warn('THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog(shader), addLineNumbers(string));
    }
    // --enable-privileged-webgl-extension
    return shader;
  };
}();
// File:src/renderers/webgl/WebGLShadowMap.js
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */
THREE.WebGLShadowMap = function (_renderer, _lights, _objects) {
  var _gl = _renderer.context, _state = _renderer.state, _frustum = new THREE.Frustum(), _projScreenMatrix = new THREE.Matrix4(), _shadowMapSize = new THREE.Vector2(), _lookTarget = new THREE.Vector3(), _lightPositionWorld = new THREE.Vector3(), _renderList = [], _MorphingFlag = 1, _SkinningFlag = 2, _NumberOfMaterialVariants = (_MorphingFlag | _SkinningFlag) + 1, _depthMaterials = new Array(_NumberOfMaterialVariants), _distanceMaterials = new Array(_NumberOfMaterialVariants);
  var cubeDirections = [
    new THREE.Vector3(1, 0, 0),
    new THREE.Vector3(-1, 0, 0),
    new THREE.Vector3(0, 0, 1),
    new THREE.Vector3(0, 0, -1),
    new THREE.Vector3(0, 1, 0),
    new THREE.Vector3(0, -1, 0)
  ];
  var cubeUps = [
    new THREE.Vector3(0, 1, 0),
    new THREE.Vector3(0, 1, 0),
    new THREE.Vector3(0, 1, 0),
    new THREE.Vector3(0, 1, 0),
    new THREE.Vector3(0, 0, 1),
    new THREE.Vector3(0, 0, -1)
  ];
  var cube2DViewPorts = [
    new THREE.Vector4(),
    new THREE.Vector4(),
    new THREE.Vector4(),
    new THREE.Vector4(),
    new THREE.Vector4(),
    new THREE.Vector4()
  ];
  // init
  var depthShader = THREE.ShaderLib['depthRGBA'];
  var depthUniforms = THREE.UniformsUtils.clone(depthShader.uniforms);
  var distanceShader = THREE.ShaderLib['distanceRGBA'];
  var distanceUniforms = THREE.UniformsUtils.clone(distanceShader.uniforms);
  for (var i = 0; i !== _NumberOfMaterialVariants; ++i) {
    var useMorphing = (i & _MorphingFlag) !== 0;
    var useSkinning = (i & _SkinningFlag) !== 0;
    var depthMaterial = new THREE.ShaderMaterial({
      uniforms: depthUniforms,
      vertexShader: depthShader.vertexShader,
      fragmentShader: depthShader.fragmentShader,
      morphTargets: useMorphing,
      skinning: useSkinning
    });
    _depthMaterials[i] = depthMaterial;
    var distanceMaterial = new THREE.ShaderMaterial({
      defines: { 'USE_SHADOWMAP': '' },
      uniforms: distanceUniforms,
      vertexShader: distanceShader.vertexShader,
      fragmentShader: distanceShader.fragmentShader,
      morphTargets: useMorphing,
      skinning: useSkinning
    });
    _distanceMaterials[i] = distanceMaterial;
  }
  //
  var scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = THREE.PCFShadowMap;
  this.cullFace = THREE.CullFaceFront;
  this.render = function (scene, camera) {
    var faceCount, isPointLight;
    var shadows = _lights.shadows;
    if (shadows.length === 0)
      return;
    if (scope.enabled === false)
      return;
    if (scope.autoUpdate === false && scope.needsUpdate === false)
      return;
    // Set GL state for depth map.
    _state.clearColor(1, 1, 1, 1);
    _state.disable(_gl.BLEND);
    _state.enable(_gl.CULL_FACE);
    _gl.frontFace(_gl.CCW);
    _gl.cullFace(scope.cullFace === THREE.CullFaceFront ? _gl.FRONT : _gl.BACK);
    _state.setDepthTest(true);
    _state.setScissorTest(false);
    // render depth map
    for (var i = 0, il = shadows.length; i < il; i++) {
      var light = shadows[i];
      var shadow = light.shadow;
      var shadowCamera = shadow.camera;
      _shadowMapSize.copy(shadow.mapSize);
      if (light instanceof THREE.PointLight) {
        faceCount = 6;
        isPointLight = true;
        var vpWidth = _shadowMapSize.x;
        var vpHeight = _shadowMapSize.y;
        // These viewports map a cube-map onto a 2D texture with the
        // following orientation:
        //
        //  xzXZ
        //   y Y
        //
        // X - Positive x direction
        // x - Negative x direction
        // Y - Positive y direction
        // y - Negative y direction
        // Z - Positive z direction
        // z - Negative z direction
        // positive X
        cube2DViewPorts[0].set(vpWidth * 2, vpHeight, vpWidth, vpHeight);
        // negative X
        cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight);
        // positive Z
        cube2DViewPorts[2].set(vpWidth * 3, vpHeight, vpWidth, vpHeight);
        // negative Z
        cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight);
        // positive Y
        cube2DViewPorts[4].set(vpWidth * 3, 0, vpWidth, vpHeight);
        // negative Y
        cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight);
        _shadowMapSize.x *= 4;
        _shadowMapSize.y *= 2;
      } else {
        faceCount = 1;
        isPointLight = false;
      }
      if (shadow.map === null) {
        var pars = {
          minFilter: THREE.NearestFilter,
          magFilter: THREE.NearestFilter,
          format: THREE.RGBAFormat
        };
        shadow.map = new THREE.WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        //
        if (light instanceof THREE.SpotLight) {
          shadowCamera.aspect = _shadowMapSize.x / _shadowMapSize.y;
        }
        shadowCamera.updateProjectionMatrix();
      }
      var shadowMap = shadow.map;
      var shadowMatrix = shadow.matrix;
      _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
      shadowCamera.position.copy(_lightPositionWorld);
      _renderer.setRenderTarget(shadowMap);
      _renderer.clear();
      // render shadow map for each cube face (if omni-directional) or
      // run a single pass if not
      for (var face = 0; face < faceCount; face++) {
        if (isPointLight) {
          _lookTarget.copy(shadowCamera.position);
          _lookTarget.add(cubeDirections[face]);
          shadowCamera.up.copy(cubeUps[face]);
          shadowCamera.lookAt(_lookTarget);
          var vpDimensions = cube2DViewPorts[face];
          _state.viewport(vpDimensions);
        } else {
          _lookTarget.setFromMatrixPosition(light.target.matrixWorld);
          shadowCamera.lookAt(_lookTarget);
        }
        shadowCamera.updateMatrixWorld();
        shadowCamera.matrixWorldInverse.getInverse(shadowCamera.matrixWorld);
        // compute shadow matrix
        shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
        shadowMatrix.multiply(shadowCamera.projectionMatrix);
        shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
        // update camera matrices and frustum
        _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
        _frustum.setFromMatrix(_projScreenMatrix);
        // set object matrices & frustum culling
        _renderList.length = 0;
        projectObject(scene, camera, shadowCamera);
        // render shadow map
        // render regular objects
        for (var j = 0, jl = _renderList.length; j < jl; j++) {
          var object = _renderList[j];
          var geometry = _objects.update(object);
          var material = object.material;
          if (material instanceof THREE.MultiMaterial) {
            var groups = geometry.groups;
            var materials = material.materials;
            for (var k = 0, kl = groups.length; k < kl; k++) {
              var group = groups[k];
              var groupMaterial = materials[group.materialIndex];
              if (groupMaterial.visible === true) {
                var depthMaterial = getDepthMaterial(object, groupMaterial, isPointLight, _lightPositionWorld);
                _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
              }
            }
          } else {
            var depthMaterial = getDepthMaterial(object, material, isPointLight, _lightPositionWorld);
            _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
          }
        }
      }
    }
    // Restore GL state.
    var clearColor = _renderer.getClearColor(), clearAlpha = _renderer.getClearAlpha();
    _renderer.setClearColor(clearColor, clearAlpha);
    _state.enable(_gl.BLEND);
    if (scope.cullFace === THREE.CullFaceFront) {
      _gl.cullFace(_gl.BACK);
    }
    scope.needsUpdate = false;
  };
  function getDepthMaterial(object, material, isPointLight, lightPositionWorld) {
    var geometry = object.geometry;
    var newMaterial = null;
    var materialVariants = _depthMaterials;
    var customMaterial = object.customDepthMaterial;
    if (isPointLight) {
      materialVariants = _distanceMaterials;
      customMaterial = object.customDistanceMaterial;
    }
    if (!customMaterial) {
      var useMorphing = geometry.morphTargets !== undefined && geometry.morphTargets.length > 0 && material.morphTargets;
      var useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;
      var variantIndex = 0;
      if (useMorphing)
        variantIndex |= _MorphingFlag;
      if (useSkinning)
        variantIndex |= _SkinningFlag;
      newMaterial = materialVariants[variantIndex];
    } else {
      newMaterial = customMaterial;
    }
    newMaterial.visible = material.visible;
    newMaterial.wireframe = material.wireframe;
    newMaterial.wireframeLinewidth = material.wireframeLinewidth;
    if (isPointLight && newMaterial.uniforms.lightPos !== undefined) {
      newMaterial.uniforms.lightPos.value.copy(lightPositionWorld);
    }
    return newMaterial;
  }
  function projectObject(object, camera, shadowCamera) {
    if (object.visible === false)
      return;
    if (object.layers.test(camera.layers) && (object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points)) {
      if (object.castShadow && (object.frustumCulled === false || _frustum.intersectsObject(object) === true)) {
        var material = object.material;
        if (material.visible === true) {
          object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
          _renderList.push(object);
        }
      }
    }
    var children = object.children;
    for (var i = 0, l = children.length; i < l; i++) {
      projectObject(children[i], camera, shadowCamera);
    }
  }
};
// File:src/renderers/webgl/WebGLState.js
/**
* @author mrdoob / http://mrdoob.com/
*/
THREE.WebGLState = function (gl, extensions, paramThreeToGL) {
  var _this = this;
  var color = new THREE.Vector4();
  var newAttributes = new Uint8Array(16);
  var enabledAttributes = new Uint8Array(16);
  var attributeDivisors = new Uint8Array(16);
  var capabilities = {};
  var compressedTextureFormats = null;
  var currentBlending = null;
  var currentBlendEquation = null;
  var currentBlendSrc = null;
  var currentBlendDst = null;
  var currentBlendEquationAlpha = null;
  var currentBlendSrcAlpha = null;
  var currentBlendDstAlpha = null;
  var currentPremultipledAlpha = false;
  var currentDepthFunc = null;
  var currentDepthWrite = null;
  var currentColorWrite = null;
  var currentStencilWrite = null;
  var currentStencilFunc = null;
  var currentStencilRef = null;
  var currentStencilMask = null;
  var currentStencilFail = null;
  var currentStencilZFail = null;
  var currentStencilZPass = null;
  var currentFlipSided = null;
  var currentLineWidth = null;
  var currentPolygonOffsetFactor = null;
  var currentPolygonOffsetUnits = null;
  var currentScissorTest = null;
  var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
  var currentTextureSlot = undefined;
  var currentBoundTextures = {};
  var currentClearColor = new THREE.Vector4();
  var currentClearDepth = null;
  var currentClearStencil = null;
  var currentScissor = new THREE.Vector4();
  var currentViewport = new THREE.Vector4();
  var emptyTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, emptyTexture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 1, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, new Uint8Array(3));
  this.init = function () {
    this.clearColor(0, 0, 0, 1);
    this.clearDepth(1);
    this.clearStencil(0);
    this.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
    gl.frontFace(gl.CCW);
    gl.cullFace(gl.BACK);
    this.enable(gl.CULL_FACE);
    this.enable(gl.BLEND);
    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  };
  this.initAttributes = function () {
    for (var i = 0, l = newAttributes.length; i < l; i++) {
      newAttributes[i] = 0;
    }
  };
  this.enableAttribute = function (attribute) {
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== 0) {
      var extension = extensions.get('ANGLE_instanced_arrays');
      extension.vertexAttribDivisorANGLE(attribute, 0);
      attributeDivisors[attribute] = 0;
    }
  };
  this.enableAttributeAndDivisor = function (attribute, meshPerAttribute, extension) {
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      extension.vertexAttribDivisorANGLE(attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  };
  this.disableUnusedAttributes = function () {
    for (var i = 0, l = enabledAttributes.length; i < l; i++) {
      if (enabledAttributes[i] !== newAttributes[i]) {
        gl.disableVertexAttribArray(i);
        enabledAttributes[i] = 0;
      }
    }
  };
  this.enable = function (id) {
    if (capabilities[id] !== true) {
      gl.enable(id);
      capabilities[id] = true;
    }
  };
  this.disable = function (id) {
    if (capabilities[id] !== false) {
      gl.disable(id);
      capabilities[id] = false;
    }
  };
  this.getCompressedTextureFormats = function () {
    if (compressedTextureFormats === null) {
      compressedTextureFormats = [];
      if (extensions.get('WEBGL_compressed_texture_pvrtc') || extensions.get('WEBGL_compressed_texture_s3tc') || extensions.get('WEBGL_compressed_texture_etc1')) {
        var formats = gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);
        for (var i = 0; i < formats.length; i++) {
          compressedTextureFormats.push(formats[i]);
        }
      }
    }
    return compressedTextureFormats;
  };
  this.setBlending = function (blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending === THREE.NoBlending) {
      this.disable(gl.BLEND);
    } else {
      this.enable(gl.BLEND);
    }
    if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
      if (blending === THREE.AdditiveBlending) {
        if (premultipliedAlpha) {
          gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
          gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
        } else {
          gl.blendEquation(gl.FUNC_ADD);
          gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
        }
      } else if (blending === THREE.SubtractiveBlending) {
        if (premultipliedAlpha) {
          gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
          gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
        } else {
          gl.blendEquation(gl.FUNC_ADD);
          gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
        }
      } else if (blending === THREE.MultiplyBlending) {
        if (premultipliedAlpha) {
          gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
          gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.SRC_COLOR, gl.SRC_ALPHA);
        } else {
          gl.blendEquation(gl.FUNC_ADD);
          gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
        }
      } else {
        if (premultipliedAlpha) {
          gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
          gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        } else {
          gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
          gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        }
      }
      currentBlending = blending;
      currentPremultipledAlpha = premultipliedAlpha;
    }
    if (blending === THREE.CustomBlending) {
      blendEquationAlpha = blendEquationAlpha || blendEquation;
      blendSrcAlpha = blendSrcAlpha || blendSrc;
      blendDstAlpha = blendDstAlpha || blendDst;
      if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
        gl.blendEquationSeparate(paramThreeToGL(blendEquation), paramThreeToGL(blendEquationAlpha));
        currentBlendEquation = blendEquation;
        currentBlendEquationAlpha = blendEquationAlpha;
      }
      if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
        gl.blendFuncSeparate(paramThreeToGL(blendSrc), paramThreeToGL(blendDst), paramThreeToGL(blendSrcAlpha), paramThreeToGL(blendDstAlpha));
        currentBlendSrc = blendSrc;
        currentBlendDst = blendDst;
        currentBlendSrcAlpha = blendSrcAlpha;
        currentBlendDstAlpha = blendDstAlpha;
      }
    } else {
      currentBlendEquation = null;
      currentBlendSrc = null;
      currentBlendDst = null;
      currentBlendEquationAlpha = null;
      currentBlendSrcAlpha = null;
      currentBlendDstAlpha = null;
    }
  };
  this.setDepthFunc = function (depthFunc) {
    if (currentDepthFunc !== depthFunc) {
      if (depthFunc) {
        switch (depthFunc) {
        case THREE.NeverDepth:
          gl.depthFunc(gl.NEVER);
          break;
        case THREE.AlwaysDepth:
          gl.depthFunc(gl.ALWAYS);
          break;
        case THREE.LessDepth:
          gl.depthFunc(gl.LESS);
          break;
        case THREE.LessEqualDepth:
          gl.depthFunc(gl.LEQUAL);
          break;
        case THREE.EqualDepth:
          gl.depthFunc(gl.EQUAL);
          break;
        case THREE.GreaterEqualDepth:
          gl.depthFunc(gl.GEQUAL);
          break;
        case THREE.GreaterDepth:
          gl.depthFunc(gl.GREATER);
          break;
        case THREE.NotEqualDepth:
          gl.depthFunc(gl.NOTEQUAL);
          break;
        default:
          gl.depthFunc(gl.LEQUAL);
        }
      } else {
        gl.depthFunc(gl.LEQUAL);
      }
      currentDepthFunc = depthFunc;
    }
  };
  this.setDepthTest = function (depthTest) {
    if (depthTest) {
      this.enable(gl.DEPTH_TEST);
    } else {
      this.disable(gl.DEPTH_TEST);
    }
  };
  this.setDepthWrite = function (depthWrite) {
    // TODO: Rename to setDepthMask
    if (currentDepthWrite !== depthWrite) {
      gl.depthMask(depthWrite);
      currentDepthWrite = depthWrite;
    }
  };
  this.setColorWrite = function (colorWrite) {
    // TODO: Rename to setColorMask
    if (currentColorWrite !== colorWrite) {
      gl.colorMask(colorWrite, colorWrite, colorWrite, colorWrite);
      currentColorWrite = colorWrite;
    }
  };
  this.setStencilFunc = function (stencilFunc, stencilRef, stencilMask) {
    if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilMask !== stencilMask) {
      gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
      currentStencilFunc = stencilFunc;
      currentStencilRef = stencilRef;
      currentStencilMask = stencilMask;
    }
  };
  this.setStencilOp = function (stencilFail, stencilZFail, stencilZPass) {
    if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
      gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
      currentStencilFail = stencilFail;
      currentStencilZFail = stencilZFail;
      currentStencilZPass = stencilZPass;
    }
  };
  this.setStencilTest = function (stencilTest) {
    if (stencilTest) {
      this.enable(gl.STENCIL_TEST);
    } else {
      this.disable(gl.STENCIL_TEST);
    }
  };
  this.setStencilWrite = function (stencilWrite) {
    // TODO: Rename to setStencilMask
    if (currentStencilWrite !== stencilWrite) {
      gl.stencilMask(stencilWrite);
      currentStencilWrite = stencilWrite;
    }
  };
  this.setFlipSided = function (flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(gl.CW);
      } else {
        gl.frontFace(gl.CCW);
      }
      currentFlipSided = flipSided;
    }
  };
  this.setLineWidth = function (width) {
    if (width !== currentLineWidth) {
      gl.lineWidth(width);
      currentLineWidth = width;
    }
  };
  this.setPolygonOffset = function (polygonOffset, factor, units) {
    if (polygonOffset) {
      this.enable(gl.POLYGON_OFFSET_FILL);
    } else {
      this.disable(gl.POLYGON_OFFSET_FILL);
    }
    if (polygonOffset && (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units)) {
      gl.polygonOffset(factor, units);
      currentPolygonOffsetFactor = factor;
      currentPolygonOffsetUnits = units;
    }
  };
  this.getScissorTest = function () {
    return currentScissorTest;
  };
  this.setScissorTest = function (scissorTest) {
    currentScissorTest = scissorTest;
    if (scissorTest) {
      this.enable(gl.SCISSOR_TEST);
    } else {
      this.disable(gl.SCISSOR_TEST);
    }
  };
  // texture
  this.activeTexture = function (webglSlot) {
    if (webglSlot === undefined)
      webglSlot = gl.TEXTURE0 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  };
  this.bindTexture = function (webglType, webglTexture) {
    if (currentTextureSlot === undefined) {
      _this.activeTexture();
    }
    var boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture === undefined) {
      boundTexture = {
        type: undefined,
        texture: undefined
      };
      currentBoundTextures[currentTextureSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      gl.bindTexture(webglType, webglTexture || emptyTexture);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  };
  this.compressedTexImage2D = function () {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error(error);
    }
  };
  this.texImage2D = function () {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error(error);
    }
  };
  // clear values
  this.clearColor = function (r, g, b, a) {
    color.set(r, g, b, a);
    if (currentClearColor.equals(color) === false) {
      gl.clearColor(r, g, b, a);
      currentClearColor.copy(color);
    }
  };
  this.clearDepth = function (depth) {
    if (currentClearDepth !== depth) {
      gl.clearDepth(depth);
      currentClearDepth = depth;
    }
  };
  this.clearStencil = function (stencil) {
    if (currentClearStencil !== stencil) {
      gl.clearStencil(stencil);
      currentClearStencil = stencil;
    }
  };
  //
  this.scissor = function (scissor) {
    if (currentScissor.equals(scissor) === false) {
      gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
      currentScissor.copy(scissor);
    }
  };
  this.viewport = function (viewport) {
    if (currentViewport.equals(viewport) === false) {
      gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
      currentViewport.copy(viewport);
    }
  };
  //
  this.reset = function () {
    for (var i = 0; i < enabledAttributes.length; i++) {
      if (enabledAttributes[i] === 1) {
        gl.disableVertexAttribArray(i);
        enabledAttributes[i] = 0;
      }
    }
    capabilities = {};
    compressedTextureFormats = null;
    currentTextureSlot = undefined;
    currentBoundTextures = {};
    currentBlending = null;
    currentColorWrite = null;
    currentDepthWrite = null;
    currentStencilWrite = null;
    currentFlipSided = null;
  };
};
// File:src/renderers/webgl/plugins/LensFlarePlugin.js
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */
THREE.LensFlarePlugin = function (renderer, flares) {
  var gl = renderer.context;
  var state = renderer.state;
  var vertexBuffer, elementBuffer;
  var program, attributes, uniforms;
  var hasVertexTexture;
  var tempTexture, occlusionTexture;
  function init() {
    var vertices = new Float32Array([
      -1,
      -1,
      0,
      0,
      1,
      -1,
      1,
      0,
      1,
      1,
      1,
      1,
      -1,
      1,
      0,
      1
    ]);
    var faces = new Uint16Array([
      0,
      1,
      2,
      0,
      2,
      3
    ]);
    // buffers
    vertexBuffer = gl.createBuffer();
    elementBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
    // textures
    tempTexture = gl.createTexture();
    occlusionTexture = gl.createTexture();
    state.bindTexture(gl.TEXTURE_2D, tempTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    state.bindTexture(gl.TEXTURE_2D, occlusionTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    hasVertexTexture = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
    var shader;
    if (hasVertexTexture) {
      shader = {
        vertexShader: [
          'uniform lowp int renderType;',
          'uniform vec3 screenPosition;',
          'uniform vec2 scale;',
          'uniform float rotation;',
          'uniform sampler2D occlusionMap;',
          'attribute vec2 position;',
          'attribute vec2 uv;',
          'varying vec2 vUV;',
          'varying float vVisibility;',
          'void main() {',
          'vUV = uv;',
          'vec2 pos = position;',
          'if ( renderType == 2 ) {',
          'vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );',
          'visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );',
          'visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );',
          'visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );',
          'visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );',
          'visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );',
          'visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );',
          'visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );',
          'visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );',
          'vVisibility =        visibility.r / 9.0;',
          'vVisibility *= 1.0 - visibility.g / 9.0;',
          'vVisibility *=       visibility.b / 9.0;',
          'vVisibility *= 1.0 - visibility.a / 9.0;',
          'pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;',
          'pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;',
          '}',
          'gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );',
          '}'
        ].join('\n'),
        fragmentShader: [
          'uniform lowp int renderType;',
          'uniform sampler2D map;',
          'uniform float opacity;',
          'uniform vec3 color;',
          'varying vec2 vUV;',
          'varying float vVisibility;',
          'void main() {',
          // pink square
          'if ( renderType == 0 ) {',
          'gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );',
          // restore
          '} else if ( renderType == 1 ) {',
          'gl_FragColor = texture2D( map, vUV );',
          // flare
          '} else {',
          'vec4 texture = texture2D( map, vUV );',
          'texture.a *= opacity * vVisibility;',
          'gl_FragColor = texture;',
          'gl_FragColor.rgb *= color;',
          '}',
          '}'
        ].join('\n')
      };
    } else {
      shader = {
        vertexShader: [
          'uniform lowp int renderType;',
          'uniform vec3 screenPosition;',
          'uniform vec2 scale;',
          'uniform float rotation;',
          'attribute vec2 position;',
          'attribute vec2 uv;',
          'varying vec2 vUV;',
          'void main() {',
          'vUV = uv;',
          'vec2 pos = position;',
          'if ( renderType == 2 ) {',
          'pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;',
          'pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;',
          '}',
          'gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );',
          '}'
        ].join('\n'),
        fragmentShader: [
          'precision mediump float;',
          'uniform lowp int renderType;',
          'uniform sampler2D map;',
          'uniform sampler2D occlusionMap;',
          'uniform float opacity;',
          'uniform vec3 color;',
          'varying vec2 vUV;',
          'void main() {',
          // pink square
          'if ( renderType == 0 ) {',
          'gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );',
          // restore
          '} else if ( renderType == 1 ) {',
          'gl_FragColor = texture2D( map, vUV );',
          // flare
          '} else {',
          'float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;',
          'visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;',
          'visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;',
          'visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;',
          'visibility = ( 1.0 - visibility / 4.0 );',
          'vec4 texture = texture2D( map, vUV );',
          'texture.a *= opacity * visibility;',
          'gl_FragColor = texture;',
          'gl_FragColor.rgb *= color;',
          '}',
          '}'
        ].join('\n')
      };
    }
    program = createProgram(shader);
    attributes = {
      vertex: gl.getAttribLocation(program, 'position'),
      uv: gl.getAttribLocation(program, 'uv')
    };
    uniforms = {
      renderType: gl.getUniformLocation(program, 'renderType'),
      map: gl.getUniformLocation(program, 'map'),
      occlusionMap: gl.getUniformLocation(program, 'occlusionMap'),
      opacity: gl.getUniformLocation(program, 'opacity'),
      color: gl.getUniformLocation(program, 'color'),
      scale: gl.getUniformLocation(program, 'scale'),
      rotation: gl.getUniformLocation(program, 'rotation'),
      screenPosition: gl.getUniformLocation(program, 'screenPosition')
    };
  }
  /*
  * Render lens flares
  * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
  *         reads these back and calculates occlusion.
  */
  this.render = function (scene, camera, viewport) {
    if (flares.length === 0)
      return;
    var tempPosition = new THREE.Vector3();
    var invAspect = viewport.w / viewport.z, halfViewportWidth = viewport.z * 0.5, halfViewportHeight = viewport.w * 0.5;
    var size = 16 / viewport.w, scale = new THREE.Vector2(size * invAspect, size);
    var screenPosition = new THREE.Vector3(1, 1, 0), screenPositionPixels = new THREE.Vector2(1, 1);
    if (program === undefined) {
      init();
    }
    gl.useProgram(program);
    state.initAttributes();
    state.enableAttribute(attributes.vertex);
    state.enableAttribute(attributes.uv);
    state.disableUnusedAttributes();
    // loop through all lens flares to update their occlusion and positions
    // setup gl and common used attribs/uniforms
    gl.uniform1i(uniforms.occlusionMap, 0);
    gl.uniform1i(uniforms.map, 1);
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.vertexAttribPointer(attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0);
    gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
    state.disable(gl.CULL_FACE);
    state.setDepthWrite(false);
    for (var i = 0, l = flares.length; i < l; i++) {
      size = 16 / viewport.w;
      scale.set(size * invAspect, size);
      // calc object screen position
      var flare = flares[i];
      tempPosition.set(flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14]);
      tempPosition.applyMatrix4(camera.matrixWorldInverse);
      tempPosition.applyProjection(camera.projectionMatrix);
      // setup arrays for gl programs
      screenPosition.copy(tempPosition);
      screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
      screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;
      // screen cull
      if (hasVertexTexture || screenPositionPixels.x > 0 && screenPositionPixels.x < viewport.z && screenPositionPixels.y > 0 && screenPositionPixels.y < viewport.w) {
        // save current RGB to temp texture
        state.activeTexture(gl.TEXTURE0);
        state.bindTexture(gl.TEXTURE_2D, null);
        state.activeTexture(gl.TEXTURE1);
        state.bindTexture(gl.TEXTURE_2D, tempTexture);
        gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, viewport.x + screenPositionPixels.x - 8, viewport.y + screenPositionPixels.y - 8, 16, 16, 0);
        // render pink quad
        gl.uniform1i(uniforms.renderType, 0);
        gl.uniform2f(uniforms.scale, scale.x, scale.y);
        gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
        state.disable(gl.BLEND);
        state.enable(gl.DEPTH_TEST);
        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        // copy result to occlusionMap
        state.activeTexture(gl.TEXTURE0);
        state.bindTexture(gl.TEXTURE_2D, occlusionTexture);
        gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, viewport.x + screenPositionPixels.x - 8, viewport.y + screenPositionPixels.y - 8, 16, 16, 0);
        // restore graphics
        gl.uniform1i(uniforms.renderType, 1);
        state.disable(gl.DEPTH_TEST);
        state.activeTexture(gl.TEXTURE1);
        state.bindTexture(gl.TEXTURE_2D, tempTexture);
        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        // update object positions
        flare.positionScreen.copy(screenPosition);
        if (flare.customUpdateCallback) {
          flare.customUpdateCallback(flare);
        } else {
          flare.updateLensFlares();
        }
        // render flares
        gl.uniform1i(uniforms.renderType, 2);
        state.enable(gl.BLEND);
        for (var j = 0, jl = flare.lensFlares.length; j < jl; j++) {
          var sprite = flare.lensFlares[j];
          if (sprite.opacity > 0.001 && sprite.scale > 0.001) {
            screenPosition.x = sprite.x;
            screenPosition.y = sprite.y;
            screenPosition.z = sprite.z;
            size = sprite.size * sprite.scale / viewport.w;
            scale.x = size * invAspect;
            scale.y = size;
            gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
            gl.uniform2f(uniforms.scale, scale.x, scale.y);
            gl.uniform1f(uniforms.rotation, sprite.rotation);
            gl.uniform1f(uniforms.opacity, sprite.opacity);
            gl.uniform3f(uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b);
            state.setBlending(sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst);
            renderer.setTexture(sprite.texture, 1);
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
          }
        }
      }
    }
    // restore gl
    state.enable(gl.CULL_FACE);
    state.enable(gl.DEPTH_TEST);
    state.setDepthWrite(true);
    renderer.resetGLState();
  };
  function createProgram(shader) {
    var program = gl.createProgram();
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    var prefix = 'precision ' + renderer.getPrecision() + ' float;\n';
    gl.shaderSource(fragmentShader, prefix + shader.fragmentShader);
    gl.shaderSource(vertexShader, prefix + shader.vertexShader);
    gl.compileShader(fragmentShader);
    gl.compileShader(vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.attachShader(program, vertexShader);
    gl.linkProgram(program);
    return program;
  }
};
// File:src/renderers/webgl/plugins/SpritePlugin.js
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */
THREE.SpritePlugin = function (renderer, sprites) {
  var gl = renderer.context;
  var state = renderer.state;
  var vertexBuffer, elementBuffer;
  var program, attributes, uniforms;
  var texture;
  // decompose matrixWorld
  var spritePosition = new THREE.Vector3();
  var spriteRotation = new THREE.Quaternion();
  var spriteScale = new THREE.Vector3();
  function init() {
    var vertices = new Float32Array([
      -0.5,
      -0.5,
      0,
      0,
      0.5,
      -0.5,
      1,
      0,
      0.5,
      0.5,
      1,
      1,
      -0.5,
      0.5,
      0,
      1
    ]);
    var faces = new Uint16Array([
      0,
      1,
      2,
      0,
      2,
      3
    ]);
    vertexBuffer = gl.createBuffer();
    elementBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
    program = createProgram();
    attributes = {
      position: gl.getAttribLocation(program, 'position'),
      uv: gl.getAttribLocation(program, 'uv')
    };
    uniforms = {
      uvOffset: gl.getUniformLocation(program, 'uvOffset'),
      uvScale: gl.getUniformLocation(program, 'uvScale'),
      rotation: gl.getUniformLocation(program, 'rotation'),
      scale: gl.getUniformLocation(program, 'scale'),
      color: gl.getUniformLocation(program, 'color'),
      map: gl.getUniformLocation(program, 'map'),
      opacity: gl.getUniformLocation(program, 'opacity'),
      modelViewMatrix: gl.getUniformLocation(program, 'modelViewMatrix'),
      projectionMatrix: gl.getUniformLocation(program, 'projectionMatrix'),
      fogType: gl.getUniformLocation(program, 'fogType'),
      fogDensity: gl.getUniformLocation(program, 'fogDensity'),
      fogNear: gl.getUniformLocation(program, 'fogNear'),
      fogFar: gl.getUniformLocation(program, 'fogFar'),
      fogColor: gl.getUniformLocation(program, 'fogColor'),
      alphaTest: gl.getUniformLocation(program, 'alphaTest')
    };
    var canvas = document.createElement('canvas');
    canvas.width = 8;
    canvas.height = 8;
    var context = canvas.getContext('2d');
    context.fillStyle = 'white';
    context.fillRect(0, 0, 8, 8);
    texture = new THREE.Texture(canvas);
    texture.needsUpdate = true;
  }
  this.render = function (scene, camera) {
    if (sprites.length === 0)
      return;
    // setup gl
    if (program === undefined) {
      init();
    }
    gl.useProgram(program);
    state.initAttributes();
    state.enableAttribute(attributes.position);
    state.enableAttribute(attributes.uv);
    state.disableUnusedAttributes();
    state.disable(gl.CULL_FACE);
    state.enable(gl.BLEND);
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, false, 2 * 8, 0);
    gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
    gl.uniformMatrix4fv(uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
    state.activeTexture(gl.TEXTURE0);
    gl.uniform1i(uniforms.map, 0);
    var oldFogType = 0;
    var sceneFogType = 0;
    var fog = scene.fog;
    if (fog) {
      gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);
      if (fog instanceof THREE.Fog) {
        gl.uniform1f(uniforms.fogNear, fog.near);
        gl.uniform1f(uniforms.fogFar, fog.far);
        gl.uniform1i(uniforms.fogType, 1);
        oldFogType = 1;
        sceneFogType = 1;
      } else if (fog instanceof THREE.FogExp2) {
        gl.uniform1f(uniforms.fogDensity, fog.density);
        gl.uniform1i(uniforms.fogType, 2);
        oldFogType = 2;
        sceneFogType = 2;
      }
    } else {
      gl.uniform1i(uniforms.fogType, 0);
      oldFogType = 0;
      sceneFogType = 0;
    }
    // update positions and sort
    for (var i = 0, l = sprites.length; i < l; i++) {
      var sprite = sprites[i];
      sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);
      sprite.z = -sprite.modelViewMatrix.elements[14];
    }
    sprites.sort(painterSortStable);
    // render all sprites
    var scale = [];
    for (var i = 0, l = sprites.length; i < l; i++) {
      var sprite = sprites[i];
      var material = sprite.material;
      gl.uniform1f(uniforms.alphaTest, material.alphaTest);
      gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements);
      sprite.matrixWorld.decompose(spritePosition, spriteRotation, spriteScale);
      scale[0] = spriteScale.x;
      scale[1] = spriteScale.y;
      var fogType = 0;
      if (scene.fog && material.fog) {
        fogType = sceneFogType;
      }
      if (oldFogType !== fogType) {
        gl.uniform1i(uniforms.fogType, fogType);
        oldFogType = fogType;
      }
      if (material.map !== null) {
        gl.uniform2f(uniforms.uvOffset, material.map.offset.x, material.map.offset.y);
        gl.uniform2f(uniforms.uvScale, material.map.repeat.x, material.map.repeat.y);
      } else {
        gl.uniform2f(uniforms.uvOffset, 0, 0);
        gl.uniform2f(uniforms.uvScale, 1, 1);
      }
      gl.uniform1f(uniforms.opacity, material.opacity);
      gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b);
      gl.uniform1f(uniforms.rotation, material.rotation);
      gl.uniform2fv(uniforms.scale, scale);
      state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);
      state.setDepthTest(material.depthTest);
      state.setDepthWrite(material.depthWrite);
      if (material.map && material.map.image && material.map.image.width) {
        renderer.setTexture(material.map, 0);
      } else {
        renderer.setTexture(texture, 0);
      }
      gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
    }
    // restore gl
    state.enable(gl.CULL_FACE);
    renderer.resetGLState();
  };
  function createProgram() {
    var program = gl.createProgram();
    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(vertexShader, [
      'precision ' + renderer.getPrecision() + ' float;',
      'uniform mat4 modelViewMatrix;',
      'uniform mat4 projectionMatrix;',
      'uniform float rotation;',
      'uniform vec2 scale;',
      'uniform vec2 uvOffset;',
      'uniform vec2 uvScale;',
      'attribute vec2 position;',
      'attribute vec2 uv;',
      'varying vec2 vUV;',
      'void main() {',
      'vUV = uvOffset + uv * uvScale;',
      'vec2 alignedPosition = position * scale;',
      'vec2 rotatedPosition;',
      'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
      'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',
      'vec4 finalPosition;',
      'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
      'finalPosition.xy += rotatedPosition;',
      'finalPosition = projectionMatrix * finalPosition;',
      'gl_Position = finalPosition;',
      '}'
    ].join('\n'));
    gl.shaderSource(fragmentShader, [
      'precision ' + renderer.getPrecision() + ' float;',
      'uniform vec3 color;',
      'uniform sampler2D map;',
      'uniform float opacity;',
      'uniform int fogType;',
      'uniform vec3 fogColor;',
      'uniform float fogDensity;',
      'uniform float fogNear;',
      'uniform float fogFar;',
      'uniform float alphaTest;',
      'varying vec2 vUV;',
      'void main() {',
      'vec4 texture = texture2D( map, vUV );',
      'if ( texture.a < alphaTest ) discard;',
      'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',
      'if ( fogType > 0 ) {',
      'float depth = gl_FragCoord.z / gl_FragCoord.w;',
      'float fogFactor = 0.0;',
      'if ( fogType == 1 ) {',
      'fogFactor = smoothstep( fogNear, fogFar, depth );',
      '} else {',
      'const float LOG2 = 1.442695;',
      'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
      'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',
      '}',
      'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',
      '}',
      '}'
    ].join('\n'));
    gl.compileShader(vertexShader);
    gl.compileShader(fragmentShader);
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    return program;
  }
  function painterSortStable(a, b) {
    if (a.renderOrder !== b.renderOrder) {
      return a.renderOrder - b.renderOrder;
    } else if (a.z !== b.z) {
      return b.z - a.z;
    } else {
      return b.id - a.id;
    }
  }
};
// File:src/Three.Legacy.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
Object.defineProperties(THREE.Box2.prototype, {
  empty: {
    value: function () {
      console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
      return this.isEmpty();
    }
  },
  isIntersectionBox: {
    value: function (box) {
      console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
      return this.intersectsBox(box);
    }
  }
});
Object.defineProperties(THREE.Box3.prototype, {
  empty: {
    value: function () {
      console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
      return this.isEmpty();
    }
  },
  isIntersectionBox: {
    value: function (box) {
      console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
      return this.intersectsBox(box);
    }
  },
  isIntersectionSphere: {
    value: function (sphere) {
      console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
      return this.intersectsSphere(sphere);
    }
  }
});
Object.defineProperties(THREE.Matrix3.prototype, {
  multiplyVector3: {
    value: function (vector) {
      console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
      return vector.applyMatrix3(this);
    }
  },
  multiplyVector3Array: {
    value: function (a) {
      console.warn('THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');
      return this.applyToVector3Array(a);
    }
  }
});
Object.defineProperties(THREE.Matrix4.prototype, {
  extractPosition: {
    value: function (m) {
      console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
      return this.copyPosition(m);
    }
  },
  setRotationFromQuaternion: {
    value: function (q) {
      console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
      return this.makeRotationFromQuaternion(q);
    }
  },
  multiplyVector3: {
    value: function (vector) {
      console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.');
      return vector.applyProjection(this);
    }
  },
  multiplyVector4: {
    value: function (vector) {
      console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
      return vector.applyMatrix4(this);
    }
  },
  multiplyVector3Array: {
    value: function (a) {
      console.warn('THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');
      return this.applyToVector3Array(a);
    }
  },
  rotateAxis: {
    value: function (v) {
      console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
      v.transformDirection(this);
    }
  },
  crossVector: {
    value: function (vector) {
      console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
      return vector.applyMatrix4(this);
    }
  },
  translate: {
    value: function (v) {
      console.error('THREE.Matrix4: .translate() has been removed.');
    }
  },
  rotateX: {
    value: function (angle) {
      console.error('THREE.Matrix4: .rotateX() has been removed.');
    }
  },
  rotateY: {
    value: function (angle) {
      console.error('THREE.Matrix4: .rotateY() has been removed.');
    }
  },
  rotateZ: {
    value: function (angle) {
      console.error('THREE.Matrix4: .rotateZ() has been removed.');
    }
  },
  rotateByAxis: {
    value: function (axis, angle) {
      console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
    }
  }
});
Object.defineProperties(THREE.Plane.prototype, {
  isIntersectionLine: {
    value: function (line) {
      console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
      return this.intersectsLine(line);
    }
  }
});
Object.defineProperties(THREE.Quaternion.prototype, {
  multiplyVector3: {
    value: function (vector) {
      console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
      return vector.applyQuaternion(this);
    }
  }
});
Object.defineProperties(THREE.Ray.prototype, {
  isIntersectionBox: {
    value: function (box) {
      console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
      return this.intersectsBox(box);
    }
  },
  isIntersectionPlane: {
    value: function (plane) {
      console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
      return this.intersectsPlane(plane);
    }
  },
  isIntersectionSphere: {
    value: function (sphere) {
      console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
      return this.intersectsSphere(sphere);
    }
  }
});
Object.defineProperties(THREE.Vector3.prototype, {
  setEulerFromRotationMatrix: {
    value: function () {
      console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
    }
  },
  setEulerFromQuaternion: {
    value: function () {
      console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
    }
  },
  getPositionFromMatrix: {
    value: function (m) {
      console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
      return this.setFromMatrixPosition(m);
    }
  },
  getScaleFromMatrix: {
    value: function (m) {
      console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
      return this.setFromMatrixScale(m);
    }
  },
  getColumnFromMatrix: {
    value: function (index, matrix) {
      console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
      return this.setFromMatrixColumn(index, matrix);
    }
  }
});
//
THREE.Face4 = function (a, b, c, d, normal, color, materialIndex) {
  console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
  return new THREE.Face3(a, b, c, normal, color, materialIndex);
};
THREE.Vertex = function (x, y, z) {
  console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
  return new THREE.Vector3(x, y, z);
};
//
Object.defineProperties(THREE.Object3D.prototype, {
  eulerOrder: {
    get: function () {
      console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
      return this.rotation.order;
    },
    set: function (value) {
      console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
      this.rotation.order = value;
    }
  },
  getChildByName: {
    value: function (name) {
      console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
      return this.getObjectByName(name);
    }
  },
  renderDepth: {
    set: function (value) {
      console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
    }
  },
  translate: {
    value: function (distance, axis) {
      console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
      return this.translateOnAxis(axis, distance);
    }
  },
  useQuaternion: {
    get: function () {
      console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
    },
    set: function (value) {
      console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
    }
  }
});
//
Object.defineProperties(THREE, {
  PointCloud: {
    value: function (geometry, material) {
      console.warn('THREE.PointCloud has been renamed to THREE.Points.');
      return new THREE.Points(geometry, material);
    }
  },
  ParticleSystem: {
    value: function (geometry, material) {
      console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
      return new THREE.Points(geometry, material);
    }
  }
});
//
Object.defineProperties(THREE.Light.prototype, {
  onlyShadow: {
    set: function (value) {
      console.warn('THREE.Light: .onlyShadow has been removed.');
    }
  },
  shadowCameraFov: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
      this.shadow.camera.fov = value;
    }
  },
  shadowCameraLeft: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
      this.shadow.camera.left = value;
    }
  },
  shadowCameraRight: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
      this.shadow.camera.right = value;
    }
  },
  shadowCameraTop: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
      this.shadow.camera.top = value;
    }
  },
  shadowCameraBottom: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
      this.shadow.camera.bottom = value;
    }
  },
  shadowCameraNear: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
      this.shadow.camera.near = value;
    }
  },
  shadowCameraFar: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
      this.shadow.camera.far = value;
    }
  },
  shadowCameraVisible: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');
    }
  },
  shadowBias: {
    set: function (value) {
      console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
      this.shadow.bias = value;
    }
  },
  shadowDarkness: {
    set: function (value) {
      console.warn('THREE.Light: .shadowDarkness has been removed.');
    }
  },
  shadowMapWidth: {
    set: function (value) {
      console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
      this.shadow.mapSize.width = value;
    }
  },
  shadowMapHeight: {
    set: function (value) {
      console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
      this.shadow.mapSize.height = value;
    }
  }
});
//
Object.defineProperties(THREE.BufferAttribute.prototype, {
  length: {
    get: function () {
      console.warn('THREE.BufferAttribute: .length has been deprecated. Please use .count.');
      return this.array.length;
    }
  }
});
Object.defineProperties(THREE.BufferGeometry.prototype, {
  drawcalls: {
    get: function () {
      console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
      return this.groups;
    }
  },
  offsets: {
    get: function () {
      console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
      return this.groups;
    }
  },
  addIndex: {
    value: function (index) {
      console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
      this.setIndex(index);
    }
  },
  addDrawCall: {
    value: function (start, count, indexOffset) {
      if (indexOffset !== undefined) {
        console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
      }
      console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
      this.addGroup(start, count);
    }
  },
  clearDrawCalls: {
    value: function () {
      console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
      this.clearGroups();
    }
  },
  computeTangents: {
    value: function () {
      console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');
    }
  },
  computeOffsets: {
    value: function () {
      console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
    }
  }
});
//
Object.defineProperties(THREE.Material.prototype, {
  wrapAround: {
    get: function () {
      console.warn('THREE.' + this.type + ': .wrapAround has been removed.');
    },
    set: function (value) {
      console.warn('THREE.' + this.type + ': .wrapAround has been removed.');
    }
  },
  wrapRGB: {
    get: function () {
      console.warn('THREE.' + this.type + ': .wrapRGB has been removed.');
      return new THREE.Color();
    }
  }
});
Object.defineProperties(THREE, {
  PointCloudMaterial: {
    value: function (parameters) {
      console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
      return new THREE.PointsMaterial(parameters);
    }
  },
  ParticleBasicMaterial: {
    value: function (parameters) {
      console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
      return new THREE.PointsMaterial(parameters);
    }
  },
  ParticleSystemMaterial: {
    value: function (parameters) {
      console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
      return new THREE.PointsMaterial(parameters);
    }
  }
});
Object.defineProperties(THREE.MeshPhongMaterial.prototype, {
  metal: {
    get: function () {
      console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');
      return false;
    },
    set: function (value) {
      console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');
    }
  }
});
Object.defineProperties(THREE.ShaderMaterial.prototype, {
  derivatives: {
    get: function () {
      console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
      return this.extensions.derivatives;
    },
    set: function (value) {
      console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
      this.extensions.derivatives = value;
    }
  }
});
//
Object.defineProperties(THREE.WebGLRenderer.prototype, {
  supportsFloatTextures: {
    value: function () {
      console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
      return this.extensions.get('OES_texture_float');
    }
  },
  supportsHalfFloatTextures: {
    value: function () {
      console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
      return this.extensions.get('OES_texture_half_float');
    }
  },
  supportsStandardDerivatives: {
    value: function () {
      console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
      return this.extensions.get('OES_standard_derivatives');
    }
  },
  supportsCompressedTextureS3TC: {
    value: function () {
      console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
      return this.extensions.get('WEBGL_compressed_texture_s3tc');
    }
  },
  supportsCompressedTexturePVRTC: {
    value: function () {
      console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
      return this.extensions.get('WEBGL_compressed_texture_pvrtc');
    }
  },
  supportsBlendMinMax: {
    value: function () {
      console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
      return this.extensions.get('EXT_blend_minmax');
    }
  },
  supportsVertexTextures: {
    value: function () {
      return this.capabilities.vertexTextures;
    }
  },
  supportsInstancedArrays: {
    value: function () {
      console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
      return this.extensions.get('ANGLE_instanced_arrays');
    }
  },
  enableScissorTest: {
    value: function (boolean) {
      console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
      this.setScissorTest(boolean);
    }
  },
  initMaterial: {
    value: function () {
      console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
    }
  },
  addPrePlugin: {
    value: function () {
      console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
    }
  },
  addPostPlugin: {
    value: function () {
      console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
    }
  },
  updateShadowMap: {
    value: function () {
      console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
    }
  },
  shadowMapEnabled: {
    get: function () {
      return this.shadowMap.enabled;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
      this.shadowMap.enabled = value;
    }
  },
  shadowMapType: {
    get: function () {
      return this.shadowMap.type;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
      this.shadowMap.type = value;
    }
  },
  shadowMapCullFace: {
    get: function () {
      return this.shadowMap.cullFace;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.');
      this.shadowMap.cullFace = value;
    }
  }
});
//
Object.defineProperties(THREE.WebGLRenderTarget.prototype, {
  wrapS: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
      return this.texture.wrapS;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
      this.texture.wrapS = value;
    }
  },
  wrapT: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
      return this.texture.wrapT;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
      this.texture.wrapT = value;
    }
  },
  magFilter: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
      return this.texture.magFilter;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
      this.texture.magFilter = value;
    }
  },
  minFilter: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
      return this.texture.minFilter;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
      this.texture.minFilter = value;
    }
  },
  anisotropy: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
      return this.texture.anisotropy;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
      this.texture.anisotropy = value;
    }
  },
  offset: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
      return this.texture.offset;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
      this.texture.offset = value;
    }
  },
  repeat: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
      return this.texture.repeat;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
      this.texture.repeat = value;
    }
  },
  format: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
      return this.texture.format;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
      this.texture.format = value;
    }
  },
  type: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
      return this.texture.type;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
      this.texture.type = value;
    }
  },
  generateMipmaps: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
      return this.texture.generateMipmaps;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
      this.texture.generateMipmaps = value;
    }
  }
});
//
THREE.GeometryUtils = {
  merge: function (geometry1, geometry2, materialIndexOffset) {
    console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');
    var matrix;
    if (geometry2 instanceof THREE.Mesh) {
      geometry2.matrixAutoUpdate && geometry2.updateMatrix();
      matrix = geometry2.matrix;
      geometry2 = geometry2.geometry;
    }
    geometry1.merge(geometry2, matrix, materialIndexOffset);
  },
  center: function (geometry) {
    console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');
    return geometry.center();
  }
};
THREE.ImageUtils = {
  crossOrigin: undefined,
  loadTexture: function (url, mapping, onLoad, onError) {
    console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');
    var loader = new THREE.TextureLoader();
    loader.setCrossOrigin(this.crossOrigin);
    var texture = loader.load(url, onLoad, undefined, onError);
    if (mapping)
      texture.mapping = mapping;
    return texture;
  },
  loadTextureCube: function (urls, mapping, onLoad, onError) {
    console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');
    var loader = new THREE.CubeTextureLoader();
    loader.setCrossOrigin(this.crossOrigin);
    var texture = loader.load(urls, onLoad, undefined, onError);
    if (mapping)
      texture.mapping = mapping;
    return texture;
  },
  loadCompressedTexture: function () {
    console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
  },
  loadCompressedTextureCube: function () {
    console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
  }
};
//
THREE.Projector = function () {
  console.error('THREE.Projector has been moved to /examples/js/renderers/Projector.js.');
  this.projectVector = function (vector, camera) {
    console.warn('THREE.Projector: .projectVector() is now vector.project().');
    vector.project(camera);
  };
  this.unprojectVector = function (vector, camera) {
    console.warn('THREE.Projector: .unprojectVector() is now vector.unproject().');
    vector.unproject(camera);
  };
  this.pickingRay = function (vector, camera) {
    console.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');
  };
};
//
THREE.CanvasRenderer = function () {
  console.error('THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js');
  this.domElement = document.createElement('canvas');
  this.clear = function () {
  };
  this.render = function () {
  };
  this.setClearColor = function () {
  };
  this.setSize = function () {
  };
};
//
THREE.MeshFaceMaterial = THREE.MultiMaterial;
// File:src/extras/geometries/CylinderBufferGeometry.js
/**
 * @author Mugen87 / https://github.com/Mugen87
 */
THREE.CylinderBufferGeometry = function (radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  THREE.BufferGeometry.call(this);
  this.type = 'CylinderBufferGeometry';
  this.parameters = {
    radiusTop: radiusTop,
    radiusBottom: radiusBottom,
    height: height,
    radialSegments: radialSegments,
    heightSegments: heightSegments,
    openEnded: openEnded,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  radiusTop = radiusTop !== undefined ? radiusTop : 20;
  radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
  height = height !== undefined ? height : 100;
  radialSegments = Math.floor(radialSegments) || 8;
  heightSegments = Math.floor(heightSegments) || 1;
  openEnded = openEnded !== undefined ? openEnded : false;
  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;
  // used to calculate buffer length
  var vertexCount = calculateVertexCount();
  var indexCount = calculateIndexCount();
  // buffers
  var indices = new THREE.BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
  var vertices = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
  var normals = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
  var uvs = new THREE.BufferAttribute(new Float32Array(vertexCount * 2), 2);
  // helper variables
  var index = 0, indexOffset = 0, indexArray = [], halfHeight = height / 2;
  // generate geometry
  generateTorso();
  if (openEnded === false) {
    if (radiusTop > 0) {
      generateCap(true);
    }
    if (radiusBottom > 0) {
      generateCap(false);
    }
  }
  // build geometry
  this.setIndex(indices);
  this.addAttribute('position', vertices);
  this.addAttribute('normal', normals);
  this.addAttribute('uv', uvs);
  // helper functions
  function calculateVertexCount() {
    var count = (radialSegments + 1) * (heightSegments + 1);
    if (openEnded === false) {
      count += (radialSegments + 1) * 2 + radialSegments * 2;
    }
    return count;
  }
  function calculateIndexCount() {
    var count = radialSegments * heightSegments * 2 * 3;
    if (openEnded === false) {
      count += radialSegments * 2 * 3;
    }
    return count;
  }
  function generateTorso() {
    var x, y;
    var normal = new THREE.Vector3();
    var vertex = new THREE.Vector3();
    // this will be used to calculate the normal
    var tanTheta = (radiusBottom - radiusTop) / height;
    // generate vertices, normals and uvs
    for (y = 0; y <= heightSegments; y++) {
      var indexRow = [];
      var v = y / heightSegments;
      // calculate the radius of the current row
      var radius = v * (radiusBottom - radiusTop) + radiusTop;
      for (x = 0; x <= radialSegments; x++) {
        var u = x / radialSegments;
        // vertex
        vertex.x = radius * Math.sin(u * thetaLength + thetaStart);
        vertex.y = -v * height + halfHeight;
        vertex.z = radius * Math.cos(u * thetaLength + thetaStart);
        vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
        // normal
        normal.copy(vertex);
        // handle special case if radiusTop/radiusBottom is zero
        if (radiusTop === 0 && y === 0 || radiusBottom === 0 && y === heightSegments) {
          normal.x = Math.sin(u * thetaLength + thetaStart);
          normal.z = Math.cos(u * thetaLength + thetaStart);
        }
        normal.setY(Math.sqrt(normal.x * normal.x + normal.z * normal.z) * tanTheta).normalize();
        normals.setXYZ(index, normal.x, normal.y, normal.z);
        // uv
        uvs.setXY(index, u, 1 - v);
        // save index of vertex in respective row
        indexRow.push(index);
        // increase index
        index++;
      }
      // now save vertices of the row in our index array
      indexArray.push(indexRow);
    }
    // generate indices
    for (x = 0; x < radialSegments; x++) {
      for (y = 0; y < heightSegments; y++) {
        // we use the index array to access the correct indices
        var i1 = indexArray[y][x];
        var i2 = indexArray[y + 1][x];
        var i3 = indexArray[y + 1][x + 1];
        var i4 = indexArray[y][x + 1];
        // face one
        indices.setX(indexOffset, i1);
        indexOffset++;
        indices.setX(indexOffset, i2);
        indexOffset++;
        indices.setX(indexOffset, i4);
        indexOffset++;
        // face two
        indices.setX(indexOffset, i2);
        indexOffset++;
        indices.setX(indexOffset, i3);
        indexOffset++;
        indices.setX(indexOffset, i4);
        indexOffset++;
      }
    }
  }
  function generateCap(top) {
    var x, centerIndexStart, centerIndexEnd;
    var uv = new THREE.Vector2();
    var vertex = new THREE.Vector3();
    var radius = top === true ? radiusTop : radiusBottom;
    var sign = top === true ? 1 : -1;
    // save the index of the first center vertex
    centerIndexStart = index;
    // first we generate the center vertex data of the cap.
    // because the geometry needs one set of uvs per face,
    // we must generate a center vertex per face/segment
    for (x = 1; x <= radialSegments; x++) {
      // vertex
      vertices.setXYZ(index, 0, halfHeight * sign, 0);
      // normal
      normals.setXYZ(index, 0, sign, 0);
      // uv
      if (top === true) {
        uv.x = x / radialSegments;
        uv.y = 0;
      } else {
        uv.x = (x - 1) / radialSegments;
        uv.y = 1;
      }
      uvs.setXY(index, uv.x, uv.y);
      // increase index
      index++;
    }
    // save the index of the last center vertex
    centerIndexEnd = index;
    // now we generate the surrounding vertices, normals and uvs
    for (x = 0; x <= radialSegments; x++) {
      var u = x / radialSegments;
      // vertex
      vertex.x = radius * Math.sin(u * thetaLength + thetaStart);
      vertex.y = halfHeight * sign;
      vertex.z = radius * Math.cos(u * thetaLength + thetaStart);
      vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
      // normal
      normals.setXYZ(index, 0, sign, 0);
      // uv
      uvs.setXY(index, u, top === true ? 1 : 0);
      // increase index
      index++;
    }
    // generate indices
    for (x = 0; x < radialSegments; x++) {
      var c = centerIndexStart + x;
      var i = centerIndexEnd + x;
      if (top === true) {
        // face top
        indices.setX(indexOffset, i);
        indexOffset++;
        indices.setX(indexOffset, i + 1);
        indexOffset++;
        indices.setX(indexOffset, c);
        indexOffset++;
      } else {
        // face bottom
        indices.setX(indexOffset, i + 1);
        indexOffset++;
        indices.setX(indexOffset, i);
        indexOffset++;
        indices.setX(indexOffset, c);
        indexOffset++;
      }
    }
  }
};
THREE.CylinderBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.CylinderBufferGeometry.prototype.constructor = THREE.CylinderBufferGeometry;
// File:src/extras/geometries/CylinderGeometry.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
THREE.CylinderGeometry = function (radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  THREE.Geometry.call(this);
  this.type = 'CylinderGeometry';
  this.parameters = {
    radiusTop: radiusTop,
    radiusBottom: radiusBottom,
    height: height,
    radialSegments: radialSegments,
    heightSegments: heightSegments,
    openEnded: openEnded,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  this.fromBufferGeometry(new THREE.CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
  this.mergeVertices();
};
THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;
// File:src/extras/geometries/PlaneGeometry.js
/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */
THREE.PlaneGeometry = function (width, height, widthSegments, heightSegments) {
  THREE.Geometry.call(this);
  this.type = 'PlaneGeometry';
  this.parameters = {
    width: width,
    height: height,
    widthSegments: widthSegments,
    heightSegments: heightSegments
  };
  this.fromBufferGeometry(new THREE.PlaneBufferGeometry(width, height, widthSegments, heightSegments));
};
THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;
// File:src/extras/geometries/PlaneBufferGeometry.js
/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */
THREE.PlaneBufferGeometry = function (width, height, widthSegments, heightSegments) {
  THREE.BufferGeometry.call(this);
  this.type = 'PlaneBufferGeometry';
  this.parameters = {
    width: width,
    height: height,
    widthSegments: widthSegments,
    heightSegments: heightSegments
  };
  var width_half = width / 2;
  var height_half = height / 2;
  var gridX = Math.floor(widthSegments) || 1;
  var gridY = Math.floor(heightSegments) || 1;
  var gridX1 = gridX + 1;
  var gridY1 = gridY + 1;
  var segment_width = width / gridX;
  var segment_height = height / gridY;
  var vertices = new Float32Array(gridX1 * gridY1 * 3);
  var normals = new Float32Array(gridX1 * gridY1 * 3);
  var uvs = new Float32Array(gridX1 * gridY1 * 2);
  var offset = 0;
  var offset2 = 0;
  for (var iy = 0; iy < gridY1; iy++) {
    var y = iy * segment_height - height_half;
    for (var ix = 0; ix < gridX1; ix++) {
      var x = ix * segment_width - width_half;
      vertices[offset] = x;
      vertices[offset + 1] = -y;
      normals[offset + 2] = 1;
      uvs[offset2] = ix / gridX;
      uvs[offset2 + 1] = 1 - iy / gridY;
      offset += 3;
      offset2 += 2;
    }
  }
  offset = 0;
  var indices = new (vertices.length / 3 > 65535 ? Uint32Array : Uint16Array)(gridX * gridY * 6);
  for (var iy = 0; iy < gridY; iy++) {
    for (var ix = 0; ix < gridX; ix++) {
      var a = ix + gridX1 * iy;
      var b = ix + gridX1 * (iy + 1);
      var c = ix + 1 + gridX1 * (iy + 1);
      var d = ix + 1 + gridX1 * iy;
      indices[offset] = a;
      indices[offset + 1] = b;
      indices[offset + 2] = d;
      indices[offset + 3] = b;
      indices[offset + 4] = c;
      indices[offset + 5] = d;
      offset += 6;
    }
  }
  this.setIndex(new THREE.BufferAttribute(indices, 1));
  this.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
  this.addAttribute('normal', new THREE.BufferAttribute(normals, 3));
  this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));
};
THREE.PlaneBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;
// File:src/extras/geometries/SphereGeometry.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
THREE.SphereGeometry = function (radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
  THREE.Geometry.call(this);
  this.type = 'SphereGeometry';
  this.parameters = {
    radius: radius,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    phiStart: phiStart,
    phiLength: phiLength,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  this.fromBufferGeometry(new THREE.SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
};
THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;
// File:src/extras/geometries/SphereBufferGeometry.js
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * based on THREE.SphereGeometry
 */
THREE.SphereBufferGeometry = function (radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
  THREE.BufferGeometry.call(this);
  this.type = 'SphereBufferGeometry';
  this.parameters = {
    radius: radius,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    phiStart: phiStart,
    phiLength: phiLength,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  radius = radius || 50;
  widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
  heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
  phiStart = phiStart !== undefined ? phiStart : 0;
  phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
  var thetaEnd = thetaStart + thetaLength;
  var vertexCount = (widthSegments + 1) * (heightSegments + 1);
  var positions = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
  var normals = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
  var uvs = new THREE.BufferAttribute(new Float32Array(vertexCount * 2), 2);
  var index = 0, vertices = [], normal = new THREE.Vector3();
  for (var y = 0; y <= heightSegments; y++) {
    var verticesRow = [];
    var v = y / heightSegments;
    for (var x = 0; x <= widthSegments; x++) {
      var u = x / widthSegments;
      var px = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
      var py = radius * Math.cos(thetaStart + v * thetaLength);
      var pz = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
      normal.set(px, py, pz).normalize();
      positions.setXYZ(index, px, py, pz);
      normals.setXYZ(index, normal.x, normal.y, normal.z);
      uvs.setXY(index, u, 1 - v);
      verticesRow.push(index);
      index++;
    }
    vertices.push(verticesRow);
  }
  var indices = [];
  for (var y = 0; y < heightSegments; y++) {
    for (var x = 0; x < widthSegments; x++) {
      var v1 = vertices[y][x + 1];
      var v2 = vertices[y][x];
      var v3 = vertices[y + 1][x];
      var v4 = vertices[y + 1][x + 1];
      if (y !== 0 || thetaStart > 0)
        indices.push(v1, v2, v4);
      if (y !== heightSegments - 1 || thetaEnd < Math.PI)
        indices.push(v2, v3, v4);
    }
  }
  this.setIndex(new (positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute)(indices, 1));
  this.addAttribute('position', positions);
  this.addAttribute('normal', normals);
  this.addAttribute('uv', uvs);
  this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
};
THREE.SphereBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;
// File:src/extras/helpers/AxisHelper.js
/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */
THREE.AxisHelper = function (size) {
  size = size || 1;
  var vertices = new Float32Array([
    0,
    0,
    0,
    size,
    0,
    0,
    0,
    0,
    0,
    0,
    size,
    0,
    0,
    0,
    0,
    0,
    0,
    size
  ]);
  var colors = new Float32Array([
    1,
    0,
    0,
    1,
    0.6,
    0,
    0,
    1,
    0,
    0.6,
    1,
    0,
    0,
    0,
    1,
    0,
    0.6,
    1
  ]);
  var geometry = new THREE.BufferGeometry();
  geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
  geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3));
  var material = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });
  THREE.LineSegments.call(this, geometry, material);
};
THREE.AxisHelper.prototype = Object.create(THREE.LineSegments.prototype);
THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;
// File:src/extras/objects/ImmediateRenderObject.js
/**
 * @author alteredq / http://alteredqualia.com/
 */
THREE.ImmediateRenderObject = function (material) {
  THREE.Object3D.call(this);
  this.material = material;
  this.render = function (renderCallback) {
  };
};
THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype);
THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;
dat = {};
(function (root, factory) {
  /* CommonJS */
  //  if (typeof module == 'object' && module.exports) module.exports = factory()
  /* AMD module */
  /*  else*/
  if (true)
    Spinner = function () {
      return typeof factory === 'function' ? factory() : factory;
    }();
  else
    root.Spinner = factory();
}(this, function () {
  'use strict';
  var prefixes = [
      'webkit',
      'Moz',
      'ms',
      'O'
    ]  /* Vendor prefixes */, animations = {}  /* Animation rules keyed by their name */, useCssAnimations, sheet;
  /* A stylesheet to hold the @keyframe or VML rules. */
  /**
   * Utility function to create elements. If no tag name is given,
   * a DIV is created. Optionally properties can be passed.
   */
  function createEl(tag, prop) {
    var el = document.createElement(tag || 'div'), n;
    for (n in prop)
      el[n] = prop[n];
    return el;
  }
  /**
   * Appends children and returns the parent.
   */
  function ins(parent) {
    for (var i = 1, n = arguments.length; i < n; i++) {
      parent.appendChild(arguments[i]);
    }
    return parent;
  }
  /**
   * Creates an opacity keyframe animation rule and returns its name.
   * Since most mobile Webkits have timing issues with animation-delay,
   * we create separate rules for each line/segment.
   */
  function addAnimation(alpha, trail, i, lines) {
    var name = [
        'opacity',
        trail,
        ~~(alpha * 100),
        i,
        lines
      ].join('-'), start = 0.01 + i / lines * 100, z = Math.max(1 - (1 - alpha) / trail * (100 - start), alpha), prefix = useCssAnimations.substring(0, useCssAnimations.indexOf('Animation')).toLowerCase(), pre = prefix && '-' + prefix + '-' || '';
    if (!animations[name]) {
      sheet.insertRule('@' + pre + 'keyframes ' + name + '{' + '0%{opacity:' + z + '}' + start + '%{opacity:' + alpha + '}' + (start + 0.01) + '%{opacity:1}' + (start + trail) % 100 + '%{opacity:' + alpha + '}' + '100%{opacity:' + z + '}' + '}', sheet.cssRules.length);
      animations[name] = 1;
    }
    return name;
  }
  /**
   * Tries various vendor prefixes and returns the first supported property.
   */
  function vendor(el, prop) {
    var s = el.style, pp, i;
    prop = prop.charAt(0).toUpperCase() + prop.slice(1);
    if (s[prop] !== undefined)
      return prop;
    for (i = 0; i < prefixes.length; i++) {
      pp = prefixes[i] + prop;
      if (s[pp] !== undefined)
        return pp;
    }
  }
  /**
   * Sets multiple style properties at once.
   */
  function css(el, prop) {
    for (var n in prop) {
      el.style[vendor(el, n) || n] = prop[n];
    }
    return el;
  }
  /**
   * Fills in default values.
   */
  function merge(obj) {
    for (var i = 1; i < arguments.length; i++) {
      var def = arguments[i];
      for (var n in def) {
        if (obj[n] === undefined)
          obj[n] = def[n];
      }
    }
    return obj;
  }
  /**
   * Returns the line color from the given string or array.
   */
  function getColor(color, idx) {
    return typeof color == 'string' ? color : color[idx % color.length];
  }
  // Built-in defaults
  var defaults = {
    lines: 12  // The number of lines to draw
,
    length: 7  // The length of each line
,
    width: 5  // The line thickness
,
    radius: 10  // The radius of the inner circle
,
    scale: 1  // Scales overall size of the spinner
,
    corners: 1  // Roundness (0..1)
,
    color: '#000'  // #rgb or #rrggbb
,
    opacity: 1 / 4  // Opacity of the lines
,
    rotate: 0  // Rotation offset
,
    direction: 1  // 1: clockwise, -1: counterclockwise
,
    speed: 1  // Rounds per second
,
    trail: 100  // Afterglow percentage
,
    fps: 20  // Frames per second when using setTimeout()
,
    zIndex: 2000000000  // Use a high z-index by default
,
    className: 'spinner'  // CSS class to assign to the element
,
    top: '50%'  // center vertically
,
    left: '50%'  // center horizontally
,
    shadow: false  // Whether to render a shadow
,
    hwaccel: false  // Whether to use hardware acceleration (might be buggy)
,
    position: 'absolute'  // Element positioning
  };
  /** The constructor */
  function Spinner(o) {
    this.opts = merge(o || {}, Spinner.defaults, defaults);
  }
  // Global defaults that override the built-ins:
  Spinner.defaults = {};
  merge(Spinner.prototype, {
    /**
     * Adds the spinner to the given target element. If this instance is already
     * spinning, it is automatically removed from its previous target b calling
     * stop() internally.
     */
    spin: function (target) {
      this.stop();
      var self = this, o = self.opts, el = self.el = createEl(null, { className: o.className });
      css(el, {
        position: o.position,
        width: 0,
        zIndex: o.zIndex,
        left: o.left,
        top: o.top
      });
      if (target) {
        target.insertBefore(el, target.firstChild || null);
      }
      el.setAttribute('role', 'progressbar');
      self.lines(el, self.opts);
      if (!useCssAnimations) {
        // No CSS animation support, use setTimeout() instead
        var i = 0, start = (o.lines - 1) * (1 - o.direction) / 2, alpha, fps = o.fps, f = fps / o.speed, ostep = (1 - o.opacity) / (f * o.trail / 100), astep = f / o.lines;
        (function anim() {
          i++;
          for (var j = 0; j < o.lines; j++) {
            alpha = Math.max(1 - (i + (o.lines - j) * astep) % f * ostep, o.opacity);
            self.opacity(el, j * o.direction + start, alpha, o);
          }
          self.timeout = self.el && setTimeout(anim, ~~(1000 / fps));
        }());
      }
      return self;
    }  /**
        * Stops and removes the Spinner.
        */,
    stop: function () {
      var el = this.el;
      if (el) {
        clearTimeout(this.timeout);
        if (el.parentNode)
          el.parentNode.removeChild(el);
        this.el = undefined;
      }
      return this;
    }  /**
        * Internal method that draws the individual lines. Will be overwritten
        * in VML fallback mode below.
        */,
    lines: function (el, o) {
      var i = 0, start = (o.lines - 1) * (1 - o.direction) / 2, seg;
      function fill(color, shadow) {
        return css(createEl(), {
          position: 'absolute',
          width: o.scale * (o.length + o.width) + 'px',
          height: o.scale * o.width + 'px',
          background: color,
          boxShadow: shadow,
          transformOrigin: 'left',
          transform: 'rotate(' + ~~(360 / o.lines * i + o.rotate) + 'deg) translate(' + o.scale * o.radius + 'px' + ',0)',
          borderRadius: (o.corners * o.scale * o.width >> 1) + 'px'
        });
      }
      for (; i < o.lines; i++) {
        seg = css(createEl(), {
          position: 'absolute',
          top: 1 + ~(o.scale * o.width / 2) + 'px',
          transform: o.hwaccel ? 'translate3d(0,0,0)' : '',
          opacity: o.opacity,
          animation: useCssAnimations && addAnimation(o.opacity, o.trail, start + i * o.direction, o.lines) + ' ' + 1 / o.speed + 's linear infinite'
        });
        if (o.shadow)
          ins(seg, css(fill('#000', '0 0 4px #000'), { top: '2px' }));
        ins(el, ins(seg, fill(getColor(o.color, i), '0 0 1px rgba(0,0,0,.1)')));
      }
      return el;
    }  /**
        * Internal method that adjusts the opacity of a single line.
        * Will be overwritten in VML fallback mode below.
        */,
    opacity: function (el, i, val) {
      if (i < el.childNodes.length)
        el.childNodes[i].style.opacity = val;
    }
  });
  function initVML() {
    /* Utility function to create a VML tag */
    function vml(tag, attr) {
      return createEl('<' + tag + ' xmlns="urn:schemas-microsoft.com:vml" class="spin-vml">', attr);
    }
    // No CSS transforms but VML support, add a CSS rule for VML elements:
    sheet.addRule('.spin-vml', 'behavior:url(#default#VML)');
    Spinner.prototype.lines = function (el, o) {
      var r = o.scale * (o.length + o.width), s = o.scale * 2 * r;
      function grp() {
        return css(vml('group', {
          coordsize: s + ' ' + s,
          coordorigin: -r + ' ' + -r
        }), {
          width: s,
          height: s
        });
      }
      var margin = -(o.width + o.length) * o.scale * 2 + 'px', g = css(grp(), {
          position: 'absolute',
          top: margin,
          left: margin
        }), i;
      function seg(i, dx, filter) {
        ins(g, ins(css(grp(), {
          rotation: 360 / o.lines * i + 'deg',
          left: ~~dx
        }), ins(css(vml('roundrect', { arcsize: o.corners }), {
          width: r,
          height: o.scale * o.width,
          left: o.scale * o.radius,
          top: -o.scale * o.width >> 1,
          filter: filter
        }), vml('fill', {
          color: getColor(o.color, i),
          opacity: o.opacity
        }), vml('stroke', { opacity: 0 })  // transparent stroke to fix color bleeding upon opacity change
)));
      }
      if (o.shadow)
        for (i = 1; i <= o.lines; i++) {
          seg(i, -2, 'progid:DXImageTransform.Microsoft.Blur(pixelradius=2,makeshadow=1,shadowopacity=.3)');
        }
      for (i = 1; i <= o.lines; i++)
        seg(i);
      return ins(el, g);
    };
    Spinner.prototype.opacity = function (el, i, val, o) {
      var c = el.firstChild;
      o = o.shadow && o.lines || 0;
      if (c && i + o < c.childNodes.length) {
        c = c.childNodes[i + o];
        c = c && c.firstChild;
        c = c && c.firstChild;
        if (c)
          c.opacity = val;
      }
    };
  }
  if (typeof document !== 'undefined') {
    sheet = function () {
      var el = createEl('style', { type: 'text/css' });
      ins(document.getElementsByTagName('head')[0], el);
      return el.sheet || el.styleSheet;
    }();
    var probe = css(createEl('group'), { behavior: 'url(#default#VML)' });
    if (!vendor(probe, 'transform') && probe.adj)
      initVML();
    else
      useCssAnimations = vendor(probe, 'animation');
  }
  return Spinner;
}));
utils = function () {
  ////////////////////////////////////////////////////////////////////////////
  // Timer
  function Timer() {
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
  }
  Timer.now = function () {
    var p = typeof window !== 'undefined' && window.performance;
    return p && p.now ? p.now.bind(p) : Date.now;
  }();
  Timer.prototype = {
    constructor: Timer,
    start: function () {
      this.startTime = Timer.now();
      this.oldTime = this.startTime;
      this.running = true;
    },
    stop: function () {
      this.getElapsedTime();
      this.running = false;
    },
    getElapsedTime: function () {
      this.update();
      return this.elapsedTime;
    },
    update: function () {
      var delta = 0;
      if (this.running) {
        var newTime = Timer.now();
        delta = 0.001 * (newTime - this.oldTime);
        this.oldTime = newTime;
        this.elapsedTime += delta;
      }
      return delta;
    }
  };
  ////////////////////////////////////////////////////////////////////////////
  // Query string
  function getUrlParameters(url, orderMatters) {
    url = url || window.location.search;
    var query = url.substring(1);
    var plus = /\+/g;
    var search = /([^&=]+)=?([^&]*)/g;
    var result = orderMatters ? [] : {};
    var match;
    function decode(s) {
      return decodeURIComponent(s.replace(plus, ' '));
    }
    if (orderMatters) {
      while ((match = search.exec(query)) !== null) {
        result.push([
          decode(match[1]),
          decode(match[2])
        ]);
      }
    } else {
      while ((match = search.exec(query)) !== null) {
        result[decode(match[1])] = decode(match[2]);
      }
    }
    return result;
  }
  ////////////////////////////////////////////////////////////////////////////
  // Create HTML element
  function createElement(tag, attrs, content) {
    var element = document.createElement(tag);
    var i, n;
    if (attrs) {
      var keys = Object.keys(attrs);
      for (i = 0, n = keys.length; i < n; ++i) {
        var key = keys[i];
        element.setAttribute(key, attrs[key]);
      }
    }
    if (content) {
      if (!(content instanceof Array)) {
        content = [content];
      }
      for (i = 0, n = content.length; i < n; ++i) {
        var child = content[i];
        if (typeof child === 'string') {
          element.appendChild(document.createTextNode(child));
        } else if (child instanceof HTMLElement) {
          element.appendChild(child);
        }
      }
    }
    return element;
  }
  ////////////////////////////////////////////////////////////////////////////
  // Deep prototyping
  function deriveDeep(obj) {
    var res = obj;
    var i, n;
    if (obj instanceof Array) {
      res = new Array(obj.length);
      for (i = 0, n = obj.length; i < n; ++i) {
        var elem = obj[i];
        res[i] = elem instanceof Object ? deriveDeep(elem) : elem;
      }
    } else if (obj instanceof Object) {
      res = Object.create(obj);
      var keys = Object.keys(obj);
      for (i = 0, n = keys.length; i < n; ++i) {
        var key = keys[i];
        var value = obj[key];
        if (value instanceof Object) {
          res[key] = deriveDeep(value);
        }
      }
    }
    return res;
  }
  ////////////////////////////////////////////////////////////////////////////
  // Colors
  function hexColor(color) {
    var hex = ('0000000' + color.toString(16)).substr(-6);
    return '#' + hex;
  }
  function stringColorToHex(color) {
    var hexString = '0x' + color.substr(-6);
    return parseInt(hexString, 16);
  }
  ////////////////////////////////////////////////////////////////////////////
  // Debug tracing
  function DebugTracer(namespace) {
    var enabled = false;
    this.enable = function (on) {
      enabled = on;
    };
    var indent = 0;
    var methods = Object.keys(namespace);
    function wrap(method_, name_) {
      return function () {
        var spaces = DebugTracer.spaces.substr(0, indent * 2);
        if (enabled) {
          console.log(spaces + name_ + ' {');
        }
        indent++;
        var result = method_.apply(this, arguments);
        // eslint-disable-line no-invalid-this
        indent--;
        if (enabled) {
          console.log(spaces + '} // ' + name_);
        }
        return result;
      };
    }
    for (var i = 0, n = methods.length; i < n; ++i) {
      var name = methods[i];
      var method = namespace[name];
      if (method instanceof Function && name !== 'constructor') {
        namespace[name] = wrap(method, name);
      }
    }
  }
  DebugTracer.spaces = '                                                                                          ';
  function OutOfMemoryError(message) {
    Error.call(this);
    this.name = 'OutOfMemoryError';
    this.message = message;
  }
  OutOfMemoryError.prototype = Object.create(Error.prototype);
  function allocateTyped(TypedArrayName, size) {
    var result = null;
    try {
      result = new TypedArrayName(size);
    } catch (e) {
      if (e instanceof RangeError) {
        throw new OutOfMemoryError(e.message);
      } else {
        throw e;
      }
    }
    return result;
  }
  ////////////////////////////////////////////////////////////////////////////
  // Exports
  return {
    Timer: Timer,
    getUrlParameters: getUrlParameters,
    createElement: createElement,
    deriveDeep: deriveDeep,
    hexColor: hexColor,
    stringColorToHex: stringColorToHex,
    DebugTracer: DebugTracer,
    OutOfMemoryError: OutOfMemoryError,
    allocateTyped: allocateTyped
  };
}();
Stats = function (utils) {
  var now = utils.Timer.now;
  function createElement(tag, id, css) {
    var element = document.createElement(tag);
    element.id = id;
    element.style.cssText = css;
    return element;
  }
  function Stats() {
    this.domElement = createElement('div', 'stats', 'padding:8px');
    this._text = createElement('p', 'fps', 'margin:0;color:silver;font-size:large');
    this.domElement.appendChild(this._text);
    this._startTime = now();
    this._prevTime = this._startTime;
    this._deltas = new Array(20);
    this._index = 0 | 0;
    this._total = 0;
    this._count = 0;
  }
  Stats.prototype = {
    constructor: Stats,
    begin: function () {
      this._startTime = now();
    },
    end: function () {
      var time = now();
      var delta = time - this._startTime;
      if (this._count < this._deltas.length) {
        this._count++;
      } else {
        this._total -= this._deltas[this._index];
      }
      this._total += delta;
      this._deltas[this._index] = delta;
      this._index = (this._index + 1) % this._deltas.length;
      this.ms = this._total / this._count;
      this.fps = 1000 / this.ms;
      if (time > this._prevTime + 1000) {
        this._text.textContent = this.fps.toPrecision(2);
        this._prevTime = time;
      }
      return time;
    },
    update: function () {
      this._startTime = this.end();
    },
    show: function (on) {
      if (on === undefined) {
        on = true;
      }
      this.domElement.style.display = on ? 'block' : 'none';
    }
  };
  return Stats;
}(utils);
(function () {
  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;
  /** Used as the semantic version number. */
  var VERSION = '4.12.0';
  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;
  /** Used as the `TypeError` message for "Functions" methods. */
  var FUNC_ERROR_TEXT = 'Expected a function';
  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';
  /** Used to compose bitmasks for wrapper metadata. */
  var BIND_FLAG = 1, BIND_KEY_FLAG = 2, CURRY_BOUND_FLAG = 4, CURRY_FLAG = 8, CURRY_RIGHT_FLAG = 16, PARTIAL_FLAG = 32, PARTIAL_RIGHT_FLAG = 64, ARY_FLAG = 128, REARG_FLAG = 256, FLIP_FLAG = 512;
  /** Used to compose bitmasks for comparison styles. */
  var UNORDERED_COMPARE_FLAG = 1, PARTIAL_COMPARE_FLAG = 2;
  /** Used as default options for `_.truncate`. */
  var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = '...';
  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 150, HOT_SPAN = 16;
  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 1.7976931348623157e+308, NAN = 0 / 0;
  /** Used as references for the maximum length and index of an array. */
  var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', promiseTag = '[object Promise]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', weakMapTag = '[object WeakMap]', weakSetTag = '[object WeakSet]';
  var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g, reUnescapedHtml = /[&<>"'`]/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]/g;
  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
  /** Used to match leading and trailing whitespace. */
  var reTrim = /^\s+|\s+$/g, reTrimStart = /^\s+/, reTrimEnd = /\s+$/;
  /** Used to match non-compound words composed of alphanumeric characters. */
  var reBasicWord = /[a-zA-Z0-9]+/g;
  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;
  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components).
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;
  /** Used to detect hexadecimal string values. */
  var reHasHexPrefix = /^0x/i;
  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;
  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;
  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
  var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;
  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;
  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff', rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23', rsComboSymbolsRange = '\\u20d0-\\u20f0', rsDingbatRange = '\\u2700-\\u27bf', rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff', rsMathOpRange = '\\xac\\xb1\\xd7\\xf7', rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf', rsPunctuationRange = '\\u2000-\\u206f', rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000', rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde', rsVarRange = '\\ufe0e\\ufe0f', rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
  /** Used to compose unicode capture groups. */
  var rsApos = '[\'\u2019]', rsAstral = '[' + rsAstralRange + ']', rsBreak = '[' + rsBreakRange + ']', rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']', rsDigits = '\\d+', rsDingbat = '[' + rsDingbatRange + ']', rsLower = '[' + rsLowerRange + ']', rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']', rsFitz = '\\ud83c[\\udffb-\\udfff]', rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')', rsNonAstral = '[^' + rsAstralRange + ']', rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}', rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]', rsUpper = '[' + rsUpperRange + ']', rsZWJ = '\\u200d';
  /** Used to compose unicode regexes. */
  var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')', rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')', rsOptLowerContr = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?', rsOptUpperContr = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?', reOptMod = rsModifier + '?', rsOptVar = '[' + rsVarRange + ']?', rsOptJoin = '(?:' + rsZWJ + '(?:' + [
      rsNonAstral,
      rsRegional,
      rsSurrPair
    ].join('|') + ')' + rsOptVar + reOptMod + ')*', rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = '(?:' + [
      rsDingbat,
      rsRegional,
      rsSurrPair
    ].join('|') + ')' + rsSeq, rsSymbol = '(?:' + [
      rsNonAstral + rsCombo + '?',
      rsCombo,
      rsRegional,
      rsSurrPair,
      rsAstral
    ].join('|') + ')';
  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');
  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo, 'g');
  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reComplexSymbol = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
  /** Used to match complex or compound words. */
  var reComplexWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptLowerContr + '(?=' + [
      rsBreak,
      rsUpper,
      '$'
    ].join('|') + ')',
    rsUpperMisc + '+' + rsOptUpperContr + '(?=' + [
      rsBreak,
      rsUpper + rsLowerMisc,
      '$'
    ].join('|') + ')',
    rsUpper + '?' + rsLowerMisc + '+' + rsOptLowerContr,
    rsUpper + '+' + rsOptUpperContr,
    rsDigits,
    rsEmoji
  ].join('|'), 'g');
  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasComplexSymbol = RegExp('[' + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');
  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasComplexWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array',
    'Buffer',
    'DataView',
    'Date',
    'Error',
    'Float32Array',
    'Float64Array',
    'Function',
    'Int8Array',
    'Int16Array',
    'Int32Array',
    'Map',
    'Math',
    'Object',
    'Promise',
    'Reflect',
    'RegExp',
    'Set',
    'String',
    'Symbol',
    'TypeError',
    'Uint8Array',
    'Uint8ClampedArray',
    'Uint16Array',
    'Uint32Array',
    'WeakMap',
    '_',
    'clearTimeout',
    'isFinite',
    'parseInt',
    'setTimeout'
  ];
  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;
  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  /** Used to map latin-1 supplementary letters to basic latin letters. */
  var deburredLetters = {
    'À': 'A',
    'Á': 'A',
    'Â': 'A',
    'Ã': 'A',
    'Ä': 'A',
    'Å': 'A',
    'à': 'a',
    'á': 'a',
    'â': 'a',
    'ã': 'a',
    'ä': 'a',
    'å': 'a',
    'Ç': 'C',
    'ç': 'c',
    'Ð': 'D',
    'ð': 'd',
    'È': 'E',
    'É': 'E',
    'Ê': 'E',
    'Ë': 'E',
    'è': 'e',
    'é': 'e',
    'ê': 'e',
    'ë': 'e',
    'Ì': 'I',
    'Í': 'I',
    'Î': 'I',
    'Ï': 'I',
    'ì': 'i',
    'í': 'i',
    'î': 'i',
    'ï': 'i',
    'Ñ': 'N',
    'ñ': 'n',
    'Ò': 'O',
    'Ó': 'O',
    'Ô': 'O',
    'Õ': 'O',
    'Ö': 'O',
    'Ø': 'O',
    'ò': 'o',
    'ó': 'o',
    'ô': 'o',
    'õ': 'o',
    'ö': 'o',
    'ø': 'o',
    'Ù': 'U',
    'Ú': 'U',
    'Û': 'U',
    'Ü': 'U',
    'ù': 'u',
    'ú': 'u',
    'û': 'u',
    'ü': 'u',
    'Ý': 'Y',
    'ý': 'y',
    'ÿ': 'y',
    'Æ': 'Ae',
    'æ': 'ae',
    'Þ': 'Th',
    'þ': 'th',
    'ß': 'ss'
  };
  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&#39;',
    '`': '&#96;'
  };
  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': '\'',
    '&#96;': '`'
  };
  /** Used to determine if values are of the language type `Object`. */
  var objectTypes = {
    'function': true,
    'object': true
  };
  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    '\'': '\'',
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };
  /** Built-in method references without a dependency on `root`. */
  var freeParseFloat = parseFloat, freeParseInt = parseInt;
  /** Detect free variable `exports`. */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType ? exports : undefined;
  /** Detect free variable `module`. */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType ? module : undefined;
  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports ? freeExports : undefined;
  /** Detect free variable `global` from Node.js. */
  var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);
  /** Detect free variable `self`. */
  var freeSelf = checkGlobal(objectTypes[typeof self] && self);
  /** Detect free variable `window`. */
  var freeWindow = checkGlobal(objectTypes[typeof window] && window);
  /** Detect `this` as the global object. */
  var thisGlobal = checkGlobal(objectTypes[typeof this] && this);
  /**
   * Used as a reference to the global object.
   *
   * The `this` value is used if it's the global object to avoid Greasemonkey's
   * restricted `window` object, otherwise the `window` object is used.
   */
  var root = freeGlobal || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf || thisGlobal || Function('return this')();
  /*--------------------------------------------------------------------------*/
  /**
   * Adds the key-value `pair` to `map`.
   *
   * @private
   * @param {Object} map The map to modify.
   * @param {Array} pair The key-value pair to add.
   * @returns {Object} Returns `map`.
   */
  function addMapEntry(map, pair) {
    // Don't return `Map#set` because it doesn't return the map instance in IE 11.
    map.set(pair[0], pair[1]);
    return map;
  }
  /**
   * Adds `value` to `set`.
   *
   * @private
   * @param {Object} set The set to modify.
   * @param {*} value The value to add.
   * @returns {Object} Returns `set`.
   */
  function addSetEntry(set, value) {
    set.add(value);
    return set;
  }
  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    var length = args.length;
    switch (length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1, length = array.length;
    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }
  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1, length = array.length;
    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }
  /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEachRight(array, iteratee) {
    var length = array.length;
    while (length--) {
      if (iteratee(array[length], length, array) === false) {
        break;
      }
    }
    return array;
  }
  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1, length = array.length;
    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }
  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1, length = array.length, resIndex = 0, result = [];
    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    return !!array.length && baseIndexOf(array, value, 0) > -1;
  }
  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1, length = array.length;
    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }
  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1, length = array.length, result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }
  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }
  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array.length;
    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }
  /**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
    var length = array.length;
    if (initAccum && length) {
      accumulator = array[--length];
    }
    while (length--) {
      accumulator = iteratee(accumulator, array[length], length, array);
    }
    return accumulator;
  }
  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1, length = array.length;
    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }
  /**
   * The base implementation of methods like `_.find` and `_.findKey`, without
   * support for iteratee shorthands, which iterates over `collection` using
   * `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to search.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @param {boolean} [retKey] Specify returning the key of the found element
   *  instead of the element itself.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */
  function baseFind(collection, predicate, eachFunc, retKey) {
    var result;
    eachFunc(collection, function (value, key, collection) {
      if (predicate(value, key, collection)) {
        result = retKey ? key : value;
        return false;
      }
    });
    return result;
  }
  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {Function} predicate The function invoked per iteration.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromRight) {
    var length = array.length, index = fromRight ? length : -1;
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }
  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return indexOfNaN(array, fromIndex);
    }
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }
  /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }
  /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
  function baseMean(array, iteratee) {
    var length = array ? array.length : 0;
    return length ? baseSum(array, iteratee) / length : NAN;
  }
  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function (value, index, collection) {
      accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }
  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;
    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }
  /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
  function baseSum(array, iteratee) {
    var result, index = -1, length = array.length;
    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== undefined) {
        result = result === undefined ? current : result + current;
      }
    }
    return result;
  }
  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  /**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */
  function baseToPairs(object, props) {
    return arrayMap(props, function (key) {
      return [
        key,
        object[key]
      ];
    });
  }
  /**
   * The base implementation of `_.unary` without support for storing wrapper metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function (value) {
      return func(value);
    };
  }
  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function (key) {
      return object[key];
    });
  }
  /**
   * Checks if a cache value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1, length = strSymbols.length;
    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
    }
    return index;
  }
  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;
    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
    }
    return index;
  }
  /**
   * Checks if `value` is a global object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {null|Object} Returns `value` if it's a global object, else `null`.
   */
  function checkGlobal(value) {
    return value && value.Object === Object ? value : null;
  }
  /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
  function countHolders(array, placeholder) {
    var length = array.length, result = 0;
    while (length--) {
      if (array[length] === placeholder) {
        result++;
      }
    }
    return result;
  }
  /**
   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  function deburrLetter(letter) {
    return deburredLetters[letter];
  }
  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeHtmlChar(chr) {
    return htmlEscapes[chr];
  }
  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }
  /**
   * Gets the index at which the first occurrence of `NaN` is found in `array`.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
   */
  function indexOfNaN(array, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 0 : -1);
    while (fromRight ? index-- : ++index < length) {
      var other = array[index];
      if (other !== other) {
        return index;
      }
    }
    return -1;
  }
  /**
   * Checks if `value` is a host object in IE < 9.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
   */
  function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;
    if (value != null && typeof value.toString != 'function') {
      try {
        result = !!(value + '');
      } catch (e) {
      }
    }
    return result;
  }
  /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
  function iteratorToArray(iterator) {
    var data, result = [];
    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }
    return result;
  }
  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function (value, key) {
      result[++index] = [
        key,
        value
      ];
    });
    return result;
  }
  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1, length = array.length, resIndex = 0, result = [];
    while (++index < length) {
      var value = array[index];
      if (value === placeholder || value === PLACEHOLDER) {
        array[index] = PLACEHOLDER;
        result[resIndex++] = index;
      }
    }
    return result;
  }
  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function (value) {
      result[++index] = value;
    });
    return result;
  }
  /**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */
  function setToPairs(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function (value) {
      result[++index] = [
        value,
        value
      ];
    });
    return result;
  }
  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    if (!(string && reHasComplexSymbol.test(string))) {
      return string.length;
    }
    var result = reComplexSymbol.lastIndex = 0;
    while (reComplexSymbol.test(string)) {
      result++;
    }
    return result;
  }
  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return string.match(reComplexSymbol);
  }
  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  function unescapeHtmlChar(chr) {
    return htmlUnescapes[chr];
  }
  /*--------------------------------------------------------------------------*/
  /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Use `context` to mock `Date#getTime` use in `_.now`.
   * var mock = _.runInContext({
   *   'Date': function() {
   *     return { 'getTime': getTimeMock };
   *   }
   * });
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  function runInContext(context) {
    context = context ? _.defaults({}, context, _.pick(root, contextProps)) : root;
    /** Built-in constructor references. */
    var Date = context.Date, Error = context.Error, Math = context.Math, RegExp = context.RegExp, TypeError = context.TypeError;
    /** Used for built-in method references. */
    var arrayProto = context.Array.prototype, objectProto = context.Object.prototype, stringProto = context.String.prototype;
    /** Used to resolve the decompiled source of functions. */
    var funcToString = context.Function.prototype.toString;
    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;
    /** Used to generate unique IDs. */
    var idCounter = 0;
    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);
    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;
    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;
    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
    /** Built-in value references. */
    var Buffer = moduleExports ? context.Buffer : undefined, Reflect = context.Reflect, Symbol = context.Symbol, Uint8Array = context.Uint8Array, clearTimeout = context.clearTimeout, enumerate = Reflect ? Reflect.enumerate : undefined, getOwnPropertySymbols = Object.getOwnPropertySymbols, iteratorSymbol = typeof (iteratorSymbol = Symbol && Symbol.iterator) == 'symbol' ? iteratorSymbol : undefined, objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, setTimeout = context.setTimeout, splice = arrayProto.splice;
    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil, nativeFloor = Math.floor, nativeGetPrototype = Object.getPrototypeOf, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = Object.keys, nativeMax = Math.max, nativeMin = Math.min, nativeParseInt = context.parseInt, nativeRandom = Math.random, nativeReplace = stringProto.replace, nativeReverse = arrayProto.reverse, nativeSplit = stringProto.split;
    /* Built-in method references that are verified to be native. */
    var DataView = getNative(context, 'DataView'), Map = getNative(context, 'Map'), Promise = getNative(context, 'Promise'), Set = getNative(context, 'Set'), WeakMap = getNative(context, 'WeakMap'), nativeCreate = getNative(Object, 'create');
    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap();
    /** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */
    var nonEnumShadows = !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf');
    /** Used to lookup unminified function names. */
    var realNames = {};
    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
    /*------------------------------------------------------------------------*/
    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array of at least `200` elements
     * and any iteratees accept only one argument. The heuristic for whether a
     * section qualifies for shortcut fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `deburr`, `divide`, `each`,
     * `eachRight`, `endsWith`, `eq`, `escape`, `escapeRegExp`, `every`, `find`,
     * `findIndex`, `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `first`,
     * `floor`, `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`,
     * `forOwnRight`, `get`, `gt`, `gte`, `has`, `hasIn`, `head`, `identity`,
     * `includes`, `indexOf`, `inRange`, `invoke`, `isArguments`, `isArray`,
     * `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`, `isBoolean`,
     * `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`, `isEqualWith`,
     * `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`, `isMap`,
     * `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`, `isNumber`,
     * `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`, `isSafeInteger`,
     * `isSet`, `isString`, `isUndefined`, `isTypedArray`, `isWeakMap`, `isWeakSet`,
     * `join`, `kebabCase`, `last`, `lastIndexOf`, `lowerCase`, `lowerFirst`,
     * `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`, `min`, `minBy`, `multiply`,
     * `noConflict`, `noop`, `now`, `nth`, `pad`, `padEnd`, `padStart`, `parseInt`,
     * `pop`, `random`, `reduce`, `reduceRight`, `repeat`, `result`, `round`,
     * `runInContext`, `sample`, `shift`, `size`, `snakeCase`, `some`, `sortedIndex`,
     * `sortedIndexBy`, `sortedLastIndex`, `sortedLastIndexBy`, `startCase`,
     * `startsWith`, `subtract`, `sum`, `sumBy`, `template`, `times`, `toFinite`,
     * `toInteger`, `toJSON`, `toLength`, `toLower`, `toNumber`, `toSafeInteger`,
     * `toString`, `toUpper`, `trim`, `trimEnd`, `trimStart`, `truncate`, `unescape`,
     * `uniqueId`, `upperCase`, `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }
    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
    }
    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }
    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB). Change the following template settings to use
     * alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */
    lodash.templateSettings = {
      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'escape': reEscape,
      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'evaluate': reEvaluate,
      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'interpolate': reInterpolate,
      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      'variable': '',
      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      'imports': {
        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        '_': lodash
      }
    };
    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;
    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;
    /*------------------------------------------------------------------------*/
    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }
    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = copyArray(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = copyArray(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = copyArray(this.__views__);
      return result;
    }
    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }
    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
      if (!isArr || arrLength < LARGE_ARRAY_SIZE || arrLength == length && takeCount == length) {
        return baseWrapperValue(array, this.__actions__);
      }
      var result = [];
      outer:
        while (length-- && resIndex < takeCount) {
          index += dir;
          var iterIndex = -1, value = array[index];
          while (++iterIndex < iterLength) {
            var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type, computed = iteratee(value);
            if (type == LAZY_MAP_FLAG) {
              value = computed;
            } else if (!computed) {
              if (type == LAZY_FILTER_FLAG) {
                continue outer;
              } else {
                break outer;
              }
            }
          }
          result[resIndex++] = value;
        }
      return result;
    }
    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;
    /*------------------------------------------------------------------------*/
    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }
    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
    }
    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
      return this;
    }
    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    /*------------------------------------------------------------------------*/
    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
    }
    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? undefined : data[index][1];
    }
    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([
          key,
          value
        ]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    /*------------------------------------------------------------------------*/
    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.__data__ = {
        'hash': new Hash(),
        'map': new (Map || ListCache)(),
        'string': new Hash()
      };
    }
    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      return getMapData(this, key)['delete'](key);
    }
    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    /*------------------------------------------------------------------------*/
    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    /*------------------------------------------------------------------------*/
    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache();
    }
    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      return this.__data__['delete'](key);
    }
    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }
    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }
    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache && cache.__data__.length == LARGE_ARRAY_SIZE) {
        cache = this.__data__ = new MapCache(cache.__data__);
      }
      cache.set(key, value);
      return this;
    }
    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    /*------------------------------------------------------------------------*/
    /**
     * Used by `_.defaults` to customize its `_.assignIn` use.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */
    function assignInDefaults(objValue, srcValue, key, object) {
      if (objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
        return srcValue;
      }
      return objValue;
    }
    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if (value !== undefined && !eq(object[key], value) || typeof key == 'number' && value === undefined && !(key in object)) {
        object[key] = value;
      }
    }
    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
        object[key] = value;
      }
    }
    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to search.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function (value, key, collection) {
        setter(accumulator, value, iteratee(value), collection);
      });
      return accumulator;
    }
    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths of elements to pick.
     * @returns {Array} Returns the picked elements.
     */
    function baseAt(object, paths) {
      var index = -1, isNil = object == null, length = paths.length, result = Array(length);
      while (++index < length) {
        result[index] = isNil ? undefined : get(object, paths[index]);
      }
      return result;
    }
    /**
     * The base implementation of `_.clamp` which doesn't coerce arguments to numbers.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== undefined) {
          number = number <= upper ? number : upper;
        }
        if (lower !== undefined) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }
    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {boolean} [isFull] Specify a clone including symbols.
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
      }
      // Recursively populate clone (susceptible to call stack limits).
      arrayEach(props || value, function (subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
      });
      return result;
    }
    /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */
    function baseConforms(source) {
      var props = keys(source), length = props.length;
      return function (object) {
        if (object == null) {
          return !length;
        }
        var index = length;
        while (index--) {
          var key = props[index], predicate = source[key], value = object[key];
          if (value === undefined && !(key in Object(object)) || !predicate(value)) {
            return false;
          }
        }
        return true;
      };
    }
    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    function baseCreate(proto) {
      return isObject(proto) ? objectCreate(proto) : {};
    }
    /**
     * The base implementation of `_.delay` and `_.defer` which accepts an array
     * of `func` arguments.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Object} args The arguments to provide to `func`.
     * @returns {number} Returns the timer id.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function () {
        func.apply(undefined, args);
      }, wait);
    }
    /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes(values, computed, comparator)) {
            result.push(value);
          }
        }
      return result;
    }
    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);
    /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);
    /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function (value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }
    /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(array, iteratee, comparator) {
      var index = -1, length = array.length;
      while (++index < length) {
        var value = array[index], current = iteratee(value);
        if (current != null && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed))) {
          var computed = current, result = value;
        }
      }
      return result;
    }
    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;
      start = toInteger(start);
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end === undefined || end > length ? length : toInteger(end);
      if (end < 0) {
        end += length;
      }
      end = start > end ? 0 : toLength(end);
      while (start < end) {
        array[start++] = value;
      }
      return array;
    }
    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function (value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }
    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();
    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);
    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return object && baseForRight(object, iteratee, keys);
    }
    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */
    function baseFunctions(object, props) {
      return arrayFilter(props, function (key) {
        return isFunction(object[key]);
      });
    }
    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : undefined;
    }
    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    /**
     * The base implementation of `_.gt` which doesn't coerce arguments to numbers.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
    function baseGt(value, other) {
      return value > other;
    }
    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      // Avoid a bug in IE 10-11 where objects with a [[Prototype]] of `null`,
      // that are composed entirely of index properties, return `false` for
      // `hasOwnProperty` checks of them.
      return hasOwnProperty.call(object, key) || typeof object == 'object' && key in object && getPrototype(object) === null;
    }
    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return key in Object(object);
    }
    /**
     * The base implementation of `_.inRange` which doesn't coerce arguments to numbers.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
    function baseInRange(number, start, end) {
      return number >= nativeMin(start, end) && number < nativeMax(start, end);
    }
    /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined;
      }
      array = arrays[0];
      var index = -1, seen = caches[0];
      outer:
        while (++index < length && result.length < maxLength) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
            othIndex = othLength;
            while (--othIndex) {
              var cache = caches[othIndex];
              if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
                continue outer;
              }
            }
            if (seen) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function (value, key, object) {
        setter(accumulator, iteratee(value), key, object);
      });
      return accumulator;
    }
    /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function baseInvoke(object, path, args) {
      if (!isKey(path, object)) {
        path = castPath(path);
        object = parent(object, path);
        path = last(path);
      }
      var func = object == null ? object : object[toKey(path)];
      return func == null ? undefined : apply(func, object, args);
    }
    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {boolean} [bitmask] The bitmask of comparison flags.
     *  The bitmask may be composed of the following flags:
     *     1 - Unordered comparison
     *     2 - Partial comparison
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
     *  for more details.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
      if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
      }
      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }
      var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'), othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
    }
    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    /**
     * The base implementation of `_.keys` which doesn't skip the constructor
     * property of prototypes or treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      return nativeKeys(Object(object));
    }
    /**
     * The base implementation of `_.keysIn` which doesn't skip the constructor
     * property of prototypes or treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      object = object == null ? object : Object(object);
      var result = [];
      for (var key in object) {
        result.push(key);
      }
      return result;
    }
    // Fallback for IE < 9 with es6-shim.
    if (enumerate && !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf')) {
      baseKeysIn = function (object) {
        return iteratorToArray(enumerate(object));
      };
    }
    /**
     * The base implementation of `_.lt` which doesn't coerce arguments to numbers.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
    function baseLt(value, other) {
      return value < other;
    }
    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function (value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }
    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function (object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function (object) {
        var objValue = get(object, path);
        return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      if (!(isArray(source) || isTypedArray(source))) {
        var props = keysIn(source);
      }
      arrayEach(props || source, function (srcValue, key) {
        if (props) {
          key = srcValue;
          srcValue = source[key];
        }
        if (isObject(srcValue)) {
          stack || (stack = new Stack());
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(object[key], srcValue, key + '', object, source, stack) : undefined;
          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      });
    }
    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = object[key], srcValue = source[key], stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
      var isCommon = newValue === undefined;
      if (isCommon) {
        newValue = srcValue;
        if (isArray(srcValue) || isTypedArray(srcValue)) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else {
            isCommon = false;
            newValue = baseClone(srcValue, true);
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || srcIndex && isFunction(objValue)) {
            isCommon = false;
            newValue = baseClone(srcValue, true);
          } else {
            newValue = objValue;
          }
        } else {
          isCommon = false;
        }
      }
      stack.set(srcValue, newValue);
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      }
      stack['delete'](srcValue);
      assignMergeValue(object, key, newValue);
    }
    /**
     * The base implementation of `_.nth` which doesn't coerce `n` to an integer.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
    function baseNth(array, n) {
      var length = array.length;
      if (!length) {
        return;
      }
      n += n < 0 ? length : 0;
      return isIndex(n, length) ? array[n] : undefined;
    }
    /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseOrderBy(collection, iteratees, orders) {
      var index = -1;
      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));
      var result = baseMap(collection, function (value, key, collection) {
        var criteria = arrayMap(iteratees, function (iteratee) {
          return iteratee(value);
        });
        return {
          'criteria': criteria,
          'index': ++index,
          'value': value
        };
      });
      return baseSortBy(result, function (object, other) {
        return compareMultiple(object, other, orders);
      });
    }
    /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} props The property identifiers to pick.
     * @returns {Object} Returns the new object.
     */
    function basePick(object, props) {
      object = Object(object);
      return arrayReduce(props, function (result, key) {
        if (key in object) {
          result[key] = object[key];
        }
        return result;
      }, {});
    }
    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, predicate) {
      var index = -1, props = getAllKeysIn(object), length = props.length, result = {};
      while (++index < length) {
        var key = props[index], value = object[key];
        if (predicate(value, key)) {
          result[key] = value;
        }
      }
      return result;
    }
    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function baseProperty(key) {
      return function (object) {
        return object == null ? undefined : object[key];
      };
    }
    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function (object) {
        return baseGet(object, path);
      };
    }
    /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values.length, seen = array;
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value;
        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }
    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0, lastIndex = length - 1;
      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice.call(array, index, 1);
          } else if (!isKey(index, array)) {
            var path = castPath(index), object = parent(array, path);
            if (object != null) {
              delete object[toKey(last(path))];
            }
          } else {
            delete array[toKey(index)];
          }
        }
      }
      return array;
    }
    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }
    /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments to numbers.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */
    function baseRange(start, end, step, fromRight) {
      var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
      while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
      }
      return result;
    }
    /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */
    function baseRepeat(string, n) {
      var result = '';
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);
      return result;
    }
    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = -1, length = path.length, lastIndex = length - 1, nested = object;
      while (nested != null && ++index < length) {
        var key = toKey(path[index]);
        if (isObject(nested)) {
          var newValue = value;
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined;
            if (newValue === undefined) {
              newValue = objValue == null ? isIndex(path[index + 1]) ? [] : {} : objValue;
            }
          }
          assignValue(nested, key, newValue);
        }
        nested = nested[key];
      }
      return object;
    }
    /**
     * The base implementation of `setData` without support for hot loop detection.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function (func, data) {
      metaMap.set(func, data);
      return func;
    };
    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1, length = array.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }
    /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;
      baseEach(collection, function (value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }
    /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndex(array, value, retHighest) {
      var low = 0, high = array ? array.length : low;
      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = low + high >>> 1, computed = array[mid];
          if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return baseSortedIndexBy(array, value, identity, retHighest);
    }
    /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndexBy(array, value, iteratee, retHighest) {
      value = iteratee(value);
      var low = 0, high = array ? array.length : 0, valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined;
      while (low < high) {
        var mid = nativeFloor((low + high) / 2), computed = iteratee(array[mid]), othIsDefined = computed !== undefined, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
        if (valIsNaN) {
          var setLow = retHighest || othIsReflexive;
        } else if (valIsUndefined) {
          setLow = othIsReflexive && (retHighest || othIsDefined);
        } else if (valIsNull) {
          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        } else if (valIsSymbol) {
          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        } else if (othIsNull || othIsSymbol) {
          setLow = false;
        } else {
          setLow = retHighest ? computed <= value : computed < value;
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }
    /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseSortedUniq(array, iteratee) {
      var index = -1, length = array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        if (!index || !eq(computed, seen)) {
          var seen = computed;
          result[resIndex++] = value === 0 ? 0 : value;
        }
      }
      return result;
    }
    /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */
    function baseToNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      return +value;
    }
    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = value + '';
      return result == '0' && 1 / value == -INFINITY ? '-0' : result;
    }
    /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      object = parent(object, path);
      var key = toKey(last(path));
      return !(object != null && baseHas(object, key)) || delete object[key];
    }
    /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseUpdate(object, path, updater, customizer) {
      return baseSet(object, path, updater(baseGet(object, path)), customizer);
    }
    /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length, index = fromRight ? length : -1;
      while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
      }
      return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
    }
    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      return arrayReduce(actions, function (result, action) {
        return action.func.apply(action.thisArg, arrayPush([result], action.args));
      }, result);
    }
    /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
    function baseXor(arrays, iteratee, comparator) {
      var index = -1, length = arrays.length;
      while (++index < length) {
        var result = result ? arrayPush(baseDifference(result, arrays[index], iteratee, comparator), baseDifference(arrays[index], result, iteratee, comparator)) : arrays[index];
      }
      return result && result.length ? baseUniq(result, iteratee, comparator) : [];
    }
    /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
    function baseZipObject(props, values, assignFunc) {
      var index = -1, length = props.length, valsLength = values.length, result = {};
      while (++index < length) {
        var value = index < valsLength ? values[index] : undefined;
        assignFunc(result, props[index], value);
      }
      return result;
    }
    /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }
    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity;
    }
    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return !start && end >= length ? array : baseSlice(array, start, end);
    }
    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var result = new buffer.constructor(buffer.length);
      buffer.copy(result);
      return result;
    }
    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }
    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    /**
     * Creates a clone of `map`.
     *
     * @private
     * @param {Object} map The map to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned map.
     */
    function cloneMap(map, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
      return arrayReduce(array, addMapEntry, new map.constructor());
    }
    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    /**
     * Creates a clone of `set`.
     *
     * @private
     * @param {Object} set The set to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned set.
     */
    function cloneSet(set, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
      return arrayReduce(array, addSetEntry, new set.constructor());
    }
    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
        var othIsDefined = other !== undefined, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
          return 1;
        }
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }
    /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareMultiple(object, other, orders) {
      var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == 'desc' ? -1 : 1);
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to provide the same value for
      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
      // for more details.
      //
      // This also ensures a stable sort in V8 and other engines.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
      return object.index - other.index;
    }
    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried;
      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }
    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried;
      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }
    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : source[key];
        assignValue(object, key, newValue);
      }
      return object;
    }
    /**
     * Copies own symbol properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function (collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
        return func(collection, setter, getIteratee(iteratee), accumulator);
      };
    }
    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return rest(function (object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;
        customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function (collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function (object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
     *  for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBaseWrapper(func, bitmask, thisArg) {
      var isBind = bitmask & BIND_FLAG, Ctor = createCtorWrapper(func);
      function wrapper() {
        var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }
    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function (string) {
        string = toString(string);
        var strSymbols = reHasComplexSymbol.test(string) ? stringToArray(string) : undefined;
        var chr = strSymbols ? strSymbols[0] : string.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join('') : string.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function (string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }
    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtorWrapper(Ctor) {
      return function () {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
        case 0:
          return new Ctor();
        case 1:
          return new Ctor(args[0]);
        case 2:
          return new Ctor(args[0], args[1]);
        case 3:
          return new Ctor(args[0], args[1], args[2]);
        case 4:
          return new Ctor(args[0], args[1], args[2], args[3]);
        case 5:
          return new Ctor(args[0], args[1], args[2], args[3], args[4]);
        case 6:
          return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
        case 7:
          return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args);
        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }
    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
     *  for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurryWrapper(func, bitmask, arity) {
      var Ctor = createCtorWrapper(func);
      function wrapper() {
        var length = arguments.length, args = Array(length), index = length, placeholder = getHolder(wrapper);
        while (index--) {
          args[index] = arguments[index];
        }
        var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
        length -= holders.length;
        if (length < arity) {
          return createRecurryWrapper(func, bitmask, createHybridWrapper, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length);
        }
        var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }
    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return rest(function (funcs) {
        funcs = baseFlatten(funcs, 1);
        var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
        if (fromRight) {
          funcs.reverse();
        }
        while (index--) {
          var func = funcs[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
            var wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? index : length;
        while (++index < length) {
          func = funcs[index];
          var funcName = getFuncName(func), data = funcName == 'wrapper' ? getData(func) : undefined;
          if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
          }
        }
        return function () {
          var args = arguments, value = args[0];
          if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
            return wrapper.plant(value).value();
          }
          var index = 0, result = length ? funcs[index].apply(this, args) : value;
          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      });
    }
    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
     *  for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & ARY_FLAG, isBind = bitmask & BIND_FLAG, isBindKey = bitmask & BIND_KEY_FLAG, isCurried = bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG), isFlip = bitmask & FLIP_FLAG, Ctor = isBindKey ? undefined : createCtorWrapper(func);
      function wrapper() {
        var length = arguments.length, args = Array(length), index = length;
        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurryWrapper(func, bitmask, createHybridWrapper, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
        }
        var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtorWrapper(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }
    /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
    function createInverter(setter, toIteratee) {
      return function (object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }
    /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new mathematical operation function.
     */
    function createMathOperation(operator) {
      return function (value, other) {
        var result;
        if (value === undefined && other === undefined) {
          return 0;
        }
        if (value !== undefined) {
          result = value;
        }
        if (other !== undefined) {
          if (result === undefined) {
            return other;
          }
          if (typeof value == 'string' || typeof other == 'string') {
            value = baseToString(value);
            other = baseToString(other);
          } else {
            value = baseToNumber(value);
            other = baseToNumber(other);
          }
          result = operator(value, other);
        }
        return result;
      };
    }
    /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */
    function createOver(arrayFunc) {
      return rest(function (iteratees) {
        iteratees = iteratees.length == 1 && isArray(iteratees[0]) ? arrayMap(iteratees[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(iteratees, 1, isFlattenableIteratee), baseUnary(getIteratee()));
        return rest(function (args) {
          var thisArg = this;
          return arrayFunc(iteratees, function (iteratee) {
            return apply(iteratee, thisArg, args);
          });
        });
      });
    }
    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(length, chars) {
      chars = chars === undefined ? ' ' : baseToString(chars);
      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
      return reHasComplexSymbol.test(chars) ? castSlice(stringToArray(result), 0, length).join('') : result.slice(0, length);
    }
    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
     *  for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartialWrapper(func, bitmask, thisArg, partials) {
      var isBind = bitmask & BIND_FLAG, Ctor = createCtorWrapper(func);
      function wrapper() {
        var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }
    /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */
    function createRange(fromRight) {
      return function (start, end, step) {
        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
          end = step = undefined;
        }
        // Ensure the sign of `-0` is preserved.
        start = toNumber(start);
        start = start === start ? start : 0;
        if (end === undefined) {
          end = start;
          start = 0;
        } else {
          end = toNumber(end) || 0;
        }
        step = step === undefined ? start < end ? 1 : -1 : toNumber(step) || 0;
        return baseRange(start, end, step, fromRight);
      };
    }
    /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */
    function createRelationalOperation(operator) {
      return function (value, other) {
        if (!(typeof value == 'string' && typeof other == 'string')) {
          value = toNumber(value);
          other = toNumber(other);
        }
        return operator(value, other);
      };
    }
    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
     *  for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurryWrapper(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & CURRY_FLAG, newHolders = isCurry ? holders : undefined, newHoldersRight = isCurry ? undefined : holders, newPartials = isCurry ? partials : undefined, newPartialsRight = isCurry ? undefined : partials;
      bitmask |= isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG;
      bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
      if (!(bitmask & CURRY_BOUND_FLAG)) {
        bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
      }
      var newData = [
        func,
        bitmask,
        thisArg,
        newPartials,
        newHolders,
        newPartialsRight,
        newHoldersRight,
        argPos,
        ary,
        arity
      ];
      var result = wrapFunc.apply(undefined, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return result;
    }
    /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function (number, precision) {
        number = toNumber(number);
        precision = toInteger(precision);
        if (precision) {
          // Shift with exponential notation to avoid floating-point issues.
          // See [MDN](https://mdn.io/round#Examples) for more details.
          var pair = (toString(number) + 'e').split('e'), value = func(pair[0] + 'e' + (+pair[1] + precision));
          pair = (toString(value) + 'e').split('e');
          return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
      };
    }
    /**
     * Creates a set of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
    var createSet = !(Set && 1 / setToArray(new Set([
      ,
      -0
    ]))[1] == INFINITY) ? noop : function (values) {
      return new Set(values);
    };
    /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
    function createToPairs(keysFunc) {
      return function (object) {
        var tag = getTag(object);
        if (tag == mapTag) {
          return mapToArray(object);
        }
        if (tag == setTag) {
          return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
      };
    }
    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask of wrapper flags.
     *  The bitmask may be composed of the following flags:
     *     1 - `_.bind`
     *     2 - `_.bindKey`
     *     4 - `_.curry` or `_.curryRight` of a bound function
     *     8 - `_.curry`
     *    16 - `_.curryRight`
     *    32 - `_.partial`
     *    64 - `_.partialRight`
     *   128 - `_.rearg`
     *   256 - `_.ary`
     *   512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
      arity = arity === undefined ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;
      if (bitmask & PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials, holdersRight = holders;
        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func);
      var newData = [
        func,
        bitmask,
        thisArg,
        partials,
        holders,
        partialsRight,
        holdersRight,
        argPos,
        ary,
        arity
      ];
      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] == null ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
      if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) {
        bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == BIND_FLAG) {
        var result = createBaseWrapper(func, bitmask, thisArg);
      } else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) {
        result = createCurryWrapper(func, bitmask, arity);
      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !holders.length) {
        result = createPartialWrapper(func, bitmask, thisArg, partials);
      } else {
        result = createHybridWrapper.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setter(result, newData);
    }
    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} customizer The function to customize comparisons.
     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
     *  for more details.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(array);
      if (stacked) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : undefined;
      stack.set(array, other);
      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function (othValue, othIndex) {
              if (!seen.has(othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
                return seen.add(othIndex);
              }
            })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      return result;
    }
    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} customizer The function to customize comparisons.
     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
     *  for more details.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
      case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
          return false;
        }
        return true;
      case boolTag:
      case dateTag:
        // Coerce dates and booleans to numbers, dates to milliseconds and
        // booleans to `1` or `0` treating invalid dates coerced to `NaN` as
        // not equal.
        return +object == +other;
      case errorTag:
        return object.name == other.name && object.message == other.message;
      case numberTag:
        // Treat `NaN` vs. `NaN` as equal.
        return object != +object ? other != +other : object == +other;
      case regexpTag:
      case stringTag:
        // Coerce regexes to strings and treat strings, primitives and objects,
        // as equal. See http://www.ecma-international.org/ecma-262/6.0/#sec-regexp.prototype.tostring
        // for more details.
        return object == other + '';
      case mapTag:
        var convert = mapToArray;
      case setTag:
        var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        // Assume cyclic values are equal.
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= UNORDERED_COMPARE_FLAG;
        stack.set(object, other);
        // Recursively compare objects (susceptible to call stack limits).
        return equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
      }
      return false;
    }
    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} customizer The function to customize comparisons.
     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
     *  for more details.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : baseHas(other, key))) {
          return false;
        }
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      return result;
    }
    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function (func) {
      return metaMap.get(func);
    };
    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = func.name + '', array = realNames[result], length = hasOwnProperty.call(realNames, result) ? array.length : 0;
      while (length--) {
        var data = array[length], otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }
    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
      return object.placeholder;
    }
    /**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */
    function getIteratee() {
      var result = lodash.iteratee || iteratee;
      result = result === iteratee ? baseIteratee : result;
      return arguments.length ? result(arguments[0], arguments[1]) : result;
    }
    /**
     * Gets the "length" property value of `object`.
     *
     * **Note:** This function is used to avoid a
     * [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792) that affects
     * Safari on at least iOS 8.1-8.3 ARM64.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {*} Returns the "length" value.
     */
    var getLength = baseProperty('length');
    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
    }
    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = toPairs(object), length = result.length;
      while (length--) {
        result[length][2] = isStrictComparable(result[length][1]);
      }
      return result;
    }
    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = object[key];
      return isNative(value) ? value : undefined;
    }
    /**
     * Gets the `[[Prototype]]` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {null|Object} Returns the `[[Prototype]]`.
     */
    function getPrototype(value) {
      return nativeGetPrototype(Object(value));
    }
    /**
     * Creates an array of the own enumerable symbol properties of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    function getSymbols(object) {
      // Coerce `object` to an object to avoid non-object errors in V8.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=3443 for more details.
      return getOwnPropertySymbols(Object(object));
    }
    // Fallback for IE < 11.
    if (!getOwnPropertySymbols) {
      getSymbols = function () {
        return [];
      };
    }
    /**
     * Creates an array of the own and inherited enumerable symbol properties
     * of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !getOwnPropertySymbols ? getSymbols : function (object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function getTag(value) {
      return objectToString.call(value);
    }
    // Fallback for data views, maps, sets, and weak maps in IE 11,
    // for data views in Edge, and promises in Node.js.
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function (value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : undefined;
        if (ctorString) {
          switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
          }
        }
        return result;
      };
    }
    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1, length = transforms.length;
      while (++index < length) {
        var data = transforms[index], size = data.size;
        switch (data.type) {
        case 'drop':
          start += size;
          break;
        case 'dropRight':
          end -= size;
          break;
        case 'take':
          end = nativeMin(end, start + size);
          break;
        case 'takeRight':
          start = nativeMax(start, end - size);
          break;
        }
      }
      return {
        'start': start,
        'end': end
      };
    }
    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = isKey(path, object) ? [path] : castPath(path);
      var result, index = -1, length = path.length;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result) {
        return result;
      }
      var length = object ? object.length : 0;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isString(object) || isArguments(object));
    }
    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length, result = array.constructor(length);
      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
      case arrayBufferTag:
        return cloneArrayBuffer(object);
      case boolTag:
      case dateTag:
        return new Ctor(+object);
      case dataViewTag:
        return cloneDataView(object, isDeep);
      case float32Tag:
      case float64Tag:
      case int8Tag:
      case int16Tag:
      case int32Tag:
      case uint8Tag:
      case uint8ClampedTag:
      case uint16Tag:
      case uint32Tag:
        return cloneTypedArray(object, isDeep);
      case mapTag:
        return cloneMap(object, isDeep, cloneFunc);
      case numberTag:
      case stringTag:
        return new Ctor(object);
      case regexpTag:
        return cloneRegExp(object);
      case setTag:
        return cloneSet(object, isDeep, cloneFunc);
      case symbolTag:
        return cloneSymbol(object);
      }
    }
    /**
     * Creates an array of index keys for `object` values of arrays,
     * `arguments` objects, and strings, otherwise `null` is returned.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array|null} Returns index keys, else `null`.
     */
    function indexKeys(object) {
      var length = object ? object.length : undefined;
      if (isLength(length) && (isArray(object) || isString(object) || isArguments(object))) {
        return baseTimes(length, String);
      }
      return null;
    }
    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable(value) {
      return isArray(value) || isArguments(value);
    }
    /**
     * Checks if `value` is a flattenable array and not a `_.matchesProperty`
     * iteratee shorthand.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenableIteratee(value) {
      return isArray(value) && !(value.length == 2 && !isFunction(value[0]));
    }
    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == 'number' || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
    }
    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func), other = lodash[funcName];
      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }
    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
      return value === proto;
    }
    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function (object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
      };
    }
    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (BIND_FLAG | BIND_KEY_FLAG | ARY_FLAG);
      var isCombo = srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG || srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8] || srcBitmask == (ARY_FLAG | REARG_FLAG) && source[7].length <= source[8] && bitmask == CURRY_FLAG;
      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & BIND_FLAG ? 0 : CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;
      return data;
    }
    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
    function mergeDefaults(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        baseMerge(objValue, srcValue, undefined, mergeDefaults, stack.set(srcValue, objValue));
      }
      return objValue;
    }
    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
    }
    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }
    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = function () {
      var count = 0, lastCalled = 0;
      return function (key, value) {
        var stamp = now(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return key;
          }
        } else {
          count = 0;
        }
        return baseSetData(key, value);
      };
    }();
    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoize(function (string) {
      var result = [];
      toString(string).replace(rePropName, function (match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
      });
      return result;
    });
    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = value + '';
      return result == '0' && 1 / value == -INFINITY ? '-0' : result;
    }
    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to process.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + '';
        } catch (e) {
        }
      }
      return '';
    }
    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__ = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }
    /*------------------------------------------------------------------------*/
    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if (guard ? isIterateeCall(array, size, guard) : size === undefined) {
        size = 1;
      } else {
        size = nativeMax(toInteger(size), 0);
      }
      var length = array ? array.length : 0;
      if (!length || size < 1) {
        return [];
      }
      var index = 0, resIndex = 0, result = Array(nativeCeil(length / size));
      while (index < length) {
        result[resIndex++] = baseSlice(array, index, index += size);
      }
      return result;
    }
    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1, length = array ? array.length : 0, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    function concat() {
      var length = arguments.length, args = Array(length ? length - 1 : 0), array = arguments[0], index = length;
      while (index--) {
        args[index - 1] = arguments[index];
      }
      return length ? arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1)) : [];
    }
    /**
     * Creates an array of unique `array` values not included in the other given
     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons. The order of result values is determined by the
     * order they occur in the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([3, 2, 1], [4, 2]);
     * // => [3, 1]
     */
    var difference = rest(function (array, values) {
      return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
    });
    /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. Result values are chosen from the first array.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([3.1, 2.2, 1.3], [4.4, 2.5], Math.floor);
     * // => [3.1, 1.3]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var differenceBy = rest(function (array, values) {
      var iteratee = last(values);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee)) : [];
    });
    /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. Result values
     * are chosen from the first array. The comparator is invoked with two arguments:
     * (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
    var differenceWith = rest(function (array, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator) : [];
    });
    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      n = guard || n === undefined ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }
    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      n = guard || n === undefined ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }
    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Array|Function|Object|string} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate) {
      return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
    }
    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Array|Function|Object|string} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate) {
      return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
    }
    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
    function fill(array, value, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }
    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to search.
     * @param {Array|Function|Object|string} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate) {
      return array && array.length ? baseFindIndex(array, getIteratee(predicate, 3)) : -1;
    }
    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to search.
     * @param {Array|Function|Object|string} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate) {
      return array && array.length ? baseFindIndex(array, getIteratee(predicate, 3), true) : -1;
    }
    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    function flatten(array) {
      var length = array ? array.length : 0;
      return length ? baseFlatten(array, 1) : [];
    }
    /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
    function flattenDeep(array) {
      var length = array ? array.length : 0;
      return length ? baseFlatten(array, INFINITY) : [];
    }
    /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
    function flattenDepth(array, depth) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(array, depth);
    }
    /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['fred', 30], ['barney', 40]]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function fromPairs(pairs) {
      var index = -1, length = pairs ? pairs.length : 0, result = {};
      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }
    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return array && array.length ? array[0] : undefined;
    }
    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
    function indexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      fromIndex = toInteger(fromIndex);
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return baseIndexOf(array, value, fromIndex);
    }
    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      return dropRight(array, 1);
    }
    /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons. The order of result values is determined by the
     * order they occur in the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [4, 2], [1, 2]);
     * // => [2]
     */
    var intersection = rest(function (arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
    });
    /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. Result values are chosen from the first array.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [4.3, 2.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
    var intersectionBy = rest(function (arrays) {
      var iteratee = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
      if (iteratee === last(mapped)) {
        iteratee = undefined;
      } else {
        mapped.pop();
      }
      return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee)) : [];
    });
    /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. Result values are chosen
     * from the first array. The comparator is invoked with two arguments:
     * (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
    var intersectionWith = rest(function (arrays) {
      var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
      if (comparator === last(mapped)) {
        comparator = undefined;
      } else {
        mapped.pop();
      }
      return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined, comparator) : [];
    });
    /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
    function join(array, separator) {
      return array ? nativeJoin.call(array, separator) : '';
    }
    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array ? array.length : 0;
      return length ? array[length - 1] : undefined;
    }
    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      var index = length;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = (index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)) + 1;
      }
      if (value !== value) {
        return indexOfNaN(array, index, true);
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    /**
     * Gets the element at `n` index of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
    function nth(array, n) {
      return array && array.length ? baseNth(array, toInteger(n)) : undefined;
    }
    /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     *
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    var pull = rest(pullAll);
    /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     *
     * _.pullAll(array, [2, 3]);
     * console.log(array);
     * // => [1, 1]
     */
    function pullAll(array, values) {
      return array && array.length && values && values.length ? basePullAll(array, values) : array;
    }
    /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
    function pullAllBy(array, values, iteratee) {
      return array && array.length && values && values.length ? basePullAll(array, values, getIteratee(iteratee)) : array;
    }
    /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
    function pullAllWith(array, values, comparator) {
      return array && array.length && values && values.length ? basePullAll(array, values, undefined, comparator) : array;
    }
    /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [5, 10, 15, 20];
     * var evens = _.pullAt(array, 1, 3);
     *
     * console.log(array);
     * // => [5, 15]
     *
     * console.log(evens);
     * // => [10, 20]
     */
    var pullAt = rest(function (array, indexes) {
      indexes = baseFlatten(indexes, 1);
      var length = array ? array.length : 0, result = baseAt(array, indexes);
      basePullAt(array, arrayMap(indexes, function (index) {
        return isIndex(index, length) ? +index : index;
      }).sort(compareAscending));
      return result;
    });
    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array|Function|Object|string} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1, indexes = [], length = array.length;
      predicate = getIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }
    /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function reverse(array) {
      return array ? nativeReverse.call(array) : array;
    }
    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      } else {
        start = start == null ? 0 : toInteger(start);
        end = end === undefined ? length : toInteger(end);
      }
      return baseSlice(array, start, end);
    }
    /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     *
     * _.sortedIndex([4, 5], 4);
     * // => 0
     */
    function sortedIndex(array, value) {
      return baseSortedIndex(array, value);
    }
    /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var dict = { 'thirty': 30, 'forty': 40, 'fifty': 50 };
     *
     * _.sortedIndexBy(['thirty', 'fifty'], 'forty', _.propertyOf(dict));
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');
     * // => 0
     */
    function sortedIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee));
    }
    /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([1, 1, 2, 2], 2);
     * // => 2
     */
    function sortedIndexOf(array, value) {
      var length = array ? array.length : 0;
      if (length) {
        var index = baseSortedIndex(array, value);
        if (index < length && eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }
    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5], 4);
     * // => 1
     */
    function sortedLastIndex(array, value) {
      return baseSortedIndex(array, value, true);
    }
    /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');
     * // => 1
     */
    function sortedLastIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee), true);
    }
    /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([1, 1, 2, 2], 2);
     * // => 3
     */
    function sortedLastIndexOf(array, value) {
      var length = array ? array.length : 0;
      if (length) {
        var index = baseSortedIndex(array, value, true) - 1;
        if (eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }
    /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
    function sortedUniq(array) {
      return array && array.length ? baseSortedUniq(array) : [];
    }
    /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
    function sortedUniqBy(array, iteratee) {
      return array && array.length ? baseSortedUniq(array, getIteratee(iteratee)) : [];
    }
    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
    function tail(array) {
      return drop(array, 1);
    }
    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n = guard || n === undefined ? 1 : toInteger(n);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }
    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      n = guard || n === undefined ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, n < 0 ? 0 : n, length);
    }
    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Array|Function|Object|string} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
    function takeRightWhile(array, predicate) {
      return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
    }
    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Array|Function|Object|string} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false},
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
    function takeWhile(array, predicate) {
      return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
    }
    /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2, 1], [4, 2], [1, 2]);
     * // => [2, 1, 4]
     */
    var union = rest(function (arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });
    /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1, 1.2], [4.3, 2.4], Math.floor);
     * // => [2.1, 1.2, 4.3]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var unionBy = rest(function (arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee));
    });
    /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var unionWith = rest(function (arrays) {
      var comparator = last(arrays);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
    });
    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each
     * element is kept.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
    function uniq(array) {
      return array && array.length ? baseUniq(array) : [];
    }
    /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniqBy(array, iteratee) {
      return array && array.length ? baseUniq(array, getIteratee(iteratee)) : [];
    }
    /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The comparator is invoked with
     * two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 },  { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
    function uniqWith(array, comparator) {
      return array && array.length ? baseUniq(array, undefined, comparator) : [];
    }
    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     *
     * _.unzip(zipped);
     * // => [['fred', 'barney'], [30, 40], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var length = 0;
      array = arrayFilter(array, function (group) {
        if (isArrayLikeObject(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      return baseTimes(length, function (index) {
        return arrayMap(array, baseProperty(index));
      });
    }
    /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee) {
      if (!(array && array.length)) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      return arrayMap(result, function (group) {
        return apply(iteratee, undefined, group);
      });
    }
    /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([1, 2, 1, 3], 1, 2);
     * // => [3]
     */
    var without = rest(function (array, values) {
      return isArrayLikeObject(array) ? baseDifference(array, values) : [];
    });
    /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [4, 2]);
     * // => [1, 4]
     */
    var xor = rest(function (arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });
    /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [4.3, 2.4], Math.floor);
     * // => [1.2, 4.3]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var xorBy = rest(function (arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee));
    });
    /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The comparator is invoked with
     * two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var xorWith = rest(function (arrays) {
      var comparator = last(arrays);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
    });
    /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    var zip = rest(unzip);
    /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }
    /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
    function zipObjectDeep(props, values) {
      return baseZipObject(props || [], values || [], baseSet);
    }
    /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
    var zipWith = rest(function (arrays) {
      var length = arrays.length, iteratee = length > 1 ? arrays[length - 1] : undefined;
      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
      return unzipWith(arrays, iteratee);
    });
    /*------------------------------------------------------------------------*/
    /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }
    /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }
    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor) {
      return interceptor(value);
    }
    /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths of elements to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     *
     * _(['a', 'b', 'c']).at(0, 2).value();
     * // => ['a', 'c']
     */
    var wrapperAt = rest(function (paths) {
      paths = baseFlatten(paths, 1);
      var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function (object) {
          return baseAt(object, paths);
        };
      if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
        return this.thru(interceptor);
      }
      value = value.slice(start, +start + (length ? 1 : 0));
      value.__actions__.push({
        'func': thru,
        'args': [interceptor],
        'thisArg': undefined
      });
      return new LodashWrapper(value, this.__chain__).thru(function (array) {
        if (length && !array.length) {
          array.push(undefined);
        }
        return array;
      });
    });
    /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }
    /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }
    /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */
    function wrapperNext() {
      if (this.__values__ === undefined) {
        this.__values__ = toArray(this.value());
      }
      var done = this.__index__ >= this.__values__.length, value = done ? undefined : this.__values__[this.__index__++];
      return {
        'done': done,
        'value': value
      };
    }
    /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */
    function wrapperToIterator() {
      return this;
    }
    /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result, parent = this;
      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        clone.__index__ = 0;
        clone.__values__ = undefined;
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }
    /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({
          'func': thru,
          'args': [reverse],
          'thisArg': undefined
        });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(reverse);
    }
    /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }
    /*------------------------------------------------------------------------*/
    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function (result, value, key) {
      hasOwnProperty.call(result, key) ? ++result[key] : result[key] = 1;
    });
    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [predicate=_.identity]
     *  The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }
    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     */
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, getIteratee(predicate, 3));
    }
    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to search.
     * @param {Array|Function|Object|string} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
    function find(collection, predicate) {
      predicate = getIteratee(predicate, 3);
      if (isArray(collection)) {
        var index = baseFindIndex(collection, predicate);
        return index > -1 ? collection[index] : undefined;
      }
      return baseFind(collection, predicate, baseEach);
    }
    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to search.
     * @param {Array|Function|Object|string} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    function findLast(collection, predicate) {
      predicate = getIteratee(predicate, 3);
      if (isArray(collection)) {
        var index = baseFindIndex(collection, predicate, true);
        return index > -1 ? collection[index] : undefined;
      }
      return baseFind(collection, predicate, baseEachRight);
    }
    /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }
    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMapDeep(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), INFINITY);
    }
    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */
    function flatMapDepth(collection, iteratee, depth) {
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(map(collection, iteratee), depth);
    }
    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _([1, 2]).forEach(function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, getIteratee(iteratee, 3));
    }
    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */
    function forEachRight(collection, iteratee) {
      var func = isArray(collection) ? arrayEachRight : baseEachRight;
      return func(collection, getIteratee(iteratee, 3));
    }
    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function (result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        result[key] = [value];
      }
    });
    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.includes('pebbles', 'eb');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
    }
    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `methodName` is a function, it's
     * invoked for and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invokeMap = rest(function (collection, path, args) {
      var index = -1, isFunc = typeof path == 'function', isProp = isKey(path), result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function (value) {
        var func = isFunc ? path : isProp && value != null ? value[path] : undefined;
        result[++index] = func ? apply(func, value, args) : baseInvoke(value, path, args);
      });
      return result;
    });
    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */
    var keyBy = createAggregator(function (result, value, key) {
      result[key] = value;
    });
    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, getIteratee(iteratee, 3));
    }
    /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
    function orderBy(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = guard ? undefined : orders;
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection, iteratees, orders);
    }
    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function (result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function () {
      return [
        [],
        []
      ];
    });
    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }
    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
    }
    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getIteratee(predicate, 3);
      return func(collection, function (value, index, collection) {
        return !predicate(value, index, collection);
      });
    }
    /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */
    function sample(collection) {
      var array = isArrayLike(collection) ? collection : values(collection), length = array.length;
      return length > 0 ? array[baseRandom(0, length - 1)] : undefined;
    }
    /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */
    function sampleSize(collection, n, guard) {
      var index = -1, result = toArray(collection), length = result.length, lastIndex = length - 1;
      if (guard ? isIterateeCall(collection, n, guard) : n === undefined) {
        n = 1;
      } else {
        n = baseClamp(toInteger(n), 0, length);
      }
      while (++index < n) {
        var rand = baseRandom(index, lastIndex), value = result[rand];
        result[rand] = result[index];
        result[index] = value;
      }
      result.length = n;
      return result;
    }
    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      return sampleSize(collection, MAX_ARRAY_LENGTH);
    }
    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        var result = collection.length;
        return result && isString(collection) ? stringSize(collection) : result;
      }
      if (isObjectLike(collection)) {
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
      }
      return keys(collection).length;
    }
    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [predicate=_.identity]
     *  The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }
    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Array|Array[]|Function|Function[]|Object|Object[]|string|string[])}
     *  [iteratees=[_.identity]] The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, function(o) { return o.user; });
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
     *
     * _.sortBy(users, 'user', function(o) {
     *   return Math.floor(o.age / 10);
     * });
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
    var sortBy = rest(function (collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      iteratees = iteratees.length == 1 && isArray(iteratees[0]) ? iteratees[0] : baseFlatten(iteratees, 1, isFlattenableIteratee);
      return baseOrderBy(collection, iteratees, []);
    });
    /*------------------------------------------------------------------------*/
    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @type {Function}
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred function to be invoked.
     */
    var now = Date.now;
    /*------------------------------------------------------------------------*/
    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */
    function after(n, func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function () {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }
    /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      n = guard ? undefined : n;
      n = func && n == null ? func.length : n;
      return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }
    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => allows adding up to 4 contacts to the list
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function () {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }
    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind` this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var greet = function(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * };
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = rest(function (func, thisArg, partials) {
      var bitmask = BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(func, bitmask, thisArg, partials, holders);
    });
    /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = rest(function (object, key, partials) {
      var bitmask = BIND_FLAG | BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bindKey));
        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(key, bitmask, object, partials, holders);
    });
    /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrapper(func, CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curry.placeholder;
      return result;
    }
    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrapper(func, CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }
    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide an options object to indicate whether `func` should be invoked on
     * the leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent calls
     * to the debounced function return the result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime = 0, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result = wait - timeSinceLastCall;
        return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return !lastCallTime || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        clearTimeout(timerId);
        timerId = undefined;
        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }
      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastCallTime = lastInvokeTime = 0;
        lastArgs = lastThis = timerId = undefined;
      }
      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one or more milliseconds.
     */
    var defer = rest(function (func, args) {
      return baseDelay(func, 1, args);
    });
    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */
    var delay = rest(function (func, wait, args) {
      return baseDelay(func, toNumber(wait) || 0, args);
    });
    /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */
    function flip(func) {
      return createWrapper(func, FLIP_FLAG);
    }
    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || resolver && typeof resolver != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function () {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    // Assign cache to `_.memoize`.
    memoize.Cache = MapCache;
    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function () {
        return !predicate.apply(this, arguments);
      };
    }
    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` invokes `createApplication` once
     */
    function once(func) {
      return before(2, func);
    }
    /**
     * Creates a function that invokes `func` with arguments transformed by
     * corresponding `transforms`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Array|Array[]|Function|Function[]|Object|Object[]|string|string[])}
     *  [transforms[_.identity]] The functions to transform.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, square, doubled);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */
    var overArgs = rest(function (func, transforms) {
      transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1, isFlattenableIteratee), baseUnary(getIteratee()));
      var funcsLength = transforms.length;
      return rest(function (args) {
        var index = -1, length = nativeMin(args.length, funcsLength);
        while (++index < length) {
          args[index] = transforms[index].call(this, args[index]);
        }
        return apply(func, this, args);
      });
    });
    /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = rest(function (func, partials) {
      var holders = replaceHolders(partials, getHolder(partial));
      return createWrapper(func, PARTIAL_FLAG, undefined, partials, holders);
    });
    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = rest(function (func, partials) {
      var holders = replaceHolders(partials, getHolder(partialRight));
      return createWrapper(func, PARTIAL_RIGHT_FLAG, undefined, partials, holders);
    });
    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, 2, 0, 1);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */
    var rearg = rest(function (func, indexes) {
      return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes, 1));
    });
    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function rest(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = nativeMax(start === undefined ? func.length - 1 : toInteger(start), 0);
      return function () {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        switch (start) {
        case 0:
          return func.call(this, array);
        case 1:
          return func.call(this, args[0], array);
        case 2:
          return func.call(this, args[0], args[1], array);
        }
        var otherArgs = Array(start + 1);
        index = -1;
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
      };
    }
    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/6.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start === undefined ? 0 : nativeMax(toInteger(start), 0);
      return rest(function (args) {
        var array = args[start], otherArgs = castSlice(args, 0, start);
        if (array) {
          arrayPush(otherArgs, array);
        }
        return apply(func, this, otherArgs);
      });
    }
    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide an options object to indicate whether
     * `func` should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }
    /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */
    function unary(func) {
      return ary(func, 1);
    }
    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Any additional arguments provided to the function are
     * appended to those provided to the wrapper function. The wrapper is invoked
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      wrapper = wrapper == null ? identity : wrapper;
      return partial(wrapper, value);
    }
    /*------------------------------------------------------------------------*/
    /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }
    /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
    function clone(value) {
      return baseClone(value, false, true);
    }
    /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */
    function cloneWith(value, customizer) {
      return baseClone(value, false, true, customizer);
    }
    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return baseClone(value, true, true);
    }
    /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
    function cloneDeepWith(value, customizer) {
      return baseClone(value, true, true, customizer);
    }
    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'fred' };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    var gt = createRelationalOperation(baseGt);
    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    var gte = createRelationalOperation(function (value, other) {
      return value >= other;
    });
    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
      return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
    }
    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @type {Function}
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified,
     *  else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;
    /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified,
     *  else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */
    function isArrayBuffer(value) {
      return isObjectLike(value) && objectToString.call(value) == arrayBufferTag;
    }
    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(getLength(value)) && !isFunction(value);
    }
    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified,
     *  else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
    }
    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = !Buffer ? constant(false) : function (value) {
      return value instanceof Buffer;
    };
    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified,
     *  else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    function isDate(value) {
      return isObjectLike(value) && objectToString.call(value) == dateTag;
    }
    /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element,
     *  else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
    }
    /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (isArrayLike(value) && (isArray(value) || isString(value) || isFunction(value.splice) || isArguments(value) || isBuffer(value))) {
        return !value.length;
      }
      if (isObjectLike(value)) {
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return !(nonEnumShadows && keys(value).length);
    }
    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are **not** supported.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent,
     *  else `false`.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'fred' };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent,
     *  else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return result === undefined ? baseIsEqual(value, other, customizer) : !!result;
    }
    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object,
     *  else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      return objectToString.call(value) == errorTag || typeof value.message == 'string' && typeof value.name == 'string';
    }
    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number,
     *  else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified,
     *  else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 8 which returns 'object' for typed array and weak map constructors,
      // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
      var tag = isObject(value) ? objectToString.call(value) : '';
      return tag == funcTag || tag == genTag;
    }
    /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */
    function isInteger(value) {
      return typeof value == 'number' && value == toInteger(value);
    }
    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This function is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length,
     *  else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return !!value && typeof value == 'object';
    }
    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified,
     *  else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    function isMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }
    /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values. This method is
     * equivalent to a `_.matches` function when `source` is partially applied.
     *
     * **Note:** This method supports comparing the same values as `_.isEqual`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.isMatch(object, { 'age': 40 });
     * // => true
     *
     * _.isMatch(object, { 'age': 36 });
     * // => false
     */
    function isMatch(object, source) {
      return object === source || baseIsMatch(object, source, getMatchData(source));
    }
    /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */
    function isMatchWith(object, source, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseIsMatch(object, source, getMatchData(source), customizer);
    }
    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some
      // ActiveX objects in IE.
      return isNumber(value) && value != +value;
    }
    /**
     * Checks if `value` is a native function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (!isObject(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }
    /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
    function isNil(value) {
      return value == null;
    }
    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified,
     *  else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' || isObjectLike(value) && objectToString.call(value) == numberTag;
    }
    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object,
     *  else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified,
     *  else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    function isRegExp(value) {
      return isObject(value) && objectToString.call(value) == regexpTag;
    }
    /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer,
     *  else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */
    function isSafeInteger(value) {
      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
    }
    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified,
     *  else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    function isSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }
    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified,
     *  else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified,
     *  else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified,
     *  else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    function isTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }
    /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified,
     *  else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */
    function isWeakMap(value) {
      return isObjectLike(value) && getTag(value) == weakMapTag;
    }
    /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified,
     *  else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */
    function isWeakSet(value) {
      return isObjectLike(value) && objectToString.call(value) == weakSetTag;
    }
    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    var lt = createRelationalOperation(baseLt);
    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    var lte = createRelationalOperation(function (value, other) {
      return value <= other;
    });
    /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (iteratorSymbol && value[iteratorSymbol]) {
        return iteratorToArray(value[iteratorSymbol]());
      }
      var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
      return func(value);
    }
    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    /**
     * Converts `value` to an integer.
     *
     * **Note:** This function is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
    function toLength(value) {
      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
    }
    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = isFunction(value.valueOf) ? value.valueOf() : value;
        value = isObject(other) ? other + '' : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */
    function toSafeInteger(value) {
      return baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    }
    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }
    /*------------------------------------------------------------------------*/
    /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.c = 3;
     * }
     *
     * function Bar() {
     *   this.e = 5;
     * }
     *
     * Foo.prototype.d = 4;
     * Bar.prototype.f = 6;
     *
     * _.assign({ 'a': 1 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3, 'e': 5 }
     */
    var assign = createAssigner(function (object, source) {
      if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });
    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * function Bar() {
     *   this.d = 4;
     * }
     *
     * Foo.prototype.c = 3;
     * Bar.prototype.e = 5;
     *
     * _.assignIn({ 'a': 1 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5 }
     */
    var assignIn = createAssigner(function (object, source) {
      if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keysIn(source), object);
        return;
      }
      for (var key in source) {
        assignValue(object, key, source[key]);
      }
    });
    /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });
    /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignWith = createAssigner(function (object, source, srcIndex, customizer) {
      copyObject(source, keys(source), object, customizer);
    });
    /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths of elements to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     *
     * _.at(['a', 'b', 'c'], 0, 2);
     * // => ['a', 'c']
     */
    var at = rest(function (object, paths) {
      return baseAt(object, baseFlatten(paths, 1));
    });
    /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties ? baseAssign(result, properties) : result;
    }
    /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    var defaults = rest(function (args) {
      args.push(undefined, assignInDefaults);
      return apply(assignInWith, undefined, args);
    });
    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
     * // => { 'user': { 'name': 'barney', 'age': 36 } }
     *
     */
    var defaultsDeep = rest(function (args) {
      args.push(undefined, mergeDefaults);
      return apply(mergeWith, undefined, args);
    });
    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to search.
     * @param {Array|Function|Object|string} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate) {
      return baseFind(object, getIteratee(predicate, 3), baseForOwn, true);
    }
    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to search.
     * @param {Array|Function|Object|string} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate) {
      return baseFind(object, getIteratee(predicate, 3), baseForOwnRight, true);
    }
    /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */
    function forIn(object, iteratee) {
      return object == null ? object : baseFor(object, getIteratee(iteratee, 3), keysIn);
    }
    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */
    function forInRight(object, iteratee) {
      return object == null ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn);
    }
    /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forOwn(object, iteratee) {
      return object && baseForOwn(object, getIteratee(iteratee, 3));
    }
    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */
    function forOwnRight(object, iteratee) {
      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
    }
    /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */
    function functions(object) {
      return object == null ? [] : baseFunctions(object, keys(object));
    }
    /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */
    function functionsIn(object) {
      return object == null ? [] : baseFunctions(object, keysIn(object));
    }
    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is used in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }
    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }
    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
    var invert = createInverter(function (result, value, key) {
      result[value] = key;
    }, constant(identity));
    /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */
    var invertBy = createInverter(function (result, value, key) {
      if (hasOwnProperty.call(result, value)) {
        result[value].push(key);
      } else {
        result[value] = [key];
      }
    }, getIteratee);
    /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */
    var invoke = rest(baseInvoke);
    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      var isProto = isPrototype(object);
      if (!(isProto || isArrayLike(object))) {
        return baseKeys(object);
      }
      var indexes = indexKeys(object), skipIndexes = !!indexes, result = indexes || [], length = result.length;
      for (var key in object) {
        if (baseHas(object, key) && !(skipIndexes && (key == 'length' || isIndex(key, length))) && !(isProto && key == 'constructor')) {
          result.push(key);
        }
      }
      return result;
    }
    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      var index = -1, isProto = isPrototype(object), props = baseKeysIn(object), propsLength = props.length, indexes = indexKeys(object), skipIndexes = !!indexes, result = indexes || [], length = result.length;
      while (++index < propsLength) {
        var key = props[index];
        if (!(skipIndexes && (key == 'length' || isIndex(key, length))) && !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);
      baseForOwn(object, function (value, key, object) {
        result[iteratee(value, key, object)] = value;
      });
      return result;
    }
    /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);
      baseForOwn(object, function (value, key, object) {
        result[key] = iteratee(value, key, object);
      });
      return result;
    }
    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var users = {
     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
     * };
     *
     * var ages = {
     *   'data': [{ 'age': 36 }, { 'age': 40 }]
     * };
     *
     * _.merge(users, ages);
     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
     */
    var merge = createAssigner(function (object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with seven arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var other = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
     */
    var mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });
    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable string keyed properties of `object` that are
     * not omitted.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [props] The property identifiers to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
    var omit = rest(function (object, props) {
      if (object == null) {
        return {};
      }
      props = arrayMap(baseFlatten(props, 1), toKey);
      return basePick(object, baseDifference(getAllKeysIn(object), props));
    });
    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Array|Function|Object|string} [predicate=_.identity]
     *  The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      predicate = getIteratee(predicate);
      return basePickBy(object, function (value, key) {
        return !predicate(value, key);
      });
    }
    /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [props] The property identifiers to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */
    var pick = rest(function (object, props) {
      return object == null ? {} : basePick(object, arrayMap(baseFlatten(props, 1), toKey));
    });
    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Array|Function|Object|string} [predicate=_.identity]
     *  The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      return object == null ? {} : basePickBy(object, getIteratee(predicate));
    }
    /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = -1, length = path.length;
      // Ensure the loop is entered when path is empty.
      if (!length) {
        object = undefined;
        length = 1;
      }
      while (++index < length) {
        var value = object == null ? undefined : object[toKey(path[index])];
        if (value === undefined) {
          index = length;
          value = defaultValue;
        }
        object = isFunction(value) ? value.call(object) : value;
      }
      return object;
    }
    /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }
    /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */
    function setWith(object, path, value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseSet(object, path, value, customizer);
    }
    /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
    var toPairs = createToPairs(keys);
    /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */
    var toPairsIn = createToPairs(keysIn);
    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. The iteratee is invoked
     * with four arguments: (accumulator, value, key, object). Iteratee functions
     * may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function transform(object, iteratee, accumulator) {
      var isArr = isArray(object) || isTypedArray(object);
      iteratee = getIteratee(iteratee, 4);
      if (accumulator == null) {
        if (isArr || isObject(object)) {
          var Ctor = object.constructor;
          if (isArr) {
            accumulator = isArray(object) ? new Ctor() : [];
          } else {
            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
          }
        } else {
          accumulator = {};
        }
      }
      (isArr ? arrayEach : baseForOwn)(object, function (value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }
    /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */
    function unset(object, path) {
      return object == null ? true : baseUnset(object, path);
    }
    /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */
    function update(object, path, updater) {
      return object == null ? object : baseUpdate(object, path, castFunction(updater));
    }
    /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */
    function updateWith(object, path, updater, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
    }
    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object ? baseValues(object, keys(object)) : [];
    }
    /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return object == null ? [] : baseValues(object, keysIn(object));
    }
    /*------------------------------------------------------------------------*/
    /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */
    function clamp(number, lower, upper) {
      if (upper === undefined) {
        upper = lower;
        lower = undefined;
      }
      if (upper !== undefined) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== undefined) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number), lower, upper);
    }
    /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
    function inRange(number, start, end) {
      start = toNumber(start) || 0;
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = toNumber(end) || 0;
      }
      number = toNumber(number);
      return baseInRange(number, start, end);
    }
    /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(lower, upper, floating) {
      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
        upper = floating = undefined;
      }
      if (floating === undefined) {
        if (typeof upper == 'boolean') {
          floating = upper;
          upper = undefined;
        } else if (typeof lower == 'boolean') {
          floating = lower;
          lower = undefined;
        }
      }
      if (lower === undefined && upper === undefined) {
        lower = 0;
        upper = 1;
      } else {
        lower = toNumber(lower) || 0;
        if (upper === undefined) {
          upper = lower;
          lower = 0;
        } else {
          upper = toNumber(upper) || 0;
        }
      }
      if (lower > upper) {
        var temp = lower;
        lower = upper;
        upper = temp;
      }
      if (floating || lower % 1 || upper % 1) {
        var rand = nativeRandom();
        return nativeMin(lower + rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1))), upper);
      }
      return baseRandom(lower, upper);
    }
    /*------------------------------------------------------------------------*/
    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function (result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });
    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }
    /**
     * Deburrs `string` by converting
     * [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * to basic latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
    }
    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search from.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = toString(string);
      target = baseToString(target);
      var length = string.length;
      position = position === undefined ? length : baseClamp(toInteger(position), 0, length);
      position -= target.length;
      return position >= 0 && string.indexOf(target, position) == position;
    }
    /**
     * Converts the characters "&", "<", ">", '"', "'", and "\`" in `string` to
     * their corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * Backticks are escaped because in IE < 9, they can break out of
     * attribute values or HTML comments. See [#59](https://html5sec.org/#59),
     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
     * [#133](https://html5sec.org/#133) of the
     * [HTML5 Security Cheatsheet](https://html5sec.org/) for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      string = toString(string);
      return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
    }
    /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = toString(string);
      return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, '\\$&') : string;
    }
    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function (result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });
    /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */
    var lowerCase = createCompounder(function (result, word, index) {
      return result + (index ? ' ' : '') + word.toLowerCase();
    });
    /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */
    var lowerFirst = createCaseFirst('toLowerCase');
    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = toString(string);
      length = toInteger(length);
      var strLength = length ? stringSize(string) : 0;
      if (!length || strLength >= length) {
        return string;
      }
      var mid = (length - strLength) / 2;
      return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
    }
    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
    function padEnd(string, length, chars) {
      string = toString(string);
      length = toInteger(length);
      var strLength = length ? stringSize(string) : 0;
      return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
    }
    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
    function padStart(string, length, chars) {
      string = toString(string);
      length = toInteger(length);
      var strLength = length ? stringSize(string) : 0;
      return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
    }
    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      // Chrome fails to trim leading <BOM> whitespace characters.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=3109 for more details.
      if (guard || radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      string = toString(string).replace(reTrim, '');
      return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
    }
    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n, guard) {
      if (guard ? isIterateeCall(string, n, guard) : n === undefined) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      return baseRepeat(toString(string), n);
    }
    /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */
    function replace() {
      var args = arguments, string = toString(args[0]);
      return args.length < 3 ? string : nativeReplace.call(string, args[1], args[2]);
    }
    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function (result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });
    /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */
    function split(string, separator, limit) {
      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
        separator = limit = undefined;
      }
      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
      if (!limit) {
        return [];
      }
      string = toString(string);
      if (string && (typeof separator == 'string' || separator != null && !isRegExp(separator))) {
        separator = baseToString(separator);
        if (separator == '' && reHasComplexSymbol.test(string)) {
          return castSlice(stringToArray(string), 0, limit);
        }
      }
      return nativeSplit.call(string, separator, limit);
    }
    /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */
    var startCase = createCompounder(function (result, word, index) {
      return result + (index ? ' ' : '') + upperFirst(word);
    });
    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = toString(string);
      position = baseClamp(toInteger(position), 0, string.length);
      return string.lastIndexOf(baseToString(target), position) == position;
    }
    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES delimiter as an alternative to the default "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, guard) {
      // Based on John Resig's `tmpl` implementation
      // (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;
      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      string = toString(string);
      options = assignInWith({}, options, settings, assignInDefaults);
      var imports = assignInWith({}, options.imports, settings.imports, assignInDefaults), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
      var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = '__p += \'';
      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
      // Use a sourceURL for easier debugging.
      var sourceURL = '//# sourceURL=' + ('sourceURL' in options ? options.sourceURL : 'lodash.templateSources[' + ++templateCounter + ']') + '\n';
      string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);
        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += '\' +\n__e(' + escapeValue + ') +\n\'';
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += '\';\n' + evaluateValue + ';\n__p += \'';
        }
        if (interpolateValue) {
          source += '\' +\n((__t = (' + interpolateValue + ')) == null ? \'\' : __t) +\n\'';
        }
        index = offset + match.length;
        // The JS engine embedded in Adobe products needs `match` returned in
        // order to produce the correct `offset` value.
        return match;
      });
      source += '\';\n';
      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + 'var __t, __p = \'\'' + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + 'function print() { __p += __j.call(arguments, \'\') }\n' : ';\n') + source + 'return __p\n}';
      var result = attempt(function () {
        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
      });
      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }
    /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */
    function toLower(value) {
      return toString(value).toLowerCase();
    }
    /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */
    function toUpper(value) {
      return toString(value).toUpperCase();
    }
    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrim, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
      return castSlice(strSymbols, start, end).join('');
    }
    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimEnd(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimEnd, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
      return castSlice(strSymbols, 0, end).join('');
    }
    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimStart(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimStart, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
      return castSlice(strSymbols, start).join('');
    }
    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function truncate(string, options) {
      var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
      if (isObject(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger(options.length) : length;
        omission = 'omission' in options ? baseToString(options.omission) : omission;
      }
      string = toString(string);
      var strLength = string.length;
      if (reHasComplexSymbol.test(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string;
      }
      var end = length - stringSize(omission);
      if (end < 1) {
        return omission;
      }
      var result = strSymbols ? castSlice(strSymbols, 0, end).join('') : string.slice(0, end);
      if (separator === undefined) {
        return result + omission;
      }
      if (strSymbols) {
        end += result.length - end;
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match, substring = result;
          if (!separator.global) {
            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
          }
          separator.lastIndex = 0;
          while (match = separator.exec(substring)) {
            var newEnd = match.index;
          }
          result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
      } else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }
    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = toString(string);
      return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
    }
    /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */
    var upperCase = createCompounder(function (result, word, index) {
      return result + (index ? ' ' : '') + word.toUpperCase();
    });
    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');
    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? undefined : pattern;
      if (pattern === undefined) {
        pattern = reHasComplexWord.test(string) ? reComplexWord : reBasicWord;
      }
      return string.match(pattern) || [];
    }
    /*------------------------------------------------------------------------*/
    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = rest(function (func, args) {
      try {
        return apply(func, undefined, args);
      } catch (e) {
        return isError(e) ? e : new Error(e);
      }
    });
    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, 'onClick');
     * jQuery(element).on('click', view.onClick);
     * // => Logs 'clicked docs' when clicked.
     */
    var bindAll = rest(function (object, methodNames) {
      arrayEach(baseFlatten(methodNames, 1), function (key) {
        key = toKey(key);
        object[key] = bind(object[key], object);
      });
      return object;
    });
    /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.constant(true),                _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */
    function cond(pairs) {
      var length = pairs ? pairs.length : 0, toIteratee = getIteratee();
      pairs = !length ? [] : arrayMap(pairs, function (pair) {
        if (typeof pair[1] != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return [
          toIteratee(pair[0]),
          pair[1]
        ];
      });
      return rest(function (args) {
        var index = -1;
        while (++index < length) {
          var pair = pairs[index];
          if (apply(pair[0], this, args)) {
            return apply(pair[1], this, args);
          }
        }
      });
    }
    /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.filter(users, _.conforms({ 'age': _.partial(_.gt, _, 38) }));
     * // => [{ 'user': 'fred', 'age': 40 }]
     */
    function conforms(source) {
      return baseConforms(baseClone(source, true));
    }
    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var getter = _.constant(object);
     *
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function () {
        return value;
      };
    }
    /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] Functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow(_.add, square);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();
    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] Functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight(square, _.add);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);
    /**
     * This method returns the first argument given to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }
    /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */
    function iteratee(func) {
      return baseIteratee(typeof func == 'function' ? func : baseClone(func, true));
    }
    /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`. The created function is equivalent to
     * `_.isMatch` with a `source` partially applied.
     *
     * **Note:** This method supports comparing the same values as `_.isEqual`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, true));
    }
    /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** This method supports comparing the same values as `_.isEqual`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * _.find(users, _.matchesProperty('user', 'fred'));
     * // => { 'user': 'fred' }
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, true));
    }
    /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */
    var method = rest(function (path, args) {
      return function (object) {
        return baseInvoke(object, path, args);
      };
    });
    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = rest(function (object, args) {
      return function (path) {
        return baseInvoke(object, path, args);
      };
    });
    /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      var props = keys(source), methodNames = baseFunctions(source, props);
      if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
        options = source;
        source = object;
        object = this;
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = !(isObject(options) && 'chain' in options) || !!options.chain, isFunc = isFunction(object);
      arrayEach(methodNames, function (methodName) {
        var func = source[methodName];
        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = function () {
            var chainAll = this.__chain__;
            if (chain || chainAll) {
              var result = object(this.__wrapped__), actions = result.__actions__ = copyArray(this.__actions__);
              actions.push({
                'func': func,
                'args': arguments,
                'thisArg': object
              });
              result.__chain__ = chainAll;
              return result;
            }
            return func.apply(object, arrayPush([this.value()], arguments));
          };
        }
      });
      return object;
    }
    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      if (root._ === this) {
        root._ = oldDash;
      }
      return this;
    }
    /**
     * A no-operation function that returns `undefined` regardless of the
     * arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
    }
    /**
     * Creates a function that gets the argument at `n` index. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */
    function nthArg(n) {
      n = toInteger(n);
      return rest(function (args) {
        return baseNth(args, n);
      });
    }
    /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Array|Array[]|Function|Function[]|Object|Object[]|string|string[])}
     *  [iteratees=[_.identity]] The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over(Math.max, Math.min);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */
    var over = createOver(arrayMap);
    /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Array|Array[]|Function|Function[]|Object|Object[]|string|string[])}
     *  [predicates=[_.identity]] The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery(Boolean, isFinite);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */
    var overEvery = createOver(arrayEvery);
    /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Array|Array[]|Function|Function[]|Object|Object[]|string|string[])}
     *  [predicates=[_.identity]] The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome(Boolean, isFinite);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     */
    var overSome = createOver(arraySome);
    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function (path) {
        return object == null ? undefined : baseGet(object, path);
      };
    }
    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    var range = createRange();
    /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */
    var rangeRight = createRange(true);
    /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(true));
     * // => [true, true, true, true]
     */
    function times(n, iteratee) {
      n = toInteger(n);
      if (n < 1 || n > MAX_SAFE_INTEGER) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
      iteratee = getIteratee(iteratee);
      n -= MAX_ARRAY_LENGTH;
      var result = baseTimes(length, iteratee);
      while (++index < n) {
        iteratee(index);
      }
      return result;
    }
    /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     *
     * var path = ['a', 'b', 'c'],
     *     newPath = _.toPath(path);
     *
     * console.log(newPath);
     * // => ['a', 'b', 'c']
     *
     * console.log(path === newPath);
     * // => false
     */
    function toPath(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(value));
    }
    /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }
    /*------------------------------------------------------------------------*/
    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    var add = createMathOperation(function (augend, addend) {
      return augend + addend;
    });
    /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');
    /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */
    var divide = createMathOperation(function (dividend, divisor) {
      return dividend / divisor;
    });
    /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');
    /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
    function max(array) {
      return array && array.length ? baseExtremum(array, identity, baseGt) : undefined;
    }
    /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */
    function maxBy(array, iteratee) {
      return array && array.length ? baseExtremum(array, getIteratee(iteratee), baseGt) : undefined;
    }
    /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */
    function mean(array) {
      return baseMean(array, identity);
    }
    /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */
    function meanBy(array, iteratee) {
      return baseMean(array, getIteratee(iteratee));
    }
    /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
    function min(array) {
      return array && array.length ? baseExtremum(array, identity, baseLt) : undefined;
    }
    /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */
    function minBy(array, iteratee) {
      return array && array.length ? baseExtremum(array, getIteratee(iteratee), baseLt) : undefined;
    }
    /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */
    var multiply = createMathOperation(function (multiplier, multiplicand) {
      return multiplier * multiplicand;
    });
    /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');
    /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */
    var subtract = createMathOperation(function (minuend, subtrahend) {
      return minuend - subtrahend;
    });
    /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
    function sum(array) {
      return array && array.length ? baseSum(array, identity) : 0;
    }
    /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */
    function sumBy(array, iteratee) {
      return array && array.length ? baseSum(array, getIteratee(iteratee)) : 0;
    }
    /*------------------------------------------------------------------------*/
    // Add methods that return wrapped values in chain sequences.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.assignIn = assignIn;
    lodash.assignInWith = assignInWith;
    lodash.assignWith = assignWith;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.castArray = castArray;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.concat = concat;
    lodash.cond = cond;
    lodash.conforms = conforms;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.differenceBy = differenceBy;
    lodash.differenceWith = differenceWith;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatMap = flatMap;
    lodash.flatMapDeep = flatMapDeep;
    lodash.flatMapDepth = flatMapDepth;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flattenDepth = flattenDepth;
    lodash.flip = flip;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.fromPairs = fromPairs;
    lodash.functions = functions;
    lodash.functionsIn = functionsIn;
    lodash.groupBy = groupBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.intersectionBy = intersectionBy;
    lodash.intersectionWith = intersectionWith;
    lodash.invert = invert;
    lodash.invertBy = invertBy;
    lodash.invokeMap = invokeMap;
    lodash.iteratee = iteratee;
    lodash.keyBy = keyBy;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mergeWith = mergeWith;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.nthArg = nthArg;
    lodash.omit = omit;
    lodash.omitBy = omitBy;
    lodash.once = once;
    lodash.orderBy = orderBy;
    lodash.over = over;
    lodash.overArgs = overArgs;
    lodash.overEvery = overEvery;
    lodash.overSome = overSome;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pickBy = pickBy;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAll = pullAll;
    lodash.pullAllBy = pullAllBy;
    lodash.pullAllWith = pullAllWith;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rangeRight = rangeRight;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.reverse = reverse;
    lodash.sampleSize = sampleSize;
    lodash.set = set;
    lodash.setWith = setWith;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortedUniq = sortedUniq;
    lodash.sortedUniqBy = sortedUniqBy;
    lodash.split = split;
    lodash.spread = spread;
    lodash.tail = tail;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.toArray = toArray;
    lodash.toPairs = toPairs;
    lodash.toPairsIn = toPairsIn;
    lodash.toPath = toPath;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.unary = unary;
    lodash.union = union;
    lodash.unionBy = unionBy;
    lodash.unionWith = unionWith;
    lodash.uniq = uniq;
    lodash.uniqBy = uniqBy;
    lodash.uniqWith = uniqWith;
    lodash.unset = unset;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.update = update;
    lodash.updateWith = updateWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.without = without;
    lodash.words = words;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.xorBy = xorBy;
    lodash.xorWith = xorWith;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipObjectDeep = zipObjectDeep;
    lodash.zipWith = zipWith;
    // Add aliases.
    lodash.entries = toPairs;
    lodash.entriesIn = toPairsIn;
    lodash.extend = assignIn;
    lodash.extendWith = assignInWith;
    // Add methods to `lodash.prototype`.
    mixin(lodash, lodash);
    /*------------------------------------------------------------------------*/
    // Add methods that return unwrapped values in chain sequences.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clamp = clamp;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.cloneDeepWith = cloneDeepWith;
    lodash.cloneWith = cloneWith;
    lodash.deburr = deburr;
    lodash.divide = divide;
    lodash.endsWith = endsWith;
    lodash.eq = eq;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.floor = floor;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.hasIn = hasIn;
    lodash.head = head;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.invoke = invoke;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isArrayBuffer = isArrayBuffer;
    lodash.isArrayLike = isArrayLike;
    lodash.isArrayLikeObject = isArrayLikeObject;
    lodash.isBoolean = isBoolean;
    lodash.isBuffer = isBuffer;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isEqualWith = isEqualWith;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isInteger = isInteger;
    lodash.isLength = isLength;
    lodash.isMap = isMap;
    lodash.isMatch = isMatch;
    lodash.isMatchWith = isMatchWith;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNil = isNil;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isObjectLike = isObjectLike;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isSafeInteger = isSafeInteger;
    lodash.isSet = isSet;
    lodash.isString = isString;
    lodash.isSymbol = isSymbol;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.isWeakMap = isWeakMap;
    lodash.isWeakSet = isWeakSet;
    lodash.join = join;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lowerCase = lowerCase;
    lodash.lowerFirst = lowerFirst;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.maxBy = maxBy;
    lodash.mean = mean;
    lodash.meanBy = meanBy;
    lodash.min = min;
    lodash.minBy = minBy;
    lodash.multiply = multiply;
    lodash.nth = nth;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padEnd = padEnd;
    lodash.padStart = padStart;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.replace = replace;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.sample = sample;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedIndexBy = sortedIndexBy;
    lodash.sortedIndexOf = sortedIndexOf;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.sortedLastIndexBy = sortedLastIndexBy;
    lodash.sortedLastIndexOf = sortedLastIndexOf;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.subtract = subtract;
    lodash.sum = sum;
    lodash.sumBy = sumBy;
    lodash.template = template;
    lodash.times = times;
    lodash.toFinite = toFinite;
    lodash.toInteger = toInteger;
    lodash.toLength = toLength;
    lodash.toLower = toLower;
    lodash.toNumber = toNumber;
    lodash.toSafeInteger = toSafeInteger;
    lodash.toString = toString;
    lodash.toUpper = toUpper;
    lodash.trim = trim;
    lodash.trimEnd = trimEnd;
    lodash.trimStart = trimStart;
    lodash.truncate = truncate;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.upperCase = upperCase;
    lodash.upperFirst = upperFirst;
    // Add aliases.
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.first = head;
    mixin(lodash, function () {
      var source = {};
      baseForOwn(lodash, function (func, methodName) {
        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
          source[methodName] = func;
        }
      });
      return source;
    }(), { 'chain': false });
    /*------------------------------------------------------------------------*/
    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */
    lodash.VERSION = VERSION;
    // Assign default placeholders.
    arrayEach([
      'bind',
      'bindKey',
      'curry',
      'curryRight',
      'partial',
      'partialRight'
    ], function (methodName) {
      lodash[methodName].placeholder = lodash;
    });
    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach([
      'drop',
      'take'
    ], function (methodName, index) {
      LazyWrapper.prototype[methodName] = function (n) {
        var filtered = this.__filtered__;
        if (filtered && !index) {
          return new LazyWrapper(this);
        }
        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
        var result = this.clone();
        if (filtered) {
          result.__takeCount__ = nativeMin(n, result.__takeCount__);
        } else {
          result.__views__.push({
            'size': nativeMin(n, MAX_ARRAY_LENGTH),
            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
          });
        }
        return result;
      };
      LazyWrapper.prototype[methodName + 'Right'] = function (n) {
        return this.reverse()[methodName](n).reverse();
      };
    });
    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach([
      'filter',
      'map',
      'takeWhile'
    ], function (methodName, index) {
      var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
      LazyWrapper.prototype[methodName] = function (iteratee) {
        var result = this.clone();
        result.__iteratees__.push({
          'iteratee': getIteratee(iteratee, 3),
          'type': type
        });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });
    // Add `LazyWrapper` methods for `_.head` and `_.last`.
    arrayEach([
      'head',
      'last'
    ], function (methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');
      LazyWrapper.prototype[methodName] = function () {
        return this[takeName](1).value()[0];
      };
    });
    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
    arrayEach([
      'initial',
      'tail'
    ], function (methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');
      LazyWrapper.prototype[methodName] = function () {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });
    LazyWrapper.prototype.compact = function () {
      return this.filter(identity);
    };
    LazyWrapper.prototype.find = function (predicate) {
      return this.filter(predicate).head();
    };
    LazyWrapper.prototype.findLast = function (predicate) {
      return this.reverse().find(predicate);
    };
    LazyWrapper.prototype.invokeMap = rest(function (path, args) {
      if (typeof path == 'function') {
        return new LazyWrapper(this);
      }
      return this.map(function (value) {
        return baseInvoke(value, path, args);
      });
    });
    LazyWrapper.prototype.reject = function (predicate) {
      predicate = getIteratee(predicate, 3);
      return this.filter(function (value) {
        return !predicate(value);
      });
    };
    LazyWrapper.prototype.slice = function (start, end) {
      start = toInteger(start);
      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = toInteger(end);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };
    LazyWrapper.prototype.takeRightWhile = function (predicate) {
      return this.reverse().takeWhile(predicate).reverse();
    };
    LazyWrapper.prototype.toArray = function () {
      return this.take(MAX_ARRAY_LENGTH);
    };
    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function (func, methodName) {
      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? 'take' + (methodName == 'last' ? 'Right' : '') : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function () {
        var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray(value);
        var interceptor = function (value) {
          var result = lodashFunc.apply(lodash, arrayPush([value], args));
          return isTaker && chainAll ? result[0] : result;
        };
        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push({
            'func': thru,
            'args': [interceptor],
            'thisArg': undefined
          });
          return new LodashWrapper(result, chainAll);
        }
        if (isUnwrapped && onlyLazy) {
          return func.apply(this, args);
        }
        result = this.thru(interceptor);
        return isUnwrapped ? isTaker ? result.value()[0] : result.value() : result;
      };
    });
    // Add `Array` methods to `lodash.prototype`.
    arrayEach([
      'pop',
      'push',
      'shift',
      'sort',
      'splice',
      'unshift'
    ], function (methodName) {
      var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru', retUnwrapped = /^(?:pop|shift)$/.test(methodName);
      lodash.prototype[methodName] = function () {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          var value = this.value();
          return func.apply(isArray(value) ? value : [], args);
        }
        return this[chainName](function (value) {
          return func.apply(isArray(value) ? value : [], args);
        });
      };
    });
    // Map minified method names to their real names.
    baseForOwn(LazyWrapper.prototype, function (func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name + '', names = realNames[key] || (realNames[key] = []);
        names.push({
          'name': methodName,
          'func': lodashFunc
        });
      }
    });
    realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{
        'name': 'wrapper',
        'func': undefined
      }];
    // Add methods to `LazyWrapper`.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;
    // Add chain sequence methods to the `lodash` wrapper.
    lodash.prototype.at = wrapperAt;
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.next = wrapperNext;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
    if (iteratorSymbol) {
      lodash.prototype[iteratorSymbol] = wrapperToIterator;
    }
    return lodash;
  }
  /*--------------------------------------------------------------------------*/
  // Export lodash.
  var _ = runInContext();
  // Expose Lodash on the free variable `window` or `self` when available so it's
  // globally accessible, even when bundled with Browserify, Webpack, etc. This
  // also prevents errors in cases where Lodash is loaded by a script tag in the
  // presence of an AMD loader. See http://requirejs.org/docs/errors.html#mismatch
  // for more details. Use `_.noConflict` to remove Lodash from the global object.
  (freeWindow || freeSelf || {})._ = _;
  // Some AMD build optimizers like r.js check for condition patterns like the following:
  if (true) {
    lodash = function () {
      return _;
    }();
  }  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
  else if (freeExports && freeModule) {
    // Export for Node.js.
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // Export for CommonJS support.
    freeExports._ = _;
  } else {
    // Export to the global object.
    root._ = _;
  }
}.call(this));
settings = function (_) {
  //////////////////////////////////////////////////////////////////////////
  /////////////////////     DEFAULT SETTINGS     ///////////////////////////
  //////////////////////////////////////////////////////////////////////////
  var defaults = {
    /**
     * Default settings for mode use Mode.shortId as a key
     * @private
     */
    modes: {
      /////////////////////    BALLS AND STICKS    ///////////////////////////
      BS: {
        /**
         * Atom radius multiplier.
         * @type {number}
         */
        atom: 0.23,
        /**
         * Bond cylinder radius.
         * @type {number}
         */
        bond: 0.15,
        /**
         * Fraction of the space around one cylinder. 0 means that cylinder fills all available space
         * @type {number}
         */
        space: 0.5,
        /**
         * Flag, that toggles rendering of multiple ordered bonds.
         * @type {boolean}
         */
        multibond: true,
        /**
         * Minor radius of a torus for aromatic loops
         * @type {number}
         */
        aromrad: 0.1,
        /**
         * Flag, that toggles rendering of aromatic loops.
         * @type {boolean}
         */
        showarom: true,
        /**
         * Poly complexity values for render modes.
         * @enum {number}
         */
        polyComplexity: {
          poor: 2,
          low: 4,
          medium: 6,
          high: 12,
          ultra: 32
        }
      },
      ////////////////////       VAN DER WAALS      //////////////////////////
      VW: {
        /**
         * Poly complexity values for render modes.
         * @enum {number}
         */
        polyComplexity: {
          poor: 4,
          low: 6,
          medium: 8,
          high: 16,
          ultra: 32
        }
      },
      ////////////////////           LINES          //////////////////////////
      LN: {
        /**
         * Flag, that toggles rendering of multiple ordered bonds.
         * @type {boolean}
         */
        multibond: true,
        /**
         * Flag, that toggles rendering of aromatic loops.
         * @type {boolean}
         */
        showarom: true,
        /**
         * Offset between bonds and aromatic cycle
         * @type {number}
         */
        offsarom: 0.2,
        /**
         * Number of pieces in a-loop arc, corresponding to atom.
         * @type {number}
         */
        chunkarom: 10,
        /**
         * Collision radius for atoms picking.
         * @type {number}
         */
        atom: 0.23
      },
      ////////////////////         LICORICE         //////////////////////////
      LC: {
        /**
         * Bond cylinder radius.
         * @type {number}
         */
        bond: 0.2,
        /**
         * Fraction of the space around one cylinder. 0 means that cylinder fills all available space
         * @type {number}
         */
        space: 0,
        /**
         * Flag, that toggles rendering of multiple ordered bonds.
         * @type {boolean}
         */
        multibond: true,
        /**
         * Minor radius of a torus for aromatic loops
         * @type {number}
         */
        aromrad: 0.1,
        /**
         * Flag, that toggles rendering of aromatic loops.
         * @type {boolean}
         */
        showarom: true,
        /**
         * Poly complexity values for render modes.
         * @enum {number}
         */
        polyComplexity: {
          poor: 3,
          low: 4,
          medium: 6,
          high: 12,
          ultra: 32
        }
      },
      ////////////////////          SURFACE         //////////////////////////
      SU: {
        /**
         * Poly complexity values for render modes.
         * @enum {number}
         */
        polyComplexity: {
          poor: 6,
          low: 8,
          medium: 16,
          high: 30,
          ultra: 60
        },
        /**
         * Flag, that toggles z-clipping.
         * @type {boolean}
         */
        zClip: false
      },
      ////////////////////          SURFACE   SAS   //////////////////////////
      SA: {
        /**
         * Poly complexity values for render modes.
         * @enum {number}
         */
        polyComplexity: {
          poor: 6,
          low: 8,
          medium: 16,
          high: 30,
          ultra: 60
        },
        /**
         * Flag, that toggles z-clipping.
         * @type {boolean}
         */
        zClip: false
      },
      ////////////////////          SURFACE   SES   //////////////////////////
      SE: {
        /**
         * Poly complexity values for render modes.
         * @enum {number}
         */
        polyComplexity: {
          poor: 6,
          low: 8,
          medium: 16,
          high: 30,
          ultra: 60
        },
        /**
         * Flag, that toggles z-clipping.
         * @type {boolean}
         */
        zClip: false
      },
      ////////////////////          SURFACE         //////////////////////////
      QS: {
        /**
         * Isovalue of the surface to extract.
         * @type {number}
         */
        isoValue: 0.5,
        /**
         * Gauss lim for coloring the bigger the value, the smoother our colors are.
         * @enum {number}
         */
        gaussLim: {
          poor: 1.5,
          low: 2,
          medium: 2.5,
          high: 3,
          ultra: 4
        },
        /**
         * Radius scale for the surface being built.
         * @type {number}
         */
        scale: 1,
        /**
         * Flag that specifies whether or not surface rendered in wireframe mode.
         * @type {boolean}
         */
        wireframe: false,
        /**
         * Poly complexity values for render modes. In this case the value corresponds to the grid density.
         * @enum {number}
         */
        gridSpacing: {
          poor: 2,
          low: 1.5,
          medium: 1,
          high: 0.5,
          ultra: 0.25
        },
        /**
         * Flag, that toggles z-clipping.
         * @type {boolean}
         */
        zClip: false
      },
      ////////////////////           TRACE          //////////////////////////
      TR: {
        /**
         * Cylinder radius.
         * @type {number}
         */
        radius: 0.3,
        /**
         * Poly complexity values for render modes.
         * @enum {number}
         */
        polyComplexity: {
          poor: 12,
          low: 16,
          medium: 32,
          high: 64,
          ultra: 64
        }
      },
      ////////////////////           TUBE           //////////////////////////
      TU: {
        /**
         * Tube radius for Tube mode.
         * @type {number}
         */
        radius: 0.3,
        /**
         * Poly complexity multiplier for height segments.
         * @type {number}
         */
        heightSegmentsRatio: 1.5,
        /**
         * Tension for interpolation.
         * @type {number}
         */
        tension: -0.7,
        /**
         * Poly complexity values for render modes.
         * @enum {number}
         */
        polyComplexity: {
          poor: 5,
          low: 6,
          medium: 10,
          high: 18,
          ultra: 34
        }
      },
      ////////////////////          CARTOON         //////////////////////////
      CA: {
        /**
         * Standard tube radius.
         * @type {number}
         */
        radius: 0.3,
        /**
         * Height of the secondary structure ribbon.
         * @type {number}
         */
        depth: 0.25,
        /**
         * Width of the secondary structure ribbon.
         * @type {number}
         */
        width: 1,
        /**
         * Secondary structure's arrow width.
         * @type {number}
         */
        arrow: 2,
        /**
         * Poly complexity multiplier for height segments.
         * @type {number}
         */
        heightSegmentsRatio: 1.5,
        /**
         * Tension for interpolation.
         * @type {number}
         */
        tension: -0.7,
        /**
         * Poly complexity values for render modes.
         * @enum {number}
         */
        polyComplexity: {
          poor: 5,
          low: 6,
          medium: 10,
          high: 18,
          ultra: 34
        }
      }
    },
    colorers: { UN: { color: 16711680 } },
    labels: 'no',
    // can be one of: no, obj, fg, bg.
    /**
     * Use antialiasing in WebGL.
     * @type {boolean}
     */
    antialias: true,
    /**
     * Camera field of view in degrees.
     * @type {number}
     */
    camFov: 45,
    /**
     * Camera near plane distance in angstroms.
     * @type {number}
     */
    camNear: 1.5,
    /**
     * Camera far plane distance in angstroms.
     * @type {number}
     */
    camFar: 1000,
    fogNearFactor: 0.5,
    fogFarFactor: 1,
    /**
     * Palette used for molecule coloring.
     * @type {string}
     */
    palette: 'JMOL_PALETTE',
    /**
     * Geometry resolution.
     * @type {string}
     */
    resolution: 'medium',
    autoResolution: false  /*true*/,
    autoPreset: true,
    preset: 'default',
    presets: {
      // Default
      default: [{
          mode: 'BALLS_AND_STICKS_MODE',
          colorer: 'ATOM_TYPE_COLORER',
          selector: 'all',
          material: 'MATERIAL_SOFT'
        }],
      // Wireframe
      wire: [{
          mode: 'LINES_MODE',
          colorer: 'ATOM_TYPE_COLORER',
          selector: 'all',
          material: 'MATERIAL_SOFT'
        }],
      // Small molecules
      small: [{
          mode: 'BALLS_AND_STICKS_MODE',
          colorer: 'ATOM_TYPE_COLORER',
          selector: 'all',
          material: 'MATERIAL_SOFT'
        }],
      // Proteins, nucleic acids etc.
      macro: [
        {
          mode: 'CARTOON_MODE',
          colorer: 'SECONDARY_STRUCTURE_COLORER',
          selector: 'not hetatm',
          material: 'MATERIAL_SOFT'
        },
        {
          mode: 'BALLS_AND_STICKS_MODE',
          colorer: 'ATOM_TYPE_COLORER',
          selector: 'hetatm and not water',
          material: 'MATERIAL_SOFT'
        }
      ]
    },
    /////////////////////////////////////////////////////////////////
    theme: 'dark',
    themes: {
      dark: 2105376,
      light: 13421772
    },
    axes: true,
    fog: true,
    fps: true,
    zSprites: true,
    isoSurfaceFakeOpacity: true,
    suspendRender: true,
    fxaa: true,
    inversePanning: false,
    // enable complex auto-rotation with constant speed
    autoRotation: 0,
    // true:  complex auto-rotation is about vertical axis
    // false: rotation axis is defined by last user rotation
    autoRotationAxisFixed: true,
    // enable zooming with mouse wheel or pinch gesture
    zooming: true,
    // enable camera panning with keyboard or pinch gesture
    panning: true,
    // enable picking atoms & residues with left mouse button or touch
    picking: true,
    // make "component" and "fragment" editing modes available
    editing: true,
    // load only one biological unit from all those described in PDB file
    singleUnit: true,
    debug: {
      example: 3.5,
      text: 'hello!',
      good: true
    }
  };
  //////////////////////////////////////////////////////////////////////////
  /////////////////////      SETTINGS CLASS      ///////////////////////////
  //////////////////////////////////////////////////////////////////////////
  /**
   * @exports Settings
   * @constructor
   */
  function Settings() {
    this.old = null;
    this.now = {};
    this._changed = {};
    this.reset();
  }
  Settings.prototype = {
    constructor: Settings,
    defaults: defaults,
    set: function (path, value) {
      _.set(this.now, path, value);
      this._changed[path] = true;
    },
    get: function (path, defaultValue) {
      return _.get(this.now, path, defaultValue);
    },
    reset: function () {
      this.now = _.cloneDeep(defaults);
      this.old = null;
      this._changed = {};
    },
    checkpoint: function () {
      this.old = _.cloneDeep(this.now);
      this._changed = {};
    },
    undo: function () {
      this.now = _.cloneDeep(this.old);
      this._changed = {};
    },
    changed: function () {
      if (!this.old) {
        return [];
      }
      var old = this.old;
      var now = this.now;
      var keys = _.filter(Object.keys(this._changed), function (key) {
        return _.get(old, key) !== _.get(now, key);
      });
      return keys;
    },
    override: function (other) {
      _.merge(this.now, other);
    }
  };
  return new Settings();
}(lodash);
options = function (settings, utils, _) {
  var repIndex = 0;
  function asBoolean(value) {
    return !(!value || value === '0' || value.toLowerCase() === 'false');
  }
  var adapters = {
    'string': String,
    'number': Number,
    'boolean': asBoolean
  };
  function ensureRepList(opts) {
    var reps = opts.reps;
    if (!reps) {
      var presets = settings.now.presets;
      var preset = opts.preset || settings.now.preset;
      reps = presets[preset];
      if (!reps) {
        console.warn('MIEW: Unknown preset "' + preset + '"');
        preset = Object.keys(presets)[0];
        reps = presets[preset];  // fall back to any preset
      }
      opts.preset = preset;
      opts.reps = utils.deriveDeep(reps);
    }
  }
  function ensureRepAssign(opts, prop, value) {
    ensureRepList(opts);
    var rep = opts.reps[repIndex];
    // prop specified twice therefore start new rep by cloning the current
    if (rep.hasOwnProperty(prop)) {
      if (++repIndex >= opts.reps.length) {
        opts.reps[repIndex] = utils.deriveDeep(rep);
      }
    }
    if (value !== undefined) {
      opts.reps[repIndex][prop] = value;
    }
  }
  function extractArgs(input, defaultsDict) {
    if (input) {
      var bang = input.indexOf('!');
      if (bang >= 0) {
        var args = input.substr(bang + 1).split(',');
        input = input.substr(0, bang);
        if (defaultsDict) {
          var defaults = defaultsDict[input];
          var opts = utils.deriveDeep(defaults);
          args.forEach(function (arg) {
            var pair = arg.split(':', 2);
            var key = pair[0], value = pair[1];
            var adapter = adapters[typeof _.get(defaults, key)];
            if (adapter) {
              _.set(opts, key, adapter(value));
            } else {
              console.warn('MIEW: Unknown argument "' + key + '" for option "' + input + '"');
            }
          });
          if (Object.keys(opts).length > 0) {
            input = [
              input,
              opts
            ];
          }
        }
      }
    }
    return input;
  }
  var actions = {
    //////////////////////////////////////////////////////////////////////////////
    // Options
    'l': 'load',
    'load': String,
    't': 'type',
    'type': String,
    'menu': asBoolean,
    //////////////////////////////////////////////////////////////////////////////
    // Commands
    'p': 'preset',
    'preset': function (value, opts) {
      opts.preset = value;
      opts.reps = null;
      ensureRepList(opts);
    },
    'r': 'rep',
    'rep': function (value, opts) {
      ensureRepList(opts);
      repIndex = Number(value);
      repIndex = repIndex < opts.reps.length ? repIndex < 0 ? 0 : repIndex : opts.reps.length - 1;  // clamp the index
    },
    's': 'select',
    'select': function (value, opts) {
      ensureRepAssign(opts, 'selector', value);
    },
    'm': 'mode',
    'mode': function (value, opts) {
      ensureRepAssign(opts, 'mode', extractArgs(value, settings.defaults.modes));
    },
    'c': 'color',
    'color': function (value, opts) {
      ensureRepAssign(opts, 'colorer', extractArgs(value, settings.defaults.colorers));
    },
    'mt': 'material',
    'material': function (value, opts) {
      ensureRepAssign(opts, 'material', extractArgs(value, settings.defaults.materials));
    },
    'dup': function (value, opts) {
      ensureRepList(opts);
      var reps = opts.reps;
      var rep = reps[repIndex];
      if (++repIndex >= reps.length) {
        reps[repIndex] = utils.deriveDeep(rep);
      }
    },
    //////////////////////////////////////////////////////////////////////////////
    // Settings shortcuts
    'ar': 'autoResolution',
    //////////////////////////////////////////////////////////////////////////////
    // Deprecated
    'background': 'theme'
  };
  var plus = /\+/g;
  function decode(s) {
    return decodeURIComponent(s.replace(plus, ' '));
  }
  function fromAttr(str) {
    if (!str) {
      return {};
    }
    var search = /([^&=]+)=?([^&]*)/g;
    var match;
    repIndex = 0;
    var opts = {};
    while ((match = search.exec(str)) !== null) {
      var key = decode(match[1]);
      var value = decode(match[2]);
      var action = actions[key];
      // shortcut
      if (action && typeof action === 'string') {
        key = action;
        action = actions[key];
      }
      // either set a property or use specialized parser
      if (!action) {
        var adapter = adapters[typeof _.get(settings.defaults, key)];
        if (adapter) {
          _.set(opts, 'settings.' + key, adapter(value));
        } else {
          console.warn('MIEW: Unknown option "' + key + '"');
        }
      } else if (action instanceof Function) {
        var result = action(value, opts);
        if (result !== undefined) {
          opts[key] = result;
        }
      }
    }
    return opts;
  }
  function fromURL(url) {
    url = url || window.location.search;
    return fromAttr(url.substr(url.indexOf('?') + 1));
  }
  return {
    fromURL: fromURL,
    fromAttr: fromAttr
  };
}(settings, utils, lodash);
utils_SelectionParser = function (require) {
  var o = function (k, v, o, l) {
      for (o = o || {}, l = k.length; l--; o[k[l]] = v);
      return o;
    }, $V0 = [
      1,
      4
    ], $V1 = [
      1,
      5
    ], $V2 = [
      1,
      6
    ], $V3 = [
      1,
      7
    ], $V4 = [
      1,
      8
    ], $V5 = [
      1,
      10
    ], $V6 = [
      1,
      11
    ], $V7 = [
      5,
      7,
      8,
      11
    ], $V8 = [
      1,
      16
    ], $V9 = [
      1,
      21
    ], $Va = [
      1,
      19
    ], $Vb = [
      1,
      20
    ], $Vc = [
      5,
      7,
      8,
      11,
      18
    ];
  var parser = {
    trace: function trace() {
    },
    yy: {},
    symbols_: {
      'error': 2,
      'Program': 3,
      'Expression': 4,
      'EOF': 5,
      'Selector': 6,
      'OR': 7,
      'AND': 8,
      'NOT': 9,
      '(': 10,
      ')': 11,
      'SELECTOR': 12,
      'SELECTOR_RANGED': 13,
      'RangeList': 14,
      'SELECTOR_NAMED': 15,
      'NameList': 16,
      'Range': 17,
      ',': 18,
      'NUMBER': 19,
      ':': 20,
      'Name': 21,
      'IDENTIFIER': 22,
      'STRING': 23,
      '$accept': 0,
      '$end': 1
    },
    terminals_: {
      2: 'error',
      5: 'EOF',
      7: 'OR',
      8: 'AND',
      9: 'NOT',
      10: '(',
      11: ')',
      12: 'SELECTOR',
      13: 'SELECTOR_RANGED',
      15: 'SELECTOR_NAMED',
      18: ',',
      19: 'NUMBER',
      20: ':',
      22: 'IDENTIFIER',
      23: 'STRING'
    },
    productions_: [
      0,
      [
        3,
        2
      ],
      [
        4,
        1
      ],
      [
        4,
        3
      ],
      [
        4,
        3
      ],
      [
        4,
        2
      ],
      [
        4,
        3
      ],
      [
        6,
        1
      ],
      [
        6,
        2
      ],
      [
        6,
        2
      ],
      [
        14,
        1
      ],
      [
        14,
        3
      ],
      [
        17,
        1
      ],
      [
        17,
        3
      ],
      [
        16,
        1
      ],
      [
        16,
        3
      ],
      [
        21,
        1
      ],
      [
        21,
        1
      ],
      [
        21,
        1
      ]
    ],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      /* this == yyval */
      var $0 = $$.length - 1;
      switch (yystate) {
      case 1:
        return $$[$0 - 1];
        break;
      case 3:
        this.$ = yy.keyword('or')($$[$0 - 2], $$[$0]);
        break;
      case 4:
        this.$ = yy.keyword('and')($$[$0 - 2], $$[$0]);
        break;
      case 5:
        this.$ = yy.keyword('not')($$[$0]);
        break;
      case 6:
        this.$ = $$[$0 - 1];
        break;
      case 7:
        this.$ = yy.keyword($$[$0])();
        break;
      case 8:
      case 9:
        this.$ = yy.keyword($$[$0 - 1])($$[$0]);
        break;
      case 10:
        this.$ = new yy.RangeList($$[$0]);
        break;
      case 11:
        this.$ = $$[$0 - 2].append($$[$0]);
        break;
      case 12:
        this.$ = new yy.Range(Number($$[$0]));
        break;
      case 13:
        this.$ = new yy.Range(Number($$[$0 - 2]), Number($$[$0]));
        break;
      case 14:
        this.$ = new yy.ValueList($$[$0].toUpperCase());
        break;
      case 15:
        this.$ = $$[$0 - 2].append($$[$0].toUpperCase());
        break;
      }
    },
    table: [
      {
        3: 1,
        4: 2,
        6: 3,
        9: $V0,
        10: $V1,
        12: $V2,
        13: $V3,
        15: $V4
      },
      { 1: [3] },
      {
        5: [
          1,
          9
        ],
        7: $V5,
        8: $V6
      },
      o($V7, [
        2,
        2
      ]),
      {
        4: 12,
        6: 3,
        9: $V0,
        10: $V1,
        12: $V2,
        13: $V3,
        15: $V4
      },
      {
        4: 13,
        6: 3,
        9: $V0,
        10: $V1,
        12: $V2,
        13: $V3,
        15: $V4
      },
      o($V7, [
        2,
        7
      ]),
      {
        14: 14,
        17: 15,
        19: $V8
      },
      {
        16: 17,
        19: $V9,
        21: 18,
        22: $Va,
        23: $Vb
      },
      {
        1: [
          2,
          1
        ]
      },
      {
        4: 22,
        6: 3,
        9: $V0,
        10: $V1,
        12: $V2,
        13: $V3,
        15: $V4
      },
      {
        4: 23,
        6: 3,
        9: $V0,
        10: $V1,
        12: $V2,
        13: $V3,
        15: $V4
      },
      o($V7, [
        2,
        5
      ]),
      {
        7: $V5,
        8: $V6,
        11: [
          1,
          24
        ]
      },
      o($V7, [
        2,
        8
      ], {
        18: [
          1,
          25
        ]
      }),
      o($Vc, [
        2,
        10
      ]),
      o($Vc, [
        2,
        12
      ], {
        20: [
          1,
          26
        ]
      }),
      o($V7, [
        2,
        9
      ], {
        18: [
          1,
          27
        ]
      }),
      o($Vc, [
        2,
        14
      ]),
      o($Vc, [
        2,
        16
      ]),
      o($Vc, [
        2,
        17
      ]),
      o($Vc, [
        2,
        18
      ]),
      o([
        5,
        7,
        11
      ], [
        2,
        3
      ], { 8: $V6 }),
      o($V7, [
        2,
        4
      ]),
      o($V7, [
        2,
        6
      ]),
      {
        17: 28,
        19: $V8
      },
      {
        19: [
          1,
          29
        ]
      },
      {
        19: $V9,
        21: 30,
        22: $Va,
        23: $Vb
      },
      o($Vc, [
        2,
        11
      ]),
      o($Vc, [
        2,
        13
      ]),
      o($Vc, [
        2,
        15
      ])
    ],
    defaultActions: {
      9: [
        2,
        1
      ]
    },
    parseError: function parseError(str, hash) {
      if (hash.recoverable) {
        this.trace(str);
      } else {
        function _parseError(msg, hash) {
          this.message = msg;
          this.hash = hash;
        }
        _parseError.prototype = Error;
        throw new _parseError(str, hash);
      }
    },
    parse: function parse(input) {
      var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
          sharedState.yy[k] = this.yy[k];
        }
      }
      lexer.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer;
      sharedState.yy.parser = this;
      if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
      }
      var yyloc = lexer.yylloc;
      lstack.push(yyloc);
      var ranges = lexer.options && lexer.options.ranges;
      if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
      }
      _token_stack:
        var lex = function () {
          var token;
          token = lexer.lex() || EOF;
          if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
          }
          return token;
        };
      var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol === null || typeof symbol == 'undefined') {
            symbol = lex();
          }
          action = table[state] && table[state][symbol];
        }
        if (typeof action === 'undefined' || !action.length || !action[0]) {
          var errStr = '';
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push('\'' + this.terminals_[p] + '\'');
            }
          }
          if (lexer.showPosition) {
            errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
          } else {
            errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
          }
          this.parseError(errStr, {
            text: lexer.match,
            token: this.terminals_[symbol] || symbol,
            line: lexer.yylineno,
            loc: yyloc,
            expected: expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
          stack.push(symbol);
          vstack.push(lexer.yytext);
          lstack.push(lexer.yylloc);
          stack.push(action[1]);
          symbol = null;
          if (!preErrorSymbol) {
            yyleng = lexer.yyleng;
            yytext = lexer.yytext;
            yylineno = lexer.yylineno;
            yyloc = lexer.yylloc;
            if (recovering > 0) {
              recovering--;
            }
          } else {
            symbol = preErrorSymbol;
            preErrorSymbol = null;
          }
          break;
        case 2:
          len = this.productions_[action[1]][1];
          yyval.$ = vstack[vstack.length - len];
          yyval._$ = {
            first_line: lstack[lstack.length - (len || 1)].first_line,
            last_line: lstack[lstack.length - 1].last_line,
            first_column: lstack[lstack.length - (len || 1)].first_column,
            last_column: lstack[lstack.length - 1].last_column
          };
          if (ranges) {
            yyval._$.range = [
              lstack[lstack.length - (len || 1)].range[0],
              lstack[lstack.length - 1].range[1]
            ];
          }
          r = this.performAction.apply(yyval, [
            yytext,
            yyleng,
            yylineno,
            sharedState.yy,
            action[1],
            vstack,
            lstack
          ].concat(args));
          if (typeof r !== 'undefined') {
            return r;
          }
          if (len) {
            stack = stack.slice(0, -1 * len * 2);
            vstack = vstack.slice(0, -1 * len);
            lstack = lstack.slice(0, -1 * len);
          }
          stack.push(this.productions_[action[1]][0]);
          vstack.push(yyval.$);
          lstack.push(yyval._$);
          newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
          stack.push(newState);
          break;
        case 3:
          return true;
        }
      }
      return true;
    }
  };
  /* generated by jison-lex 0.3.4 */
  var lexer = function () {
    var lexer = {
      EOF: 1,
      parseError: function parseError(str, hash) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash);
        } else {
          throw new Error(str);
        }
      },
      // resets the lexer, sets new input
      setInput: function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [
            0,
            0
          ];
        }
        this.offset = 0;
        return this;
      },
      // consumes and returns one char from the input
      input: function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      // unshifts one char (or a string) into the input
      unput: function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [
            r[0],
            r[0] + this.yyleng - len
          ];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      // When called from action, caches matched text and appends it on next action
      more: function () {
        this._more = true;
        return this;
      },
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: function () {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
            text: '',
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      // retain first n characters of the match
      less: function (n) {
        this.unput(this.match.slice(n));
      },
      // displays already matched input, i.e. for error messages
      pastInput: function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, '');
      },
      // displays upcoming input, i.e. for error messages
      upcomingInput: function () {
        var next = this.match;
        if (next.length < 20) {
          next += this._input.substr(0, 20 - next.length);
        }
        return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, '');
      },
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join('-');
        return pre + this.upcomingInput() + '\n' + c + '^';
      },
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: function (match, indexed_rule) {
        var token, lines, backup;
        if (this.options.backtrack_lexer) {
          // save context
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [
            this.offset,
            this.offset += this.yyleng
          ];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token) {
          return token;
        } else if (this._backtrack) {
          // recover context
          for (var k in backup) {
            this[k] = backup[k];
          }
          return false;  // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
      },
      // return next match in input
      next: function () {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token, match, tempMatch, index;
        if (!this._more) {
          this.yytext = '';
          this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index = i;
            if (this.options.backtrack_lexer) {
              token = this.test_match(tempMatch, rules[i]);
              if (token !== false) {
                return token;
              } else if (this._backtrack) {
                match = false;
                continue;  // rule action called reject() implying a rule MISmatch.
              } else {
                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token = this.test_match(match, rules[index]);
          if (token !== false) {
            return token;
          }
          // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
          return false;
        }
        if (this._input === '') {
          return this.EOF;
        } else {
          return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
            text: '',
            token: null,
            line: this.yylineno
          });
        }
      },
      // return next match that has a token
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      // pop the previously active lexer condition state off the condition stack
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions['INITIAL'].rules;
        }
      },
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return 'INITIAL';
        }
      },
      // alias for begin(condition)
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      // return the number of states currently on the stack
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: { 'case-insensitive': true },
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        var YYSTATE = YY_START;
        switch ($avoiding_name_collisions) {
        case 0:
          /* skip whitespace */
          break;
        case 1:
          return 19;
          break;
        case 2:
          return 7;
          break;
        case 3:
          return 8;
          break;
        case 4:
          return 9;
          break;
        case 5:
          return 12;
          break;
        case 6:
          return 12;
          break;
        case 7:
          return 12;
          break;
        case 8:
          return 12;
          break;
        case 9:
          return 13;
          break;
        case 10:
          return 15;
          break;
        case 11:
          return 15;
          break;
        case 12:
          return 15;
          break;
        case 13:
          return 13;
          break;
        case 14:
          return 15;
          break;
        case 15:
          return 10;
          break;
        case 16:
          return 11;
          break;
        case 17:
          return 18;
          break;
        case 18:
          return 20;
          break;
        case 19:
          return '<=';
          break;
        case 20:
          return '>=';
          break;
        case 21:
          return '<';
          break;
        case 22:
          return '>';
          break;
        case 23:
          yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2);
          return 23;
          break;
        case 24:
          return 22;
          break;
        case 25:
          return 5;
          break;
        case 26:
          return 'INVALID';
          break;
        }
      },
      rules: [
        /^(?:\s+)/i,
        /^(?:(-?(?:[1-9][0-9]+|[0-9]))\b)/i,
        /^(?:OR\b)/i,
        /^(?:AND\b)/i,
        /^(?:NOT\b)/i,
        /^(?:ALL\b)/i,
        /^(?:NONE\b)/i,
        /^(?:WATER\b)/i,
        /^(?:HETATM\b)/i,
        /^(?:SERIAL\b)/i,
        /^(?:NAME\b)/i,
        /^(?:TYPE\b)/i,
        /^(?:RESIDUE\b)/i,
        /^(?:SEQUENCE\b)/i,
        /^(?:CHAIN\b)/i,
        /^(?:\()/i,
        /^(?:\))/i,
        /^(?:,)/i,
        /^(?::)/i,
        /^(?:<=)/i,
        /^(?:>=)/i,
        /^(?:<)/i,
        /^(?:>)/i,
        /^(?:((?:"([^"]*)"|'([^']*)')))/i,
        /^(?:([_A-Z0-9]+))/i,
        /^(?:$)/i,
        /^(?:.)/i
      ],
      conditions: {
        'INITIAL': {
          'rules': [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26
          ],
          'inclusive': true
        }
      }
    };
    return lexer;
  }();
  parser.lexer = lexer;
  return parser;
}({});
chem_selectors = function (parser) {
  var keywords = {};
  //////////////////////////////////////////////////////////////////////////////
  function Range(min, max) {
    this.min = min;
    this.max = typeof max === 'undefined' ? min : max;
  }
  Range.prototype.includes = function (value) {
    return this.min <= value && value <= this.max;
  };
  Range.prototype.toString = function () {
    var min = this.min, max = this.max;
    return min === max ? String(min) : [
      min,
      max
    ].join(':');
  };
  //////////////////////////////////////////////////////////////////////////////
  function List(arg) {
    if (arg instanceof this.constructor) {
      return arg;
    } else if (arg instanceof Array) {
      this._values = arg.slice(0);
    } else if (arg) {
      this._values = [arg];
    } else {
      this._values = [];
    }
  }
  List.prototype.append = function (value) {
    var values = this._values;
    values[values.length] = value;
    return this;
  };
  List.prototype.remove = function (value) {
    var values = this._values;
    var index = values.indexOf(value);
    if (index >= 0) {
      values.splice(index, 1);
    }
    return this;
  };
  List.prototype.toString = function () {
    return this._values.join(', ');
  };
  //////////////////////////////////////////////////////////////////////////////
  function RangeList(arg) {
    return List.call(this, arg);
  }
  RangeList.prototype = Object.create(List.prototype);
  RangeList.prototype.constructor = RangeList;
  RangeList.prototype.includes = function (value) {
    var list = this._values;
    for (var i = 0, n = list.length; i < n; ++i) {
      if (list[i].includes(value)) {
        return true;
      }
    }
    return false;
  };
  //////////////////////////////////////////////////////////////////////////////
  function ValueList(arg) {
    return List.call(this, arg);
  }
  ValueList.prototype = Object.create(List.prototype);
  ValueList.prototype.constructor = ValueList;
  ValueList.prototype.includes = function (value) {
    return this._values.indexOf(value) !== -1;
  };
  ValueList.prototype.toString = function () {
    var re = /^[a-zA-Z0-9_]*$/;
    var ar = [];
    var quoted = [
      '"',
      '',
      '"'
    ];
    // Quote values that are not correct identifiers
    return function () {
      var values = this._values;
      ar.length = 0;
      for (var i = 0, n = values.length; i < n; ++i) {
        var value = String(values[i]);
        if (re.test(value)) {
          ar[i] = value;
        } else {
          quoted[1] = value;
          ar[i] = quoted.join('');
        }
      }
      return ar.join(', ');
    };
  }();
  //////////////////////////////////////////////////////////////////////////////
  // Serial
  function Serial(arg) {
    this.list = new RangeList(arg);
  }
  Serial.prototype.includesAtom = function (atom) {
    return this.list.includes(atom._serial);
  };
  Serial.prototype.toString = function () {
    return 'serial ' + String(this.list);
  };
  keywords.serial = function (arg) {
    return new Serial(arg);
  };
  //////////////////////////////////////////////////////////////////////////////
  // Name
  function Name(arg) {
    this.list = new ValueList(arg);
  }
  Name.prototype.includesAtom = function (atom) {
    return this.list.includes(atom._name.getString().trim());  // FIXME: trim() is slow
  };
  Name.prototype.toString = function () {
    return 'name ' + String(this.list);
  };
  keywords.name = function (arg) {
    return new Name(arg);
  };
  //////////////////////////////////////////////////////////////////////////////
  // Type
  function Type(arg) {
    this.list = new ValueList(arg);
  }
  Type.prototype.includesAtom = function (atom) {
    return this.list.includes(atom._type.name);
  };
  Type.prototype.toString = function () {
    return 'type ' + String(this.list);
  };
  keywords.type = function (arg) {
    return new Type(arg);
  };
  //////////////////////////////////////////////////////////////////////////////
  // Residue
  function Residue(arg) {
    this.list = new ValueList(arg);
  }
  Residue.prototype.includesAtom = function (atom) {
    return this.list.includes(atom._residue._type._name);
  };
  Residue.prototype.toString = function () {
    return 'residue ' + String(this.list);
  };
  keywords.residue = function (arg) {
    return new Residue(arg);
  };
  //////////////////////////////////////////////////////////////////////////////
  // Sequence
  function Sequence(arg) {
    this.list = new RangeList(arg);
  }
  Sequence.prototype.includesAtom = function (atom) {
    return this.list.includes(atom._residue._sequence);
  };
  Sequence.prototype.toString = function () {
    return 'sequence ' + String(this.list);
  };
  keywords.sequence = function (arg) {
    return new Sequence(arg);
  };
  //////////////////////////////////////////////////////////////////////////////
  // Chain
  function Chain(arg) {
    this.list = new ValueList(arg);
  }
  Chain.prototype.includesAtom = function (atom) {
    return this.list.includes(atom._residue._chain._name);
  };
  Chain.prototype.toString = function () {
    return 'chain ' + String(this.list);
  };
  keywords.chain = function (arg) {
    return new Chain(arg);
  };
  //////////////////////////////////////////////////////////////////////////////
  // Hetatm
  function Hetatm() {
  }
  Hetatm.prototype.includesAtom = function (atom) {
    return atom._het;
  };
  Hetatm.prototype.toString = function () {
    return 'hetatm';
  };
  keywords.hetatm = function () {
    var obj = new Hetatm();
    return function () {
      return obj;
    };
  }();
  //////////////////////////////////////////////////////////////////////////////
  // Water
  function Water() {
  }
  Water.prototype.includesAtom = function () {
    var list = new ValueList(['HOH']);
    return function (atom) {
      return list.includes(atom._residue._type._name);
    };
  }();
  Water.prototype.toString = function () {
    return 'water';
  };
  keywords.water = function () {
    var obj = new Water();
    return function () {
      return obj;
    };
  }();
  //////////////////////////////////////////////////////////////////////////////
  // All
  function All() {
  }
  All.prototype.includesAtom = function (_atom) {
    return true;
  };
  All.prototype.toString = function () {
    return 'all';
  };
  keywords.all = function () {
    var obj = new All();
    return function () {
      return obj;
    };
  }();
  //////////////////////////////////////////////////////////////////////////////
  // None
  function None() {
  }
  None.prototype.includesAtom = function (_atom) {
    return false;
  };
  None.prototype.toString = function () {
    return 'none';
  };
  keywords.none = function () {
    var obj = new None();
    return function () {
      return obj;
    };
  }();
  var NULL_SELECTOR = keywords.none();
  //////////////////////////////////////////////////////////////////////////////
  // Not
  function Not(op) {
    this.op = op || NULL_SELECTOR;
  }
  Not.prototype.includesAtom = function (atom) {
    return !this.op.includesAtom(atom);
  };
  Not.prototype.toString = function () {
    var op = String(this.op);
    var opCons = this.op.constructor;
    if (opCons === And || opCons === Or) {
      return [
        'not (',
        op,
        ')'
      ].join('');
    } else {
      return 'not ' + op;
    }
  };
  keywords.not = function (arg) {
    return new Not(arg);
  };
  //////////////////////////////////////////////////////////////////////////////
  // And
  function And(a, b) {
    this.a = a || NULL_SELECTOR;
    this.b = b || NULL_SELECTOR;
  }
  And.prototype.includesAtom = function (atom) {
    return this.a.includesAtom(atom) && this.b.includesAtom(atom);
  };
  And.prototype.toString = function () {
    var aCons = this.a.constructor;
    var a = aCons === Or ? [
      '(',
      this.a,
      ')'
    ].join('') : this.a;
    var bCons = this.b.constructor;
    var b = bCons === Or ? [
      '(',
      this.b,
      ')'
    ].join('') : this.b;
    return [
      a,
      ' and ',
      b
    ].join('');
  };
  keywords.and = function (a, b) {
    return new And(a, b);
  };
  //////////////////////////////////////////////////////////////////////////////
  // Or
  function Or(a, b) {
    this.a = a || NULL_SELECTOR;
    this.b = b || NULL_SELECTOR;
  }
  Or.prototype.includesAtom = function (atom) {
    return this.a.includesAtom(atom) || this.b.includesAtom(atom);
  };
  Or.prototype.toString = function () {
    return [
      this.a,
      ' or ',
      this.b
    ].join('');
  };
  keywords.or = function (a, b) {
    return new Or(a, b);
  };
  //////////////////////////////////////////////////////////////////////////////
  var selectors = Object.create(keywords);
  selectors.Range = Range;
  selectors.RangeList = RangeList;
  selectors.ValueList = ValueList;
  selectors.keyword = function (key) {
    return keywords[key.toLowerCase()] || NULL_SELECTOR;
  };
  selectors.parse = function (str) {
    var res = {};
    try {
      res.selector = parser.parse(str);
    } catch (e) {
      res.selector = NULL_SELECTOR;
      res.error = e.message;
    }
    return res;
  };
  parser.yy = selectors;
  parser.yy.parseError = parser.parseError;
  // FIXME: workaround for incorrect JISON parser generator for AMD module
  return selectors;
}(utils_SelectionParser);
chem_AtomName = function () {
  /**
   * Atom name: simple and cooked.
   *
   * @param {string} name    - Simple atom name as a sting
   * @param {object} node    - Cooked name for pretty printing
   *
   * @exports Atom
   * @constructor
   */
  function AtomName(name, node) {
    this._node = node || null;
    this._name = name || null;
    if (this._node === null && this._name === null) {
      this._name = 'Unknown';
    }
  }
  /**
   * Get atom full name.
   * @returns {string} Atom simple name.
   */
  AtomName.prototype.getString = function () {
    return this._name || 'unknown';
  };
  /**
   * Get atom full pretty name.
   * @returns {object} Atom simple name.
   */
  AtomName.prototype.getNode = function () {
    return this._node || null;
  };
  return AtomName;
}();
chem_AtomType = function () {
  // TODO: See ResidueType and make this AtomType in similar way
  function AtomType(number, name, fullName, weight, radius, radiusBonding, hValency) {
    this.number = number;
    this.name = name;
    this.fullName = fullName;
    this.weight = weight;
    this.radius = radius;
    this.radiusBonding = radiusBonding;
    this.hydrogenValency = hValency;
  }
  AtomType.Constants = {
    /* eslint-disable no-magic-numbers */
    U1: 1,
    Lead: 2,
    U2: 3,
    Wing: 4,
    U18: 18  /* eslint-enable no-magic-numbers */
  };
  AtomType.Role = {
    /* eslint-disable no-magic-numbers */
    N: AtomType.Constants.U1,
    CA: AtomType.Constants.Lead,
    C: AtomType.Constants.U2,
    O: AtomType.Constants.Wing,
    SG: AtomType.Constants.U18
  };
  // DO NOT EDIT MANUALLY! Autogenerated from atom_types.csv by atom_types.py.
  AtomType.PeriodicTable = {
    /* eslint-disable no-magic-numbers */
    H: new AtomType(1, 'H', 'Hydrogen', 1.008, 1.2, 0.23, [1]),
    HE: new AtomType(2, 'HE', 'Helium', 4.003, 1.4, 0.93, [0]),
    LI: new AtomType(3, 'LI', 'Lithium', 6.941, 1.82, 0.68, [1]),
    BE: new AtomType(4, 'BE', 'Beryllium', 9.012, 1.7, 0.35, [2]),
    B: new AtomType(5, 'B', 'Boron', 10.81, 2.08, 0.83, [3]),
    C: new AtomType(6, 'C', 'Carbon', 12.011, 1.95, 0.68, [4]),
    N: new AtomType(7, 'N', 'Nitrogen', 14.007, 1.85, 0.68, [
      3,
      5
    ]),
    O: new AtomType(8, 'O', 'Oxygen', 15.999, 1.7, 0.68, [
      2,
      4
    ]),
    F: new AtomType(9, 'F', 'Fluorine', 18.998, 1.73, 0.64, [1]),
    NE: new AtomType(10, 'NE', 'Neon', 20.18, 1.54, 1.12, [0]),
    NA: new AtomType(11, 'NA', 'Sodium', 22.99, 2.27, 0.97, [1]),
    MG: new AtomType(12, 'MG', 'Magnesium', 24.305, 1.73, 1.1, [2]),
    AL: new AtomType(13, 'AL', 'Aluminum', 26.981, 2.05, 1.35, [3]),
    SI: new AtomType(14, 'SI', 'Silicon', 28.086, 2.1, 1.2, [4]),
    P: new AtomType(15, 'P', 'Phosphorus', 30.974, 2.08, 0.75, [
      3,
      5
    ]),
    S: new AtomType(16, 'S', 'Sulfur', 32.07, 2, 1.02, [
      2,
      4,
      6
    ]),
    CL: new AtomType(17, 'CL', 'Chlorine', 35.453, 1.97, 0.99, [
      1,
      3,
      5,
      7
    ]),
    AR: new AtomType(18, 'AR', 'Argon', 39.948, 1.88, 1.57, [0]),
    K: new AtomType(19, 'K', 'Potassium', 39.1, 2.75, 1.33, [1]),
    CA: new AtomType(20, 'CA', 'Calcium', 40.08, 1.973, 0.99, [2]),
    SC: new AtomType(21, 'SC', 'Scandium', 44.956, 1.7, 1.44, [0]),
    TI: new AtomType(22, 'TI', 'Titanium', 47.88, 1.7, 1.47, [0]),
    V: new AtomType(23, 'V', 'Vanadium', 50.941, 1.7, 1.33, [0]),
    CR: new AtomType(24, 'CR', 'Chromium', 52, 1.7, 1.35, [0]),
    MN: new AtomType(25, 'MN', 'Manganese', 54.938, 1.7, 1.35, [0]),
    FE: new AtomType(26, 'FE', 'Iron', 55.847, 1.7, 1.34, [0]),
    CO: new AtomType(27, 'CO', 'Cobalt', 58.93, 1.7, 1.33, [0]),
    NI: new AtomType(28, 'NI', 'Nickel', 58.69, 1.63, 1.5, [0]),
    CU: new AtomType(29, 'CU', 'Copper', 63.55, 1.4, 1.52, [0]),
    ZN: new AtomType(30, 'ZN', 'Zinc', 65.39, 1.39, 1.45, [0]),
    GA: new AtomType(31, 'GA', 'Gallium', 69.72, 1.87, 1.22, [3]),
    GE: new AtomType(32, 'GE', 'Germanium', 72.61, 1.7, 1.17, [4]),
    AS: new AtomType(33, 'AS', 'Arsenic', 74.92, 1.85, 1.21, [
      3,
      5
    ]),
    SE: new AtomType(34, 'SE', 'Selenium', 78.96, 1.9, 1.22, [
      2,
      4,
      6
    ]),
    BR: new AtomType(35, 'BR', 'Bromine', 79.9, 2.1, 1.21, [
      1,
      3,
      5,
      7
    ]),
    KR: new AtomType(36, 'KR', 'Krypton', 83.8, 2.02, 1.91, [0]),
    RB: new AtomType(37, 'RB', 'Rubidium', 85.47, 1.7, 1.47, [1]),
    SR: new AtomType(38, 'SR', 'Strontium', 87.62, 1.7, 1.12, [2]),
    Y: new AtomType(39, 'Y', 'Yttrium', 88.91, 1.7, 1.78, [0]),
    ZR: new AtomType(40, 'ZR', 'Zirconium', 91.22, 1.7, 1.56, [0]),
    NB: new AtomType(41, 'NB', 'Niobium', 92.91, 1.7, 1.48, [0]),
    MO: new AtomType(42, 'MO', 'Molybdenum', 95.94, 1.7, 1.47, [0]),
    TC: new AtomType(43, 'TC', 'Technetium', 98.91, 1.7, 1.35, [0]),
    RU: new AtomType(44, 'RU', 'Ruthenium', 101.07, 1.7, 1.4, [0]),
    RH: new AtomType(45, 'RH', 'Rhodium', 102.91, 1.7, 1.45, [0]),
    PD: new AtomType(46, 'PD', 'Palladium', 106.42, 1.63, 1.5, [0]),
    AG: new AtomType(47, 'AG', 'Silver', 107.87, 1.72, 1.59, [0]),
    CD: new AtomType(48, 'CD', 'Cadmium', 112.41, 1.58, 1.69, [0]),
    IN: new AtomType(49, 'IN', 'Indium', 114.82, 1.93, 1.63, [3]),
    SN: new AtomType(50, 'SN', 'Tin', 118.71, 2.17, 1.46, [
      2,
      4
    ]),
    SB: new AtomType(51, 'SB', 'Antimony', 121.75, 2.2, 1.46, [
      3,
      5
    ]),
    TE: new AtomType(52, 'TE', 'Tellurium', 127.6, 2.06, 1.47, [
      2,
      4,
      6
    ]),
    I: new AtomType(53, 'I', 'Iodine', 126.91, 2.15, 1.4, [
      1,
      3,
      5,
      7
    ]),
    XE: new AtomType(54, 'XE', 'Xenon', 131.29, 2.16, 1.98, [0]),
    CS: new AtomType(55, 'CS', 'Cesium', 132.91, 1.7, 1.67, [1]),
    BA: new AtomType(56, 'BA', 'Barium', 137.33, 1.7, 1.34, [2]),
    LA: new AtomType(57, 'LA', 'Lanthanum', 138.91, 1.7, 1.87, [0]),
    CE: new AtomType(58, 'CE', 'Cerium', 140.12, 1.7, 1.83, [0]),
    PR: new AtomType(59, 'PR', 'Praseodymium', 140.91, 1.7, 1.82, [0]),
    ND: new AtomType(60, 'ND', 'Neodymium', 144.24, 1.7, 1.81, [0]),
    PM: new AtomType(61, 'PM', 'Promethium', 144.9, 1.7, 1.8, [0]),
    SM: new AtomType(62, 'SM', 'Samarium', 150.36, 1.7, 1.8, [0]),
    EU: new AtomType(63, 'EU', 'Europium', 151.96, 1.7, 1.99, [0]),
    GD: new AtomType(64, 'GD', 'Gadolinium', 157.25, 1.7, 1.79, [0]),
    TB: new AtomType(65, 'TB', 'Terbium', 158.93, 1.7, 1.76, [0]),
    DY: new AtomType(66, 'DY', 'Dysprosium', 162.5, 1.7, 1.75, [0]),
    HO: new AtomType(67, 'HO', 'Holmium', 164.93, 1.7, 1.74, [0]),
    ER: new AtomType(68, 'ER', 'Erbium', 167.26, 1.7, 1.73, [0]),
    TM: new AtomType(69, 'TM', 'Thulium', 168.93, 1.7, 1.72, [0]),
    YB: new AtomType(70, 'YB', 'Ytterbium', 173.04, 1.7, 1.94, [0]),
    LU: new AtomType(71, 'LU', 'Lutetium', 174.97, 1.7, 1.72, [0]),
    HF: new AtomType(72, 'HF', 'Hafnium', 178.49, 1.7, 1.57, [0]),
    TA: new AtomType(73, 'TA', 'Tantalum', 180.95, 1.7, 1.43, [0]),
    W: new AtomType(74, 'W', 'Tungsten', 183.85, 1.7, 1.37, [0]),
    RE: new AtomType(75, 'RE', 'Rhenium', 186.21, 1.7, 1.35, [0]),
    OS: new AtomType(76, 'OS', 'Osmium', 190.2, 1.7, 1.37, [0]),
    IR: new AtomType(77, 'IR', 'Iridium', 192.22, 1.7, 1.32, [0]),
    PT: new AtomType(78, 'PT', 'Platinum', 195.08, 1.72, 1.5, [0]),
    AU: new AtomType(79, 'AU', 'Gold', 196.97, 1.66, 1.5, [0]),
    HG: new AtomType(80, 'HG', 'Mercury', 200.59, 1.55, 1.7, [0]),
    TL: new AtomType(81, 'TL', 'Thallium', 204.38, 1.96, 1.55, [
      1,
      3
    ]),
    PB: new AtomType(82, 'PB', 'Lead', 207.2, 2.02, 1.54, [
      2,
      4
    ]),
    BI: new AtomType(83, 'BI', 'Bismuth', 208.98, 1.7, 1.54, [
      3,
      5
    ]),
    PO: new AtomType(84, 'PO', 'Polonium', 210, 1.7, 1.68, [
      2,
      4,
      6
    ]),
    AT: new AtomType(85, 'AT', 'Astatine', 210, 1.7, 1.7, [
      1,
      3,
      5,
      7
    ]),
    RN: new AtomType(86, 'RN', 'Radon', 222, 1.7, 2.4, [0]),
    FR: new AtomType(87, 'FR', 'Francium', 223, 1.7, 2, [1]),
    RA: new AtomType(88, 'RA', 'Radium', 226.03, 1.7, 1.9, [2]),
    AC: new AtomType(89, 'AC', 'Actinium', 227.03, 1.7, 1.88, [0]),
    TH: new AtomType(90, 'TH', 'Thorium', 232.04, 1.7, 1.79, [0]),
    PA: new AtomType(91, 'PA', 'Protactinium', 231.04, 1.7, 1.61, [0]),
    U: new AtomType(92, 'U', 'Uranium', 238.03, 1.86, 1.58, [0]),
    NP: new AtomType(93, 'NP', 'Neptunium', 237.05, 1.7, 1.55, [0]),
    PU: new AtomType(94, 'PU', 'Plutonium', 239.1, 1.7, 1.53, [0]),
    AM: new AtomType(95, 'AM', 'Americium', 243.1, 1.7, 1.51, [0]),
    CM: new AtomType(96, 'CM', 'Curium', 247.1, 1.7, 1.5, [0]),
    BK: new AtomType(97, 'BK', 'Berkelium', 247.1, 1.7, 1.5, [0]),
    CF: new AtomType(98, 'CF', 'Californium', 252.1, 1.7, 1.5, [0]),
    ES: new AtomType(99, 'ES', 'Einsteinium', 252.1, 1.7, 1.5, [0]),
    FM: new AtomType(100, 'FM', 'Fermium', 257.1, 1.7, 1.5, [0]),
    MD: new AtomType(101, 'MD', 'Mendelevium', 256.1, 1.7, 1.5, [0]),
    NO: new AtomType(102, 'NO', 'Nobelium', 259.1, 1.7, 1.5, [0]),
    LR: new AtomType(103, 'LR', 'Lawrencium', 260.1, 1.7, 1.5, [0]),
    RF: new AtomType(104, 'RF', 'Rutherfordium', 261, 1.7, 1.6, [0]),
    DB: new AtomType(105, 'DB', 'Dubnium', 262, 1.7, 1.6, [0]),
    SG: new AtomType(106, 'SG', 'Seaborgium', 263, 1.7, 1.6, [0]),
    BH: new AtomType(107, 'BH', 'Bohrium', 262, 1.7, 1.6, [0]),
    HS: new AtomType(108, 'HS', 'Hassium', 265, 1.7, 1.6, [0]),
    MT: new AtomType(109, 'MT', 'Meitnerium', 268, 1.7, 1.6, [0])  /* eslint-enable no-magic-numbers */
  };
  return AtomType;
}();
chem_Atom = function (AtomName, AtomType) {
  //////////////////////////////////////////////////////////////////////////////
  /**
   * Atom measurements.
   *
   * @param {Residue} residue    - Residue containing the atom
   * @param {AtomName} name        - Name, unique in the residue
   * @param {AtomType} type      - Chemical element reference
   * @param {THREE.Vector3} position - Registered coordinates
   *
   * @param {number} role        - Role of atom inside monomer: Lead and wing are particularity interesting
   * @param {boolean} het        - Non-standard residue indicator
   *
   * @param {number} serial      - Serial number, unique in the model
   * @param {string} location    - Alternative location indicator (usually space or A-Z)
   * @param {number} occupancy   - Occupancy percentage, from 0 to 1
   * @param {number} temperature - Temperature
   * @param {number} charge      - Charge
   *
   * @exports Atom
   * @constructor
   */
  function Atom(residue, name, type, position, role, het, serial, location, occupancy, temperature, charge) {
    this._index = -1;
    this._residue = residue;
    if (name instanceof AtomName) {
      this._name = name;
    } else {
      this._name = new AtomName(name);
    }
    this._type = type;
    this._position = position;
    this._role = role;
    this._mask = 1 | 0;
    this._index = -1;
    this._het = het;
    this._serial = serial;
    this._location = (location || ' ').charCodeAt(0);
    this._occupancy = occupancy || 1;
    this._temperature = temperature;
    this._charge = charge;
    this._hydrogenCount = -1;
    //explicitly invalid
    this._radicalCount = 0;
    this._valence = -1;
    //explicitly invalid
    this._bonds = [];
  }
  /**
   * Get atom full name.
   * @returns {AtomName} Atom full name.
   */
  Atom.prototype.getName = function () {
    return this._name;
  };
  Atom.prototype.getPosition = function () {
    return this._position;
  };
  Atom.prototype.getResidue = function () {
    return this._residue;
  };
  Atom.prototype.getType = function () {
    return this._type;
  };
  Atom.prototype.getSerial = function () {
    return this._serial;
  };
  Atom.prototype.getBonds = function () {
    return this._bonds;
  };
  Atom.prototype.isHet = function () {
    return this._het;
  };
  Atom.prototype.isHydrogen = function () {
    return this._type.number === 1;
  };
  Atom.prototype.getValence = function () {
    return this._valence === -1 ? 0 : this._valence;
  };
  Atom.prototype.getVisualName = function () {
    var name = this.getName();
    if (name.getString().length > 0) {
      return name.getString().trim();
    } else {
      return this.getType().name.trim();
    }
  };
  Atom.prototype.forEachBond = function (process) {
    var bonds = this._bonds;
    for (var i = 0, n = bonds.length; i < n; ++i) {
      process(bonds[i]);
    }
  };
  Atom.prototype.isLabelVisible = function () {
    var n = null;
    if (this.getName().getNode() !== null) {
      return true;
    }
    if (this.getType() === null) {
      return false;
    }
    if (this.getType().number === AtomType.PeriodicTable.C.number) {
      n = this.getVisualName();
      if (n === null) {
        return false;
      }
      if (n.length === 1 && n.charCodeAt(0) === 67 && this.getBonds().length !== 0) {
        return false;
      }
    }
    return true;
  };
  Atom.prototype.getHydrogenCountBoron = function () {
    //examples
    //BH3*BH4(1-)*BH2(1+)*BH3(2-)*BH(2+)
    var valence = 3;
    //hardcoded as 3
    var hc = valence - this.getCharge() - this.getAtomBondsCount() - this._radicalCount;
    return Math.max(0, hc);
  };
  Atom.prototype.getHydrogenCountTin = function () {
    var valence = this._valence;
    if (valence === -1) {
      valence = this.getAtomBondsCount() - Math.abs(this.getCharge()) + this._radicalCount;
    }
    var defVal = this.findSuitableValence(valence);
    if (this.getCharge() !== 0) {
      defVal = 4;
    }
    //find default valency for our case
    return Math.max(0, defVal - valence);
  };
  Atom.prototype.getHydrogenCountMetal = function () {
    return 0;
  };
  Atom.prototype.getHydrogenCountGroup14 = function () {
    var valence = this._valence;
    if (valence === -1) {
      valence = this.getAtomBondsCount() - Math.abs(this.getCharge()) + this._radicalCount;
    }
    var defVal = this.findSuitableValence(valence);
    //find default valency for our case
    return Math.max(0, defVal - valence);
  };
  Atom.prototype.getHydrogenCountNonMetal = function () {
    // apply from Reaxys Drawing Guidelines (Version 2.04
    // January 2012) Standard Valence – (Valence + Charge + Number of Radical(s))
    var valence = this._valence;
    if (valence === -1) {
      valence = this.getAtomBondsCount() - this.getCharge() + this._radicalCount;
    }
    var defVal = this.findSuitableValence(valence);
    //find default valency for our case
    return Math.max(0, defVal - valence);
  };
  Atom.prototype.getHydrogenCountHydrogen = function () {
    if (this.getAtomBondsCount() === 0 && this.getCharge() === 0 && this.getValence() === 0 && this._radicalCount === 0) {
      return 1;
    }
    //do add in any other case
    return 0;
  };
  Atom.prototype.getHydrogenCount = function () {
    if (this._hydrogenCount >= 0) {
      return this._hydrogenCount;
    }
    var t = this.getType();
    var val = t.hydrogenValency;
    if (val.length === 1 && val[0] === 0) {
      return 0;
    }
    switch (t.number) {
    case 1:
      return this.getHydrogenCountHydrogen();
    case 3:
    case 11:
    case 19:
    case 37:
    case 55:
    case 87:
    //group 1
    case 4:
    case 12:
    case 20:
    case 38:
    case 56:
    case 88:
    //group 2
    case 13:
    case 31:
    case 49:
    case 41:
    //group 13 but Boron
    case 82:
    case 83:
      //Bi and Pb
      return this.getHydrogenCountMetal();
    case 6:
    case 14:
    case 32:
    case 51:
      //C, Si, Ge, Sb
      return this.getHydrogenCountGroup14();
    case 50:
      //Sn
      return this.getHydrogenCountTin();
    case 7:
    case 8:
    case 9:
    case 15:
    case 16:
    case 17:
    //N, O, F, P, S, Cl
    case 33:
    case 34:
    case 35:
    case 53:
    case 85:
      //As, Se, Br, I, At
      return this.getHydrogenCountNonMetal();
    case 5:
      return this.getHydrogenCountBoron();
    default:
      return 0;
    }
  };
  function getCylinderCount(bondOrder) {
    return bondOrder < 2 ? 1 : bondOrder;
  }
  Atom.prototype.getAtomBondsCount = function () {
    var explicitBonds = this.getBonds();
    var ebCount = 0;
    var i = 0;
    for (i = 0; i < explicitBonds.length; i++) {
      ebCount += getCylinderCount(explicitBonds[i].getOrder());
    }
    return ebCount;
  };
  Atom.prototype.findSuitableValence = function (valence) {
    var i = 0;
    var val = this.getType().hydrogenValency;
    var defVal = val[val.length - 1];
    for (i = 0; i < val.length; i++) {
      if (val[i] >= valence) {
        defVal = val[i];
        break;
      }
    }
    return defVal;
  };
  Atom.prototype.getCharge = function () {
    return this._charge;
  };
  Atom.prototype.getLocation = function () {
    return this._location;
  };
  return Atom;
}(chem_AtomName, chem_AtomType);
chem_ResidueType = function () {
  /**
   * Residue type.
   *
   * Predefined acid or created with HET, HETNAM, etc.
   *
   * @param {string} name            - Short name, either standard (ALA, MET, etc.) or non-standard one.
   * @param {string} fullName        - Full residue name.
   * @param {ResidueType.Kind} kind  - Kind (acidic, nucleic, etc.)
   *
   * @exports ResidueType
   * @constructor
   */
  function ResidueType(name, fullName, kind) {
    this._name = name;
    this._fullName = fullName;
    this._kind = kind;
    this._standard = true;
  }
  ResidueType.prototype.getName = function () {
    return this._name;
  };
  /**
   * Enumeration of residue kind values.
   *
   * @enum {number}
   * @readonly
   */
  ResidueType.Kind = {
    /** Unknown */
    UNKNOWN: 0,
    /** Amino acid residual */
    AMINO: 1,
    /** Nucleic acid residual */
    NUCLEIC: 2,
    /** Solvent */
    SOLVENT: 3  /* Other types here (polar, ion, etc.) */
  };
  // DO NOT EDIT MANUALLY! Autogenerated from residue_types.csv by residue_types.py.
  ResidueType.StandardTypes = {
    /* eslint-disable no-magic-numbers */
    'ALA': new ResidueType('ALA', 'Alanine', 1),
    'ARG': new ResidueType('ARG', 'Arginine', 1),
    'ASN': new ResidueType('ASN', 'Asparagine', 1),
    'ASP': new ResidueType('ASP', 'Aspartic Acid', 1),
    'CYS': new ResidueType('CYS', 'Cysteine', 1),
    'GLY': new ResidueType('GLY', 'Glycine', 1),
    'GLU': new ResidueType('GLU', 'Glutamic Acid', 1),
    'GLN': new ResidueType('GLN', 'Glutamine', 1),
    'HIS': new ResidueType('HIS', 'Histidine', 1),
    'ILE': new ResidueType('ILE', 'Isoleucine', 1),
    'LEU': new ResidueType('LEU', 'Leucine', 1),
    'LYS': new ResidueType('LYS', 'Lysine', 1),
    'MET': new ResidueType('MET', 'Methionine', 1),
    'PHE': new ResidueType('PHE', 'Phenylalanine', 1),
    'PRO': new ResidueType('PRO', 'Proline', 1),
    'SEC': new ResidueType('SEC', 'Selenocysteine', 1),
    'SER': new ResidueType('SER', 'Serine', 1),
    'THR': new ResidueType('THR', 'Threonine', 1),
    'TRP': new ResidueType('TRP', 'Tryptophan', 1),
    'TYR': new ResidueType('TYR', 'Tyrosine', 1),
    'VAL': new ResidueType('VAL', 'Valine', 1),
    'A': new ResidueType('A', 'Adenine', 2),
    'C': new ResidueType('C', 'Cytosine', 2),
    'G': new ResidueType('G', 'Guanine', 2),
    'I': new ResidueType('I', 'Inosine', 2),
    'T': new ResidueType('T', 'Thymine', 2),
    'U': new ResidueType('U', 'Uracil', 2),
    'DA': new ResidueType('DA', 'Adenine', 2),
    'DC': new ResidueType('DC', 'Cytosine', 2),
    'DG': new ResidueType('DG', 'Guanine', 2),
    'DI': new ResidueType('DI', 'Inosine', 2),
    'DT': new ResidueType('DT', 'Thymine', 2),
    'DU': new ResidueType('DU', 'Uracil', 2),
    '+A': new ResidueType('+A', 'Adenine', 2),
    '+C': new ResidueType('+C', 'Cytosine', 2),
    '+G': new ResidueType('+G', 'Guanine', 2),
    '+I': new ResidueType('+I', 'Inosine', 2),
    '+T': new ResidueType('+T', 'Thymine', 2),
    '+U': new ResidueType('+U', 'Uracil', 2),
    'WAT': new ResidueType('WAT', 'Water', 3),
    'H2O': new ResidueType('H2O', 'Water', 3),
    'HOH': new ResidueType('HOH', 'Water', 3),
    'UNK': new ResidueType('UNK', 'Unknown', 0),
    'UNL': new ResidueType('UNL', 'Unknown Ligand', 0)  /* eslint-enable no-magic-numbers */
  };
  return ResidueType;
}();
chem_Residue = function (Atom, AtomType, THREE, ResidueType) {
  //////////////////////////////////////////////////////////////////////////////
  var cNucleicControlNames = [
    ' C3\'',
    ' C3*',
    ' P  ',
    ' H5T',
    ' H3T'
  ];
  var cNucleicWing1Names = [
    ' OP1',
    ' O1P'
  ];
  var cNucleicWing2Names = [
    ' OP2',
    ' O2P'
  ];
  var cCylinderSource = [
    ' C3\'',
    ' C3*',
    ' C1',
    ' C1\'',
    ' C1*',
    ' P  '
  ];
  var cCylinderTarget = [
    ' N1 ',
    ' N3 ',
    ' O4 '
  ];
  /**
   * Residue instance.
   *
   * @param {Chain} chain      - Chain this residue belongs to.
   * @param {ResidueType} type - Generic residue instance type.
   * @param {number} sequence  - Sequence ID.
   * @param {string} icode     - One character insertion code (usually space or A-Z).
   *
   * @exports Residue
   * @constructor
   */
  function Residue(chain, type, sequence, icode) {
    this._chain = chain;
    this._component = null;
    this._type = type;
    this._sequence = sequence;
    this._icode = icode;
    this._mask = 1 | 0;
    this._index = -1;
    this._atoms = [];
    // TODO: change to range
    this._secondary = null;
    this._firstAtom = null;
    this._leadAtom = null;
    this._wingAtom = null;
    this._lastAtom = null;
    this._controlPoint = null;
    this._midPoint = null;
    this._wingVector = null;
    this._cylinders = null;
    this._isValid = true;
    this._het = false;
  }
  // Getters and setters
  Residue.prototype.getChain = function () {
    return this._chain;
  };
  Residue.prototype.getType = function () {
    return this._type;
  };
  Residue.prototype.getSequence = function () {
    return this._sequence;
  };
  Residue.prototype.getSecondary = function () {
    return this._secondary;
  };
  Residue.prototype.getICode = function () {
    return this._icode;
  };
  // Other methods
  Residue.prototype.addAtom = function (name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge) {
    var atom = new Atom(this, name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge);
    var complex = this._chain.getComplex();
    /* var index = */
    complex.addAtom(atom);
    this._atoms.push(atom);
    // TODO: change to range
    this._het = this._het || het;
    return atom;
  };
  Residue.prototype.getAtomCount = function () {
    return this._atoms.length;
  };
  Residue.prototype.forEachAtom = function (process) {
    var atoms = this._atoms;
    for (var i = 0, n = atoms.length; i < n; ++i) {
      if (process(atoms[i])) {
        break;
      }
    }
  };
  Residue.prototype._findAtomByName = function (name) {
    var res = null;
    this.forEachAtom(function (atom) {
      if (atom._name._name === name) {
        res = atom;
        return true;
      }
      return false;
    });
    return res;
  };
  Residue.prototype._findFirstAtomInList = function (names) {
    var res = null;
    for (var i = 0; i < names.length; ++i) {
      res = this._findAtomByName(names[i]);
      if (res !== null) {
        return res;
      }
    }
    return res;
  };
  Residue.prototype.collectMask = function () {
    var mask = 4294967295;
    var atoms = this._atoms;
    for (var i = 0, n = atoms.length; i < n; ++i) {
      mask &= atoms[i]._mask;
    }
    this._mask = mask;
  };
  Residue.prototype._detectLeadWing = function () {
    var leadAtom = this._findFirstAtomInList(cNucleicControlNames);
    var wingStart = this._findFirstAtomInList(cNucleicWing1Names);
    var wingEnd = this._findFirstAtomInList(cNucleicWing2Names);
    if (leadAtom === null || wingStart === null || wingEnd === null) {
      return;
    }
    this._leadAtom = leadAtom;
    this._controlPoint = leadAtom._position;
    this._wingVector = wingEnd._position.clone().sub(wingStart._position);
    this._isValid = true;
    var cylSource = this._findFirstAtomInList(cCylinderSource);
    var cylTarget = this._findFirstAtomInList(cCylinderTarget);
    if (cylSource === null || cylTarget === null) {
      return;
    }
    this._cylinders = [
      cylSource,
      cylTarget
    ];
  };
  Residue.prototype._finalize2 = function (prev) {
    //Should be called AFTER first finalize
    var bFirstInChain = prev === null;
    /* eslint-disable no-magic-numbers */
    var half = 0.5;
    var minusOne = -1;
    /* eslint-enable no-magic-numbers */
    var lp = this._leadAtom._position;
    var leadPoint = new THREE.Vector3(lp.x, lp.y, lp.z);
    if (this._type._kind === ResidueType.Kind.NUCLEIC) {
      this._detectLeadWing();
      return;
    }
    if (bFirstInChain) {
      //for first one in chain
      this._midPoint = new THREE.Vector3(this._firstAtom._position);
    } else {
      var pp = prev._leadAtom._position;
      var leadPointPrev = new THREE.Vector3(pp.x, pp.y, pp.z);
      //lead point of previous monomer
      this._midPoint = new THREE.Vector3(0, 0, 0);
      this._midPoint.addScaledVector(leadPointPrev, half);
      this._midPoint.addScaledVector(this._leadAtom._position, half);
      var vectorA = new THREE.Vector3(0, 0, 0).subVectors(this._leadAtom._position, leadPointPrev);
      var ato = prev._wingAtom._position;
      var vectorB = new THREE.Vector3(0, 0, 0).subVectors(leadPointPrev, ato);
      var vectorC = new THREE.Vector3(0, 0, 0).crossVectors(vectorA, vectorB);
      var vectorD = new THREE.Vector3(0, 0, 0).crossVectors(vectorA, vectorC);
      vectorD.normalize();
      if (prev._wingVector !== null && Math.abs(prev._wingVector.angleTo(vectorD)) > Math.PI / 2) {
        vectorD.multiplyScalar(minusOne);
      }
      this._wingVector = vectorD;
    }
    this._controlPoint = leadPoint;
  };
  Residue.prototype.isConnected = function (anotherResidue) {
    if (this === anotherResidue) {
      return true;
    }
    var res = false;
    this.forEachAtom(function (atom) {
      var bonds = atom._bonds;
      for (var i = 0, n = bonds.length; i < n; ++i) {
        var bond = bonds[i];
        if (bond._left._residue === anotherResidue || bond._right._residue === anotherResidue) {
          res = true;
          return true;
        }
      }
      return false;
    });
    return res;
  };
  Residue.prototype._finalize = function () {
    var self = this;
    this._firstAtom = this._atoms[0];
    this._lastAtom = this._atoms[this._atoms.length - 1];
    this._leadAtom = null;
    this._wingAtom = null;
    // TODO: Is it correct? Is it fast?
    this.forEachAtom(function (a) {
      if (self._leadAtom === null) {
        if (a._role === AtomType.Constants.Lead) {
          self._leadAtom = a;
        }
      }
      if (self._wingAtom === null) {
        if (a._role === AtomType.Constants.Wing) {
          self._wingAtom = a;
        }
      }
      return self._leadAtom !== null && self._wingAtom !== null;
    });
    //Still try to make monomer look valid
    if (this._leadAtom === null || this._wingAtom === null) {
      this._isValid = false;
    }
    if (this._leadAtom === null) {
      this._leadAtom = this._firstAtom;
    }
    if (this._wingAtom === null) {
      this._wingAtom = this._lastAtom;
    }
  };
  return Residue;
}(chem_Atom, chem_AtomType, three, chem_ResidueType);
chem_Chain = function (Residue, THREE) {
  //////////////////////////////////////////////////////////////////////////////
  /**
   * Residue chain.
   *
   * @param {Complex} complex - Molecular complex this chain belongs to.
   * @param {string} name - One character identifier (usually space, A-Z, 0-9, or a-z).
   *
   * @exports Chain
   * @constructor
   */
  function Chain(complex, name) {
    this._complex = complex;
    this._name = name;
    this._visible = true;
    this._mask = 1 | 0;
    this._index = -1;
    this._residues = [];  // TODO: change to range
  }
  Chain.prototype.getComplex = function () {
    return this._complex;
  };
  Chain.prototype.getName = function () {
    return this._name;
  };
  Chain.prototype.isVisible = function () {
    return this._visible;
  };
  Chain.prototype.getResidues = function () {
    return this._residues;
  };
  Chain.prototype._finalize = function () {
    var residues = this._residues;
    var prev = null, curr = null;
    for (var i = 0, n = residues.length; i < n; ++i) {
      curr = residues[i];
      // TODO: skip invalid residues
      if (1  /* curr._isValid */) {
        // eslint-disable-line no-constant-condition
        curr._finalize2(prev);
        prev = curr;
      }
    }
    //fix very first wing
    if (residues.length > 1) {
      var p = residues[1]._wingVector;
      residues[0]._wingVector = new THREE.Vector3(p.x, p.y, p.z);
    } else if (residues.length > 0) {
      residues[0]._wingVector = new THREE.Vector3(1, 0, 0);
    }
  };
  /**
   * Create a new residue.
   *
   * @param {string} name - Residue name.
   * @param {number} sequence - Residue sequence number.
   * @param {string} iCode - Insertion code.
   * @returns {Residue} - Newly created residue instance.
   */
  Chain.prototype.addResidue = function (name, sequence, iCode) {
    var type = this._complex.getResidueType(name);
    if (type === null) {
      type = this._complex.addResidueType(name);
    }
    var residue = new Residue(this, type, sequence, iCode);
    /* var index = */
    this._complex.addResidue(residue);
    this._residues.push(residue);
    // TODO: change to range
    return residue;
  };
  Chain.prototype.getResidueCount = function () {
    return this._residues.length;
  };
  Chain.prototype.forEachResidue = function (process) {
    var residues = this._residues;
    for (var i = 0, n = residues.length; i < n; ++i) {
      process(residues[i]);
    }
  };
  Chain.prototype.collectMask = function () {
    var mask = 4294967295;
    var residues = this._residues;
    for (var i = 0, n = residues.length; i < n; ++i) {
      mask &= residues[i]._mask;
    }
    this._mask = mask;
  };
  return Chain;
}(chem_Residue, three);
chem_Component = function () {
  //////////////////////////////////////////////////////////////////////////////
  /**
   * This class represents connected component as a part of a complex.
   *
   * @param {Complex} complex - Molecular complex this chain belongs to.
   *
   * @exports Component
   * @constructor
   */
  function Component(complex) {
    this._complex = complex;
    this._index = -1;
    this._visible = true;
    this._residues = [];
    // TODO: change to range
    this._cycles = [];
  }
  Component.prototype.getResidues = function () {
    return this._residues;
  };
  Component.prototype.getResidueCount = function () {
    return this._residues.length;
  };
  Component.prototype.forEachResidue = function (process) {
    var residues = this._residues;
    for (var i = 0, n = residues.length; i < n; ++i) {
      process(residues[i]);
    }
  };
  Component.prototype.getComplex = function () {
    return this._complex;
  };
  Component.prototype.forEachBond = function (process) {
    var bonds = this._complex._bonds;
    for (var i = 0, n = bonds.length; i < n; ++i) {
      var bond = bonds[i];
      if (bond._left._residue._component === this) {
        process(bond);
      }
    }
  };
  Component.prototype.update = function () {
    this.forEachCycle(function (cycle) {
      cycle.update();
    });
  };
  Component.prototype.forEachAtom = function (process) {
    this.forEachResidue(function (residue) {
      residue.forEachAtom(process);
    });
  };
  Component.prototype.addCycle = function (cycle) {
    this._cycles.push(cycle);
  };
  Component.prototype.forEachCycle = function (process) {
    var cycles = this._cycles;
    for (var i = 0, n = cycles.length; i < n; ++i) {
      process(cycles[i]);
    }
  };
  Component.prototype.markResidues = function () {
    var self = this;
    self.forEachResidue(function (residue) {
      residue._component = self;
    });
  };
  Component.prototype._forEachSubChain = function (mask, process) {
    var residues = this._residues;
    var resCount = residues.length;
    for (var idx = 0; idx < resCount; ++idx) {
      var currRes = residues[idx];
      if (mask & currRes._mask && currRes._isValid) {
        var end = idx + 1;
        for (; end < resCount; ++end) {
          var endRes = residues[end];
          if (!(mask & endRes._mask && endRes._isValid)) {
            break;
          }
        }
        process(idx, end - 1);
        idx = end;
      }
    }
  };
  Component.prototype.getMaskedSequences = function (mask) {
    var subs = [];
    this._forEachSubChain(mask, function (start, end) {
      subs.push({
        start: start,
        end: end
      });
    });
    return subs;
  };
  return Component;
}();
chem_Bond = function () {
  //////////////////////////////////////////////////////////////////////////////
  var cBondTypes = {
    /** Was generated manually */
    UNKNOWN: 0,
    /** Simple covalent bond */
    COVALENT: 1,
    /** Aromatic bond */
    AROMATIC: 2
  };
  /**
   * Bond between atoms.
   *
   * @param {Atom} left     - The first atom.
   * @param {Atom} right    - The second atom.
   * @param {number} order - Order of current bond.
   * @param {number} type - Bond type.
   * @param {boolean} fixed - Indicator of a pre-specified connection (in contrast with guessed one).
   *
   * @exports Bond
   * @constructor
   */
  function Bond(left, right, order, type, fixed) {
    this._left = left;
    this._right = right;
    this._fixed = fixed;
    this._index = -1;
    if (left > right) {
      console.log('Logic error.');
    }
    this._order = order;
    this._type = type;
  }
  Bond.BondType = cBondTypes;
  Bond.prototype.BondType = cBondTypes;
  Bond.prototype.getLeft = function () {
    return this._left;
  };
  Bond.prototype.getRight = function () {
    return this._right;
  };
  Bond.prototype.getOrder = function () {
    return this._order;
  };
  Bond.prototype._forEachNeighbour = function (currAtom, process) {
    var bonds = currAtom._bonds;
    for (var i = 0, n = bonds.length; i < n; ++i) {
      process(bonds[i]._left !== currAtom ? bonds[i]._left : bonds[i]._right);
    }
  };
  Bond.prototype.forEachLevelOne = function (process) {
    var left = this._left;
    var right = this._right;
    this._forEachNeighbour(left, function (atom) {
      if (atom === right) {
        return;
      }
      process(atom);
    });
    this._forEachNeighbour(right, function (atom) {
      if (atom === left) {
        return;
      }
      process(atom);
    });
  };
  Bond.prototype.forEachLevelTwo = function (process) {
    // TODO refactor this piece of an art?
    var left = this._left;
    var right = this._right;
    var self = this;
    self._forEachNeighbour(left, function (atom) {
      if (atom === right) {
        return;
      }
      self._forEachNeighbour(atom, function (l2Atom) {
        if (l2Atom === left) {
          return;
        }
        process(l2Atom);
      });
    });
    self._forEachNeighbour(right, function (atom) {
      if (atom === left) {
        return;
      }
      self._forEachNeighbour(atom, function (l2Atom) {
        if (l2Atom === right) {
          return;
        }
        process(l2Atom);
      });
    });
  };
  Bond.prototype.fixDir = function (refPoint, currDir) {
    // count atoms to the right and to the left of the current plane
    var rightCount = 0;
    var leftCount = 0;
    var tmpVec = refPoint.clone();
    function checkDir(atom) {
      tmpVec.copy(atom._position);
      tmpVec.sub(refPoint);
      var dotProd = currDir.dot(tmpVec);
      if (dotProd > 0) {
        ++rightCount;
      } else {
        ++leftCount;
      }
    }
    function checkCarbon(atom) {
      if (atom._type.name === 'C') {
        checkDir(atom);
      }
    }
    // count all atoms to the left and right of our plane, start from level 1 and carbons
    var stages = [
      [
        this.forEachLevelOne,
        checkCarbon
      ],
      [
        this.forEachLevelOne,
        checkDir
      ],
      [
        this.forEachLevelTwo,
        checkCarbon
      ],
      [
        this.forEachLevelTwo,
        checkDir
      ]
    ];
    for (var stageId = 0; stageId < stages.length; ++stageId) {
      stages[stageId][0].call(this, stages[stageId][1]);
      if (leftCount > rightCount) {
        return currDir.multiplyScalar(-1);
      } else if (leftCount < rightCount) {
        return currDir;
      }
    }
    return currDir;
  };
  Bond.prototype.calcNormalDir = function () {
    var left = this._left;
    var right = this._right;
    var first = left;
    var second = right;
    if (left._bonds.length > right._bonds.length) {
      first = right;
      second = left;
    }
    var third = first;
    var maxNeibs = 0;
    var bonds = second._bonds;
    for (var i = 0, n = bonds.length; i < n; ++i) {
      var another = bonds[i]._left;
      if (bonds[i]._left === second) {
        another = bonds[i]._right;
      }
      if (another._bonds.length > maxNeibs && another !== first) {
        third = another;
        maxNeibs = another._bonds.length;
      }
    }
    var firstV = first._position.clone().sub(second._position);
    var secondV = third._position.clone().sub(second._position);
    secondV.crossVectors(firstV, secondV);
    if (secondV.lengthSq() < 0.0001) {
      secondV.set(0, 1, 0);
    }
    firstV.normalize();
    secondV.normalize();
    firstV.crossVectors(secondV, firstV);
    if (firstV.lengthSq() < 0.0001) {
      firstV.set(0, 1, 0);
    }
    firstV.normalize();
    return this.fixDir(second._position, firstV);
  };
  return Bond;
}();
chem_AtomPairs = function (utils) {
  //////////////////////////////////////////////////////////////////////////////
  var cMaxPairsForHashCode = 32;
  var cHashTableSize = 16384;
  var cNumbersPerPair = 4;
  var cMaxNeighbours = 14;
  var cErrorCode = -1;
  var cInvalidVal = -1;
  // 89237 is a large simple number, can be used for pseudo random hash code create
  var cBigPrime = 89237;
  function PairCollection(maxPairsEstimate) {
    var i = 0;
    this.numPairs = 0;
    this.numMaxPairs = maxPairsEstimate;
    this.intBuffer = utils.allocateTyped(Int32Array, maxPairsEstimate * cNumbersPerPair);
    for (; i < maxPairsEstimate * cNumbersPerPair; i++) {
      this.intBuffer[i] = cInvalidVal;
    }
    this.hashBuffer = utils.allocateTyped(Int32Array, cHashTableSize * cMaxPairsForHashCode);
    for (i = 0; i < cHashTableSize * cMaxPairsForHashCode; i++) {
      this.hashBuffer[i] = cInvalidVal;
    }
  }
  /**
   * Destroy all pairs memory
   */
  PairCollection.prototype.destroy = function () {
    this.intBuffer = null;
    this.hashBuffer = null;
  };
  /**
   * Add pair of atoms to collection
   * @param {number} indexA - Index of the 1st vertex.
   * @param {number} indexB - Index of the 2nd vertex.
   * @returns {number} zero on success
   */
  PairCollection.prototype.addPair = function (indexA, indexB) {
    var ia = indexA < indexB ? indexA : indexB;
    var ib = indexA > indexB ? indexA : indexB;
    var code = 0;
    var codeToAdd = ia + (ib << cMaxNeighbours);
    var hashCode = ia + ib * cBigPrime & cHashTableSize - 1;
    var j = hashCode * cMaxPairsForHashCode;
    var apI = 0;
    for (; apI < cMaxPairsForHashCode; apI++) {
      code = this.hashBuffer[j + apI];
      if (code === cInvalidVal) {
        break;
      }
      if (code === codeToAdd) {
        return 0;
      }
    }
    // add this new hash code
    if (apI >= cMaxPairsForHashCode) {
      console.log('bad hash code: increase cMaxPairsForHashCode');
      return cErrorCode;
    }
    this.hashBuffer[j + apI] = codeToAdd;
    // actually add
    if (this.numPairs >= this.numMaxPairs) {
      console.log('Increase num pairs');
      return cErrorCode;
    }
    j = this.numPairs * cNumbersPerPair;
    this.intBuffer[j] = ia;
    this.intBuffer[j + 1] = ib;
    this.intBuffer[j + 2] = codeToAdd;
    this.numPairs++;
    return 0;
  };
  return PairCollection;
}(utils);
chem_AutoBond = function (THREE, PairCollection, Bond) {
  //////////////////////////////////////////////////////////////////////////////
  var cProfileBondBuilder = false;
  var cEstBondsMultiplier = 4;
  var cSpaceCode = 32;
  var cBondTolerance = 0.45;
  var cVMDTolerance = 0.6;
  var cBondRadInJMOL = true;
  var cEpsilon = 0.001;
  /**
   * Get radius used for building bonds.
   *
   * @param {Atom} atom - Atom object.
   * @returns {number} special value for bonding radius for this atom
   */
  function _getBondingRadius(atom) {
    var bondRad = 0;
    var at = atom.getType();
    if (at) {
      bondRad = at.radiusBonding;
    } else {
      console.log('_getBondingRadius: Logic error.');
    }
    return bondRad;
  }
  /**
   * Returns value, limited in given range (min, max)
   * @param {number} val modified value
   * @param {number} valMin minimum value in range
   * @param {number} valMax maximum value in range
   * @returns {number} original value (if it lie inside range) or range bound (left or right)
   */
  function _clamp(val, valMin, valMax) {
    if (val < valMin) {
      return valMin;
    }
    if (val > valMax) {
      return valMax;
    }
    return val;
  }
  function _isAtomEligible(atom) {
    return !atom.isHet() && atom.getResidue().getChain().isVisible();
  }
  /**
     * Bond between atoms.
     *
     * @param {Vector3} complex molecular complex
  
     * @exports AutoBond
     * @constructor
     */
  function AutoBond(complex) {
    this._complex = complex;
    this._maxRad = 1.8;
    var cmp = complex;
    // this was added as a warning fix
    this._vBoxMin = cmp.boundingBox.min.clone();
    this._vBoxMax = cmp.boundingBox.max.clone();
    this._pairCollection = null;
  }
  /**
   * Add existing pairs of connectors (from pdb file after its reading)
   * @returns {number} 0
   */
  AutoBond.prototype._addExistingPairs = function () {
    var atoms = this._complex.getAtoms();
    var numAtoms = atoms.length;
    var aInd = 0;
    var collection = this._pairCollection;
    for (; aInd < numAtoms; aInd++) {
      var bonds = atoms[aInd]._bonds;
      var numBondsForAtom = bonds.length;
      for (var bInd = 0; bInd < numBondsForAtom; bInd++) {
        var bond = bonds[bInd];
        var indTo = bond._left._index;
        if (indTo === aInd) {
          collection.addPair(aInd, bond._right._index);
        }
      }  // for (b) all bonds in atom
    }
    // for (a)
    return 0;
  };
  AutoBond.prototype._findPairs = function (volMap) {
    var atoms = this._complex._atoms;
    var atomsNum = atoms.length;
    var vBoxMin = this._vBoxMin;
    var xB = this.xB;
    var yB = this.yB;
    var zB = this.zB;
    var invPairDist = this.invPairDist;
    var maxAcceptable = 0;
    var xyTotalBoxes = yB * xB;
    for (var i = 0; i < atomsNum; ++i) {
      var atom = atoms[i];
      if (!_isAtomEligible(atom)) {
        continue;
      }
      var rA = atom.getType().radiusBonding;
      // 'H' == 72
      var isHydrogenA = atom.isHydrogen();
      var locationA = atom.getLocation();
      var posA = atom._position;
      var axB = (posA.x - vBoxMin.x) * invPairDist | 0;
      var ayB = (posA.y - vBoxMin.y) * invPairDist | 0;
      var azB = (posA.z - vBoxMin.z) * invPairDist | 0;
      for (var dz = -1; dz <= 1; ++dz) {
        var zInd = azB + dz;
        if (zInd < 0 || zInd >= zB) {
          continue;
        }
        for (var dy = -1; dy <= 1; ++dy) {
          var yInd = ayB + dy;
          if (yInd < 0 || yInd >= yB) {
            continue;
          }
          for (var dx = -1; dx <= 1; ++dx) {
            var xInd = axB + dx;
            if (xInd < 0 || xInd >= xB) {
              continue;
            }
            var iIndex = zInd * xyTotalBoxes + yInd * xB + xInd;
            var neighbours = volMap[iIndex];
            for (var j = 0; j < neighbours.length; ++j) {
              var iB = neighbours[j];
              if (iB <= i) {
                continue;
              }
              var atomB = atoms[iB];
              if (isHydrogenA && atomB.isHydrogen()) {
                continue;
              }
              var locationB = atomB.getLocation();
              if (locationA !== cSpaceCode && locationB !== cSpaceCode && locationA !== locationB) {
                continue;
              }
              var dist2 = posA.distanceToSquared(atomB._position);
              var rB = atomB.getType().radiusBonding;
              if (cBondRadInJMOL) {
                // JMOL style criteria
                maxAcceptable = rA + rB + cBondTolerance;
              } else {
                // VMD style criteria
                maxAcceptable = cVMDTolerance * (rA + rB);
              }
              if (dist2 > maxAcceptable * maxAcceptable) {
                continue;
              }
              if (dist2 < cEpsilon) {
                continue;
              }
              this._pairCollection.addPair(i, iB);
            }
          }
        }
      }
    }
  };
  AutoBond.prototype._addPairs = function () {
    var atoms = this._complex._atoms;
    var k = 0;
    var iA = 0, iB = 0;
    for (var i = 0; i < this._pairCollection.numPairs; i++, k += 4) {
      iA = this._pairCollection.intBuffer[k];
      iB = this._pairCollection.intBuffer[k + 1];
      this._addPair(atoms[iA], atoms[iB]);
    }
  };
  AutoBond.prototype._addPair = function (atomA, atomB) {
    var bondsA = atomA._bonds;
    var indexA = atomA._index;
    var indexB = atomB._index;
    for (var j = 0, numBonds = bondsA.length; j < numBonds; ++j) {
      var bond = bondsA[j];
      if (bond._left._index === indexB || bond._right._index === indexB) {
        return;
      }
    }
    var left = indexA < indexB ? atomA : atomB;
    var right = indexA < indexB ? atomB : atomA;
    var newBond = this._complex.addBond(left, right, 0, Bond.BondType.UNKWOWN, false);
    bondsA.push(newBond);
    atomB.getBonds().push(newBond);
  };
  AutoBond.prototype.build = function () {
    if (cProfileBondBuilder) {
      console.time('Bonds Builder');
    }
    // TODO verify that complex is ready
    this._buildInner();
    if (cProfileBondBuilder) {
      console.timeEnd('Bonds Builder');
    }
  };
  AutoBond.prototype._buildInner = function () {
    var atoms = this._complex._atoms;
    if (atoms.length < 2) {
      return;
    }
    if (atoms[0]._index < 0) {
      console.error('AutoBond: Atoms in complex were not indexed.');
      return;
    }
    this._calcBoundingBox();
    var volMap = this._buildGridMap();
    this._pairCollection = new PairCollection(atoms.length * cEstBondsMultiplier);
    this._addExistingPairs();
    this._findPairs(volMap);
    this._addPairs();
    volMap = null;
  };
  AutoBond.prototype._calcBoundingBox = function () {
    var atoms = this._complex._atoms;
    var nAtoms = atoms.length;
    var maxRad = _getBondingRadius(atoms[0]);
    for (var i = 1; i < nAtoms; ++i) {
      maxRad = Math.max(maxRad, _getBondingRadius(atoms[i]));
    }
    this._vBoxMax.addScalar(maxRad);
    this._vBoxMin.addScalar(-maxRad);
    this._maxRad = maxRad * 1.2;
  };
  AutoBond.prototype._buildGridMap = function () {
    var cMaxBoxes = 125000;
    var cRadMultiplier = 1.26;
    var totalBoxes = cMaxBoxes + 1;
    var pairDist = this._maxRad * 2;
    var newPairDist = pairDist;
    var vBoxMin = this._vBoxMin;
    var vBoxMax = this._vBoxMax;
    var xRange = vBoxMax.x - vBoxMin.x;
    var yRange = vBoxMax.y - vBoxMin.y;
    var zRange = vBoxMax.z - vBoxMin.z;
    var xB, yB, zB, xyTotalBoxes;
    var invPairDist;
    do {
      pairDist = newPairDist;
      invPairDist = 1 / pairDist;
      xB = (xRange * invPairDist | 0) + 1;
      yB = (yRange * invPairDist | 0) + 1;
      zB = (zRange * invPairDist | 0) + 1;
      xyTotalBoxes = yB * xB;
      totalBoxes = xyTotalBoxes * zB;
      newPairDist = pairDist * cRadMultiplier;
    } while (totalBoxes > cMaxBoxes);
    this.xB = xB;
    this.yB = yB;
    this.zB = zB;
    this.invPairDist = invPairDist;
    var voxMap = [];
    var i = 0;
    for (; i < totalBoxes; ++i) {
      voxMap[i] = [];
    }
    var atoms = this._complex._atoms;
    var nAtoms = atoms.length;
    for (i = 0; i < nAtoms; ++i) {
      if (!_isAtomEligible(atoms[i])) {
        continue;
      }
      var pos = atoms[i]._position;
      var axB = _clamp((pos.x - vBoxMin.x) * invPairDist | 0, 0, xB);
      var ayB = _clamp((pos.y - vBoxMin.y) * invPairDist | 0, 0, yB);
      var azB = _clamp((pos.z - vBoxMin.z) * invPairDist | 0, 0, zB);
      var iIndex = azB * xyTotalBoxes + ayB * xB + axB;
      voxMap[iIndex].push(i);
    }
    return voxMap;
  };
  AutoBond.prototype.destroy = function () {
    this._pairCollection.destroy();
  };
  return AutoBond;
}(three, chem_AtomPairs, chem_Bond);
chem_SGroup = function (Atom, AtomName, THREE) {
  //////////////////////////////////////////////////////////////////////////////
  /**
   * Atom measurements.
   *
   * @param {string} id              - SGroup id
   * @param {AtomName} name          - Name of the group
   * @param {THREE.Vector3} position - Registered coordinates
   * @param {array} atoms            - Atoms group consists of
   * @param {object} saveNode        - XML node from file for saving
   *
   * @exports SGroup
   * @constructor
   */
  function SGroup(id, name, position, atoms, saveNode) {
    this._id = id;
    this._name = name;
    this._position = position || new THREE.Vector3();
    this._atoms = atoms || [];
    this._charge = 0;
    //default group charge
    this._repeat = 1;
    //how many times group repeated: always > 0
    this._center = null;
    this.xmlNodeRef = saveNode || null;
  }
  /**
   * Get atom full name.
   * @returns {AtomName} Atom full name.
   */
  SGroup.prototype.getName = function () {
    return this._name;
  };
  SGroup.prototype.getPosition = function () {
    return this._position;
  };
  SGroup.prototype.getCentralPoint = function () {
    return this._center;
  };
  SGroup.prototype._rebuildSGroupOnAtomChange = function () {
    var nLimon = 100000000;
    if (this._center === null) {
      return;  //nothing to do if we are not relative
    }
    var j = 0, n = this._atoms.length;
    var bLow = new THREE.Vector3(nLimon, nLimon, nLimon);
    var bHight = new THREE.Vector3(-nLimon, -nLimon, -nLimon);
    var aPos = null;
    for (; j < n; j++) {
      aPos = this._atoms[j].getPosition();
      bLow.set(Math.min(bLow.x, aPos.x), Math.min(bLow.y, aPos.y), Math.min(bLow.z, aPos.z));
      bHight.set(Math.max(bHight.x, aPos.x), Math.max(bHight.y, aPos.y), Math.max(bHight.z, aPos.z));
    }
    this._center.addVectors(bLow, bHight);
    this._center.multiplyScalar(0.5);
  };
  SGroup.prototype.buildChemicalFormula = function (complex, part) {
    var calcCharge = 0;
    var atomsCount = 0;
    var formula = complex._buildFormulaSimple(part, function (l, c) {
      atomsCount = l;
      calcCharge = c;
    });
    var finalCharge = this._charge + calcCharge;
    if (finalCharge !== 0) {
      if (this._repeat > 1) {
        if (atomsCount > 1) {
          formula = this._repeat.toString() + '(' + formula + ')';
        } else {
          formula = this._repeat.toString() + formula;
        }
      } else if (atomsCount > 1) {
        formula = '(' + formula + ')';
      }
      if (finalCharge > 1) {
        formula += '^' + finalCharge.toString() + '+';
      }
      if (finalCharge === 1) {
        formula += '^+';
      }
      if (finalCharge < -1) {
        formula += '^' + Math.abs(finalCharge).toString() + '-';
      }
      if (finalCharge === -1) {
        formula += '^-';
      }
    } else if (this._repeat > 1) {
      formula = this._repeat.toString() + formula;
    }
    return formula;
  };
  return SGroup;
}(chem_Atom, chem_AtomName, three);
chem_AromaticMarker = function (THREE, Bond) {
  var cCrossThresh = 0.001;
  var cAromaticType = Bond.BondType.AROMATIC;
  /** Conditions for bonds:
   *   - Cross product with each subsequent bond to add is collinear and point to the same direction
   *   - Each pair of a adjacent bonds belong to not more than one cycle
   *   - If there is more than one candidates we try them in ascending order of angle values
   */
  function _coDirVectors(v1, v2) {
    var cp = v1.cross(v2);
    if (cp.length() > cCrossThresh) {
      return false;
    }
    // zero vector in out terms must be collinear to any
    return v1.dot(v2) >= 0;
  }
  function _insertAscending(arr, val) {
    var idx = 0;
    while (idx < arr.length && arr[idx] < val) {
      ++idx;
    }
    arr.splice(idx, 0, val);
  }
  function _anotherAtom(bond, currAtom) {
    return bond._left === currAtom ? bond._right : bond._left;
  }
  function _cosBetween(v1, v2) {
    var theta = v1.dot(v2) / Math.sqrt(v1.lengthSq() * v2.lengthSq());
    return THREE.Math.clamp(theta, -1, 1);
  }
  function Cycle(atomsList) {
    this.atoms = atomsList;
    this.update();
  }
  Cycle.prototype.update = function () {
    var atoms = this.atoms;
    var center = new THREE.Vector3();
    var nA = atoms.length;
    for (var j = 0; j < nA; ++j) {
      center.add(atoms[j]._position);
    }
    center.multiplyScalar(1 / nA);
    this.center = center;
    this.radius = center.distanceTo(atoms[0]._position.clone().lerp(atoms[1]._position, 0.5));
  };
  function AromaticLoopsMarker(complex) {
    this._complex = complex;
    var bondsData = new Array(complex._bonds.length);
    var bondMarks = new Array(complex._bonds.length);
    for (var i = 0, n = bondsData.length; i < n; ++i) {
      bondsData[i] = [];
      bondMarks[i] = false;
    }
    this._bondsData = bondsData;
    this._bondMarks = bondMarks;
    this._cycles = [];
    this._currIdx = -1;
  }
  AromaticLoopsMarker.prototype._haveSameCycle = function (bondsData, bond1, bond2) {
    var arr1 = bondsData[bond1._index];
    var arr2 = bondsData[bond2._index];
    var n1 = arr1.length;
    var n2 = arr2.length;
    var i1 = 0;
    var i2 = 0;
    while (i1 < n1 && i2 < n2) {
      if (arr1[i1] === arr2[i2]) {
        return true;
      }
      if (arr1[i1] > arr2[i2]) {
        ++i2;
      } else {
        ++i1;
      }
    }
    return false;
  };
  AromaticLoopsMarker.prototype._tryBond = function (prevBond, currRight, currDir) {
    var bondsOrder = [];
    var bondsData = this._bondsData;
    var currLeft = _anotherAtom(prevBond, currRight);
    var currVec = currRight._position.clone().sub(currLeft._position);
    var startAtomRef = this._currStart;
    var self = this;
    var bondMarks = this._bondMarks;
    bondMarks[prevBond._index] = true;
    currRight.forEachBond(function (newBond) {
      if (newBond._type !== cAromaticType || newBond === prevBond || bondMarks[newBond._index] || self._haveSameCycle(bondsData, prevBond, newBond)) {
        return;
      }
      var anotherAtom = _anotherAtom(newBond, currRight);
      var anotherVec = anotherAtom._position.clone().sub(currRight._position);
      var val = anotherAtom === startAtomRef ? -2 : 1 - _cosBetween(currVec, anotherVec);
      var newDir = anotherVec.cross(currVec);
      if (!_coDirVectors(newDir, currDir)) {
        return;
      }
      var idx = 0;
      while (idx < bondsOrder.length && bondsOrder[idx].val < val) {
        ++idx;
      }
      bondsOrder.splice(idx, 0, {
        bond: newBond,
        val: val,
        dir: newDir
      });
    });
    for (var i = 0, n = bondsOrder.length; i < n; ++i) {
      var bond = bondsOrder[i].bond;
      var newRight = bond._left === currRight ? bond._right : bond._left;
      if (newRight === startAtomRef) {
        ++this._currIdx;
        this._cycles.push([currRight]);
        bondMarks[prevBond._index] = false;
        return true;
      }
      if (this._tryBond(bond, newRight, bondsOrder[i].dir)) {
        _insertAscending(bondsData[bond._index], this._currIdx);
        this._cycles[this._currIdx].push(currRight);
        bondMarks[prevBond._index] = false;
        return true;
      }
    }
    bondMarks[prevBond._index] = false;
    return false;
  };
  AromaticLoopsMarker.prototype._startCycle = function (bond) {
    // start from left to right
    this._currStart = bond._left;
    if (this._tryBond(bond, bond._right, new THREE.Vector3())) {
      _insertAscending(this._bondsData[bond._index], this._currIdx);
      this._cycles[this._currIdx].push(bond._left);
    }
  };
  AromaticLoopsMarker.prototype.markCycles = function () {
    var complex = this._complex;
    var self = this;
    var cycles = this._cycles;
    complex.forEachComponent(function (component) {
      component.forEachBond(function (bond) {
        if (bond._type === cAromaticType) {
          self._startCycle(bond);
        }
      });
      for (var i = 0, n = cycles.length; i < n; ++i) {
        var cycle = cycles[i];
        if (cycle.length < 3) {
          continue;
        }
        component.addCycle(new Cycle(cycle));
      }
      cycles = [];
    });
  };
  return AromaticLoopsMarker;
}(three, chem_Bond);
chem_Complex = function (THREE, Chain, AtomType, Component, ResidueType, Bond, AutoBond, SGroup, AromaticMarker) {
  //////////////////////////////////////////////////////////////////////////////
  /**
   * The entire complex of the molecules under study.
   *
   * @exports Complex
   * @constructor
   */
  function Complex() {
    this._chains = [];
    this._components = [];
    this._helices = [];
    this._sheets = [];
    this._residueTypes = Object.create(ResidueType.StandardTypes);
    this._atoms = [];
    // TODO: preallocate
    this._residues = [];
    // TODO: preallocate
    this._bonds = [];
    // TODO: preallocate
    this._sgroups = [];
    this._aSelOutOfDate = false;
    this._rSelOutOfDate = false;
    this.metadata = {};
    this.boundingBox = new THREE.Box3();
    this.boundingSphere = new THREE.Sphere();
  }
  Complex.prototype.name = '';
  Complex.prototype.addAtom = function (atom) {
    var index = this._atoms.length;
    this._atoms.push(atom);
    return index;
  };
  Complex.prototype.addSheet = function (sheet) {
    var index = this._sheets.length;
    this._sheets.push(sheet);
    return index;
  };
  Complex.prototype.addHelix = function (helix) {
    var index = this._helices.length;
    this._helices.push(helix);
    return index;
  };
  Complex.prototype.getAtoms = function () {
    return this._atoms;
  };
  Complex.prototype.getBonds = function () {
    return this._bonds;
  };
  Complex.prototype.getAtomCount = function () {
    return this._atoms.length;
  };
  Complex.prototype.addResidue = function (residue) {
    var index = this._residues.length;
    this._residues.push(residue);
    return index;
  };
  Complex.prototype.addResidueType = function (resName) {
    var rt = this._residueTypes[resName] = new ResidueType(resName, 'Unknown', 0);
    return rt;
  };
  Complex.prototype.getResidueCount = function () {
    return this._residues.length;
  };
  Complex.prototype.getResidues = function () {
    return this._residues;
  };
  Complex.prototype.getSGroupCount = function () {
    return this._sgroups.length;
  };
  Complex.prototype.getSGroups = function () {
    return this._sgroups;
  };
  /**
   * Create a new chain.
   *
   * @param {string} name - Chain name.
   * @returns {Chain} - Newly created chain.
   */
  Complex.prototype.addChain = function (name) {
    var result = new Chain(this, name);
    this._chains.push(result);
    // TODO: keep chains in dictionary with an (ordered?) array of keys
    return result;
  };
  Complex.prototype.getChain = function (name) {
    for (var i = 0, n = this._chains.length; i < n; ++i) {
      var chain = this._chains[i];
      if (chain.getName() === name) {
        return chain;
      }
    }
    return null;
  };
  Complex.prototype.getChainCount = function () {
    return this._chains.length;
  };
  Complex.prototype.forEachAtom = function (process) {
    var atoms = this._atoms;
    for (var i = 0, n = atoms.length; i < n; ++i) {
      process(atoms[i]);
    }
  };
  Complex.prototype.forEachBond = function (process) {
    var bonds = this._bonds;
    for (var i = 0, n = bonds.length; i < n; ++i) {
      process(bonds[i]);
    }
  };
  Complex.prototype.forEachResidue = function (process) {
    var residues = this._residues;
    for (var i = 0, n = residues.length; i < n; ++i) {
      process(residues[i]);
    }
  };
  Complex.prototype.forEachChain = function (process) {
    var chains = this._chains;
    for (var i = 0, n = chains.length; i < n; ++i) {
      process(chains[i]);
    }
  };
  Complex.prototype.forEachSGroup = function (process) {
    var groups = this._sgroups;
    for (var i = 0, n = groups.length; i < n; ++i) {
      process(groups[i]);
    }
  };
  Complex.prototype.forEachComponent = function (process) {
    var components = this._components;
    for (var i = 0, n = components.length; i < n; ++i) {
      process(components[i]);
    }
  };
  Complex.prototype.forEachVisibleChain = function (process) {
    var chains = this._chains;
    for (var i = 0, n = chains.length; i < n; ++i) {
      if (chains[i]._visible) {
        process(chains[i]);
      }
    }
  };
  Complex.prototype.forEachVisibleComponent = function (process) {
    var components = this._components;
    for (var i = 0, n = components.length; i < n; ++i) {
      if (components[i]._visible) {
        process(components[i]);
      }
    }
  };
  Complex.prototype.addBond = function (left, right, order, type, fixed) {
    var bond = new Bond(left, right, order, type, fixed);
    this._bonds.push(bond);
    return bond;
  };
  Complex.prototype.getBondCount = function () {
    return this._bonds.length;
  };
  Complex.prototype.getResidueType = function (name) {
    return this._residueTypes[name] || null;
  };
  Complex.prototype._atomNameCompare = function (a, b, hVal) {
    var hydrogenName = AtomType.PeriodicTable.H.name;
    var carbideName = AtomType.PeriodicTable.C.name;
    function snc(str) {
      if (str === carbideName) {
        return String.fromCharCode(1);
      }
      if (str === hydrogenName) {
        return String.fromCharCode(hVal);
      }
      return str;
    }
    var ca = snc(a);
    var cb = snc(b);
    if (ca < cb) {
      return -1;
    }
    if (ca > cb) {
      return 1;
    }
    return 0;
  };
  Complex.prototype._atomNameCompareCWithH = function (a, b) {
    return this._atomNameCompare(a, b, 2);
  };
  Complex.prototype._atomNameCompareCWithoutH = function (a, b) {
    return this._atomNameCompare(a, b, 254);
  };
  Complex.prototype._buildFormulaSimple = function (part, charge) {
    var atoms = part.atoms;
    var at = null;
    var hash = {};
    var out = '';
    var self = this;
    var hydrogenName = AtomType.PeriodicTable.H.name;
    var actualCharge = 0;
    atoms.forEach(function (a) {
      var hc = a.getHydrogenCount();
      at = a.getType();
      if (hash[at.name]) {
        hash[at.name] += 1;
      } else {
        hash[at.name] = 1;
      }
      if (hc > 0) {
        if (hash[hydrogenName]) {
          hash[hydrogenName] += hc;
        } else {
          hash[hydrogenName] = hc;
        }
      }
      actualCharge += a.getCharge();
    });
    var k = Object.keys(hash);
    if (hash.C) {
      k.sort(this._atomNameCompareCWithH.bind(this));
    } else {
      k.sort(function (a, b) {
        return self._atomNameCompare(a, b, 'H'.charCodeAt(0));
      });
    }
    k.forEach(function (e) {
      var cname = e.substr(0, 1).toUpperCase() + e.substr(1).toLowerCase();
      if (hash[e] > 1) {
        out += cname + hash[e].toString();
      } else {
        out += cname;
      }
    });
    if (charge === null) {
      //apply ourselves
      if (actualCharge !== 0) {
        if (k.length > 1) {
          out = '(' + out + ')';
        }
        if (actualCharge > 1) {
          out += '^{' + actualCharge.toString() + '+}';
        }
        if (actualCharge === 1) {
          out += '^+';
        }
        if (actualCharge < -1) {
          out += '^{' + Math.abs(actualCharge).toString() + '-}';
        }
        if (actualCharge === -1) {
          out += '^-';
        }
      }
      if (part.repeatCount > 1) {
        out = part.repeatCount.toString(10) + out;
      }
    } else {
      charge(k.length, actualCharge);
    }
    return out;
  };
  Complex.prototype._buildPartFormula = function (part) {
    if (part.owner instanceof Complex || part.owner instanceof Component) {
      return this._buildFormulaSimple(part, null);
    } else if (part.owner instanceof SGroup) {
      return part.owner.buildChemicalFormula(this, part);
    } else {
      return '';
    }
  };
  Complex.prototype._partCompareFunc = function (a, b) {
    return this._partCompareFuncInt(a, b, true);
  };
  Complex.prototype._getCumulativeCharge = function (arr) {
    var n = arr.length;
    var i = 0;
    var cumCharge = 0;
    for (i = 0; i < n; i++) {
      cumCharge += arr[i].getCharge();
    }
    return cumCharge;
  };
  Complex.prototype._partCompareFuncInt = function (a, b, skipH) {
    var self = this;
    var i = 0;
    var hydroName = AtomType.PeriodicTable.H.name;
    function buildAtomArray(atms, skipHydro) {
      var r = {};
      atms.forEach(function (singleAtom) {
        var hCount = 0;
        if (r[singleAtom.getType().name]) {
          r[singleAtom.getType().name] += 1;
        } else {
          r[singleAtom.getType().name] = 1;
        }
        if (!skipHydro) {
          hCount = singleAtom.getHydrogenCount();
          if (hCount > 0) {
            if (r[hydroName]) {
              r[hydroName] += hCount;
            } else {
              r[hydroName] = hCount;
            }
          }
        }
      });
      var k = Object.keys(r);
      k.sort(self._atomNameCompareCWithoutH.bind(self));
      return {
        seq: k,
        data: r
      };
    }
    var skipArr = [
      skipH,
      false
    ];
    var skipPar = true;
    var aData = null;
    var bData = null;
    var aIdx = 0, bIdx = 0;
    var atomDiff = 0;
    for (i = 0; i < skipArr.length; i++) {
      skipPar = skipArr[i];
      aData = buildAtomArray(a.atoms, skipPar);
      bData = buildAtomArray(b.atoms, skipPar);
      for (aIdx = 0, bIdx = 0; aIdx < aData.seq.length && bIdx < bData.seq.length;) {
        if (aData.seq[aIdx] === bData.seq[bIdx]) {
          if (aData.data[aData.seq[aIdx]] === bData.data[bData.seq[bIdx]]) {
            aIdx += 1;
            bIdx += 1;
          } else {
            atomDiff = bData.data[bData.seq[bIdx]] - aData.data[aData.seq[aIdx]];
            return atomDiff;
          }
        } else {
          return self._atomNameCompareCWithoutH(aData.seq[aIdx], bData.seq[bIdx]);
        }
      }
      atomDiff = aData.seq.length - bData.seq.length;
      if (atomDiff !== 0 || !skipPar) {
        if (atomDiff === 0) {
          return this._getCumulativeCharge(a.atoms) - this._getCumulativeCharge(b.atoms);
        } else {
          return atomDiff;
        }
      }
    }
    if (atomDiff === 0) {
      return this._getCumulativeCharge(a.atoms) - this._getCumulativeCharge(b.atoms);
    }
    return atomDiff;
  };
  Complex.prototype._checkFormulaBuildable = function () {
    var atom = null;
    var atoms = this.getAtoms();
    var nAtoms = atoms.length;
    var i = 0;
    for (; i < nAtoms; i++) {
      atom = atoms[i];
      if (atom.getType().number > AtomType.PeriodicTable.MT.number) {
        return '}\\text{Could not create chemical formula for this structure.}{';
      }
    }
    return '';
  };
  Complex.prototype.buildChemicalFormula = function () {
    var retDelim = '*';
    var formulaParts = [];
    //object array
    var currPart = null;
    var pAtoms = null;
    var atomsHash = {};
    var hEntry = null;
    var self = this;
    var formula = this._checkFormulaBuildable();
    if (formula !== '') {
      return formula;
    }
    this.forEachAtom(function (a) {
      if (atomsHash[a.getSerial()]) {
        console.error('Broken complex. Formula can be invalid...');
      }
      atomsHash[a.getSerial()] = {
        atom: a,
        taken: null
      };
    });
    //groups part goes first
    this.forEachSGroup(function (grp) {
      if (grp._charge === 0 && grp._repeat === 1) {
        //if do not we have valid reason to take part ==> skip
        return;
      }
      currPart = {
        owner: grp,
        atoms: [],
        repeatCount: 1
      };
      pAtoms = currPart.atoms;
      grp._atoms.forEach(function (a) {
        hEntry = atomsHash[a.getSerial()];
        //check is not taken
        if (hEntry.taken === null) {
          pAtoms.push(a);
          //mark as taken
          hEntry.taken = grp;
        }
      });
      if (currPart.atoms.length > 0) {
        formulaParts.push(currPart);
      }
      currPart = null;
    });
    //components part
    this.forEachComponent(function (cmp) {
      currPart = {
        owner: cmp,
        atoms: [],
        repeatCount: 1
      };
      pAtoms = currPart.atoms;
      cmp.forEachResidue(function (r) {
        r._atoms.forEach(function (a) {
          hEntry = atomsHash[a.getSerial()];
          //check is not taken
          if (hEntry.taken === null) {
            pAtoms.push(a);
            //mark as taken
            hEntry.taken = cmp;
          }
        });
      });
      if (currPart.atoms.length > 0) {
        formulaParts.push(currPart);
      }
      currPart = null;
    });
    //collect main part
    var atomKeys = Object.keys(atomsHash);
    atomKeys.forEach(function (a) {
      if (a.taken === null) {
        if (currPart === null) {
          currPart = {
            owner: self,
            atoms: [],
            repeatCount: 1
          };
        }
        currPart.atoms.push(a.atom);
        a.taken = self;
      }
    });
    //add first part
    if (currPart !== null) {
      if (currPart.atoms.length > 0) {
        formulaParts.push(currPart);
      }
    }
    //sort parts
    formulaParts.sort(function (a, b) {
      return self._partCompareFunc(a, b);
    });
    //now join the same parts
    var i = formulaParts.length - 1;
    var j = formulaParts.length - 2;
    var pi = null, pj = null;
    for (; i >= 0 && j >= 0;) {
      pi = formulaParts[i];
      pj = formulaParts[j];
      if (!(pi.owner instanceof Complex || pi.owner instanceof Component)) {
        i--;
        if (i === j) {
          j--;
        }
        continue;
      }
      if (!(pj.owner instanceof Complex || pj.owner instanceof Component)) {
        j--;
        continue;
      }
      if (this._partCompareFuncInt(pj, pi, false) === 0) {
        pj.repeatCount += pi.repeatCount;
        formulaParts.splice(i, 1);
      }
      j--;
      i--;
    }
    //build formula for each part individually
    formulaParts.forEach(function (p) {
      var pf = self._buildPartFormula(p);
      if (pf.length > 0) {
        if (formula.length > 0) {
          formula += retDelim;
        }
        formula += pf;
      }
    });
    return formula;
  };
  Complex.prototype.getUnifiedSerial = function (chain, serial, iCode) {
    /* eslint-disable no-magic-numbers */
    var maxSerial = 65536;
    var chainShift = maxSerial * 256;
    /* eslint-enable no-magic-numbers */
    return serial + iCode * maxSerial + chain * chainShift;
  };
  Complex.prototype.splitUnifiedSerial = function (uniSerial) {
    /* eslint-disable no-magic-numbers */
    var maxSerial = 65536;
    var chainShift = maxSerial * 256;
    /* eslint-enable no-magic-numbers */
    var chainId = Math.floor(uniSerial / chainShift);
    var remnant = uniSerial - chainId * chainShift;
    var insCode = Math.floor(remnant / maxSerial);
    var ser = remnant - insCode * maxSerial;
    return {
      chain: chainId,
      serial: ser,
      iCode: insCode
    };
  };
  Complex.prototype.fillComponents = function () {
    var self = this;
    var components = this._components;
    this.forEachChain(function (chain) {
      var residues = chain._residues;
      var resCount = residues.length;
      for (var firstResIdx = 0; firstResIdx < resCount;) {
        var res = residues[firstResIdx];
        if (res._component !== null) {
          ++firstResIdx;
          continue;
        }
        var comp = new Component(self);
        comp._index = components.length;
        var compRes = comp._residues;
        comp._visible = chain._visible;
        components.push(comp);
        res._component = comp;
        compRes.push(res);
        var prevRes = res;
        var secondIdx = firstResIdx + 1;
        for (; secondIdx < resCount; ++secondIdx) {
          var res2 = residues[secondIdx];
          if (!prevRes.isConnected(res2)) {
            break;
          }
          res2._component = comp;
          compRes.push(res2);
          prevRes = res2;
        }
        firstResIdx = secondIdx;
      }
    });
  };
  Complex.prototype._computeBounds = function () {
    var atoms = this._atoms;
    var n = atoms.length;
    var i = 0;
    // Build bounding box // TODO: Is non-Three.js way much faster?
    var boundingBox = this.boundingBox;
    boundingBox.makeEmpty();
    if (n === 1) {
      boundingBox.expandByPoint(atoms[0]._position);
      var bbc = boundingBox.center();
      var s = 2 * atoms[0].getType().radius;
      //*settings.now.modes.BS.atom; FIXME N: hack commented
      boundingBox.setFromCenterAndSize(bbc, new THREE.Vector3(s, s, s));
    } else {
      for (i = 0; i < n; ++i) {
        boundingBox.expandByPoint(atoms[i]._position);
      }
    }
    // Build bounding sphere
    var radiusSquared = 0;
    var center = boundingBox.isEmpty() ? new THREE.Vector3() : boundingBox.center();
    if (n === 1) {
      // * settings.now.modes.BS.atom); FIXME N: hack commented
      this.boundingSphere.set(center, atoms[0].getType().radius);
    } else {
      for (i = 0; i < n; ++i) {
        var pos = atoms[i]._position;
        var lengthSquared = center.distanceToSquared(pos);
        if (radiusSquared < lengthSquared) {
          radiusSquared = lengthSquared;
        }
      }
      this.boundingSphere.set(center, Math.sqrt(radiusSquared));
    }
  };
  Complex.prototype.onAtomPositionChanged = function () {
    this.forEachChain(function (a) {
      a._finalize();
    });
    this.forEachComponent(function (c) {
      c.update();
    });
    // Update bounding sphere and box
    this._computeBounds();
    this._finalizeBonds();
    this.forEachSGroup(function (s) {
      s._rebuildSGroupOnAtomChange();
    });
  };
  Complex.prototype._finalizeBonds = function () {
    var bonds = this.getBonds();
    var n = bonds.length;
    for (var i = 0; i < n; ++i) {
      bonds[i]._index = i;
    }
  };
  Complex.prototype.finalize = function (serialAtomMap, needAutoBonding) {
    // Put bonds into atoms
    var bonds = this._bonds;
    var i = 0;
    var n = 0;
    var bond = null;
    //remove invalid bonds
    for (i = bonds.length - 1; i >= 0; i--) {
      bond = bonds[i];
      if (bond._left === null || bond._right === null) {
        bonds.splice(i, 1);
      } else {
        bond._left._bonds.push(bond);
        bond._right._bonds.push(bond);
      }
    }
    var residues = this._residues;
    for (i = 0, n = residues.length; i < n; ++i) {
      residues[i]._finalize();
    }
    this.forEachChain(function (a) {
      a._finalize();
    });
    var helices = this._helices;
    var res = null;
    var residueHash = {};
    for (i = 0, n = residues.length; i < n; ++i) {
      res = residues[i];
      residueHash[this.getUnifiedSerial(res.getChain().getName().charCodeAt(0), res.getSequence(), res.getICode().charCodeAt(0))] = res;
    }
    for (i = 0, n = helices.length; i < n; ++i) {
      helices[i]._finalize(residueHash, this);
    }
    var sheets = this._sheets;
    for (i = 0, n = sheets.length; i < n; ++i) {
      sheets[i]._finalize(serialAtomMap, residueHash, this);
    }
    // Update bounding sphere and box
    this._computeBounds();
    var atoms = this._atoms;
    for (i = 0, n = atoms.length; i < n; ++i) {
      var currAtom = atoms[i];
      currAtom._index = i;
    }
    if (needAutoBonding) {
      var autoConnector = new AutoBond(this);
      autoConnector.build();
      autoConnector.destroy();
      autoConnector = null;  
    }
    residueHash = null;
    var chains = this._chains;
    for (i = 0, n = chains.length; i < n; ++i) {
      chains[i]._index = i;
    }
    for (i = 0, n = residues.length; i < n; ++i) {
      residues[i]._index = i;
    }
    this._finalizeBonds();
    /*
        if (DEBUG) {
          if (this._chains && this._chains.length > 0) {
            var chain = this._chains[0];
            console.log('DEBUG: The first chain is "' + chain.getName() + '"');
          }
          if (this._residues && this._residues.length > 0) {
            var residue = this._residues[0];
            console.log('DEBUG: The first residue is "' + residue.getType().getName() + '"');
          }
          if (this._atoms && this._atoms.length > 0) {
            var atom = this._atoms[0];
            console.log('DEBUG: The first atom is "' + atom.getName().getString() + '"');
          }
          if (helices && helices.length > 0) {
            var helix = helices[0];
            console.log('DEBUG: The first helix is "' + helix.getName() + '"');
          }
          if (sheets && sheets.length > 0) {
            var sheet = sheets[0];
            console.log('DEBUG: The first sheet is "' + sheet.getName() + '"');
          }
        }
    */
    this._aSelOutOfDate = false;
    this._rSelOutOfDate = false;
    this.fillComponents();
    var marker = new AromaticMarker(this);
    marker.markCycles();
  };
  Complex.prototype._propagateMaskRA = function () {
    this.forEachResidue(function (residue) {
      var mask = residue._mask;
      residue.forEachAtom(function (atom) {
        atom._mask |= mask;
      });
    });
  };
  Complex.prototype._propagateMaskAR = function () {
    this.forEachResidue(function (residue) {
      var mask = -1 | 0;
      residue.forEachAtom(function (atom) {
        mask &= atom._mask;
      });
      residue._mask = mask;
    });
  };
  Complex.prototype.propagateAtoms = function () {
  };
  Complex.prototype.propagateResidues = function () {
    if (this._rSelOutOfDate) {
      return;
    }
    this._propagateMaskAR();
    this._rSelOutOfDate = false;
  };
  Complex.prototype.updateResidueMask = function () {
    this.forEachResidue(function (residue) {
      residue.collectMask();
    });
  };
  Complex.prototype.updateChainMask = function () {
    this.forEachChain(function (chain) {
      chain.collectMask();
    });
  };
  Complex.prototype.getNumAtomsBySelector = function (selector) {
    var count = 0;
    this.forEachAtom(function (atom) {
      if (selector.includesAtom(atom)) {
        count++;
      }
    });
    return count;
  };
  Complex.prototype.resetAtomMask = function (mask) {
    this.forEachAtom(function (atom) {
      atom._mask = mask;
    });
  };
  Complex.prototype.markAtoms = function (selector, mask) {
    var setMask = mask;
    var clearMask = ~setMask;
    var count = 0;
    this.forEachAtom(function (atom) {
      if (selector.includesAtom(atom)) {
        atom._mask |= setMask;
        count++;
      } else {
        atom._mask &= clearMask;
      }
    });
    return count;
  };
  Complex.prototype.clearAtomBits = function (mask) {
    var clearMask = ~mask;
    this.forEachAtom(function (atom) {
      atom._mask &= clearMask;
    });
  };
  Complex.prototype.getAtomNames = function () {
    if (this.hasOwnProperty('_atomNames')) {
      return this._atomNames;
    }
    var dict = {};
    this.forEachAtom(function (atom) {
      dict[atom._name._name] = 1;
    });
    this._atomNames = Object.keys(dict);
    return this._atomNames;
  };
  Complex.prototype.getAtomTypes = function () {
    if (this.hasOwnProperty('_atomTypes')) {
      return this._atomTypes;
    }
    var dict = {};
    this.forEachAtom(function (atom) {
      dict[atom._type.name] = 1;
    });
    this._atomTypes = Object.keys(dict);
    return this._atomTypes;
  };
  Complex.prototype.getResidueNames = function () {
    if (this.hasOwnProperty('_residueNames')) {
      return this._residueNames;
    }
    var dict = {};
    this.forEachResidue(function (res) {
      dict[res._type._name] = 1;
    });
    this._residueNames = Object.keys(dict);
    return this._residueNames;
  };
  Complex.prototype.getChainNames = function () {
    if (this.hasOwnProperty('_chainNames')) {
      return this._chainNames;
    }
    var dict = {};
    this.forEachChain(function (chain) {
      dict[chain._name] = 1;
    });
    this._chainNames = Object.keys(dict);
    return this._chainNames;
  };
  // this function joins multiple complexes into one (this)
  // atom, bond, ... objects are reused -- so input complexes are no longer valid
  Complex.prototype.joinComplexes = function (complexes) {
    var i, j;
    // clear target complex
    this._chains = [];
    this._components = [];
    this._helices = [];
    this._sheets = [];
    this._atoms = [];
    this._residues = [];
    this._bonds = [];
    this._sgroups = [];
    var atomBias = 0;
    var bondBias = 0;
    var residueBias = 0;
    var chainBias = 0;
    var componentBias = 0;
    for (i = 0; i < complexes.length; ++i) {
      var c = complexes[i];
      // add atoms
      for (j = 0; j < c._atoms.length; ++j) {
        var a = c._atoms[j];
        a._serial += atomBias;
        a._index += atomBias;
        this._atoms.push(a);
      }
      // add bonds
      for (j = 0; j < c._bonds.length; ++j) {
        var b = c._bonds[j];
        b._index += bondBias;
        this._bonds.push(b);
      }
      // add residues
      for (j = 0; j < c._residues.length; ++j) {
        var r = c._residues[j];
        r._index += residueBias;
        this._residues.push(r);
      }
      // add chains
      for (j = 0; j < c._chains.length; ++j) {
        var chain = c._chains[j];
        chain._complex = this;
        chain._index += chainBias;
        this._chains.push(chain);
      }
      // add sheets
      for (j = 0; j < c._sheets.length; ++j) {
        this._sheets.push(c._sheets[j]);
      }
      // add helices
      for (j = 0; j < c._helices.length; ++j) {
        this._helices.push(c._helices[j]);
      }
      // add SGroups
      for (j = 0; j < c._sgroups.length; ++j) {
        this._sgroups.push(c._sgroups[j]);
      }
      // add components
      for (j = 0; j < c._components.length; ++j) {
        var comp = c._components[j];
        comp._complex = this;
        comp._index += componentBias;
        this._components.push(comp);
      }
      // merge residue types
      for (var rt in c._residueTypes) {
        if (c._residueTypes.hasOwnProperty(rt)) {
          this._residueTypes[rt] = c._residueTypes[rt];
        }
      }
      atomBias += c._atoms.length;
      bondBias += c._bonds.length;
      residueBias += c._residues.length;
      chainBias += c._chains.length;
      componentBias += c._components.length;
    }
    this._computeBounds();
  };
  return Complex;
}(three, chem_Chain, chem_AtomType, chem_Component, chem_ResidueType, chem_Bond, chem_AutoBond, chem_SGroup, chem_AromaticMarker);
Profiler = function (utils) {
  function Profiler() {
    // bind method to get current time
    this.now = utils.Timer.now;
    this._startTime = 0;
    this._times = [];
  }
  Profiler.prototype.start = function () {
    this._startTime = this.now();
  };
  Profiler.prototype.end = function () {
    if (this._startTime !== 0) {
      this._times.push(this.now() - this._startTime);
    }
  };
  Profiler.prototype.rawMean = function () {
    var n = this._times.length;
    var mean = 0;
    for (var i = 0; i < n; ++i) {
      mean += this._times[i];
    }
    return mean / n;
  };
  Profiler.prototype.mean = function () {
    return this._robustMean(this._times);
  };
  Profiler.prototype.deviation = function (mean) {
    return this._robustDeviation(this._times, mean);
  };
  Profiler.prototype.min = function () {
    return this._robustMin(this._times);
  };
  Profiler.prototype._robustMean = function (values) {
    var first = Math.round(values.length * 0.1);
    var n = values.length - Math.round(values.length * 0.2);
    values.sort(function (a, b) {
      return a - b;
    });
    var mean = 0;
    for (var i = first; i < n; ++i) {
      mean += values[i];
    }
    return mean / n;
  };
  Profiler.prototype._robustDeviation = function (values, mean) {
    var n = values.length;
    var deltas = new Array(n);
    for (var i = 0; i < n; ++i) {
      deltas[i] = (values[i] - mean) * (values[i] - mean);
    }
    deltas.sort(function (a, b) {
      return a - b;
    });
    return Math.sqrt(this._robustMean(deltas));
  };
  Profiler.prototype._robustMin = function (values) {
    var first = Math.round(values.length * 0.05);
    var n = Math.round(values.length * 0.1);
    values.sort(function (a, b) {
      return a - b;
    });
    var mean = 0;
    for (var i = 0; i < n; ++i) {
      mean += values[first + i];
    }
    return mean / n;
  };
  return Profiler;
}(utils);
gfx_GfxProfiler = function ($, THREE, Profiler) {
  function GfxProfiler(renderer) {
    this._renderer = renderer;
    this._prepareTest();
  }
  GfxProfiler.prototype._prepareTest = function () {
    this._scene = new THREE.Scene();
    var geo = new THREE.PlaneGeometry(10, 10, 128, 128);
    var mat = new THREE.MeshBasicMaterial({ color: this._renderer.getClearColor() });
    for (var j = 0; j < 300; ++j) {
      var plane = new THREE.Mesh(geo, mat);
      this._scene.add(plane);
    }
    this._camera = new THREE.PerspectiveCamera(45, 1, 1, 2000);
    this._camera.position.z = 30;
    this._prof = new Profiler();
  };
  GfxProfiler.prototype.run = function () {
    for (var i = 0; i < 100; ++i) {
      this._prof.start();
      this._renderer.render(this._scene, this._camera, this._target);
      this._prof.end();
    }
  };
  GfxProfiler.prototype.runOnTicks = function (maxResults, skipMs, timeLimitMs) {
    var self = this;
    if (typeof maxResults === 'undefined') {
      maxResults = 50;
    }
    if (typeof skipMs === 'undefined') {
      skipMs = 1000;
    }
    if (typeof timeLimitMs === 'undefined') {
      timeLimitMs = 10000;
    }
    var count = -1;
    var startTime = this._prof.now();
    var dfd = new $.Deferred();
    setTimeout(function () {
      function onTick() {
        self._renderer.render(self._scene, self._camera);
        var elapsedMs = self._prof.now() - startTime;
        // we're skipping some frames to get more stable FPS
        if (elapsedMs > skipMs) {
          self._prof.end();
          self._prof.start();
          ++count;
        }
        if (elapsedMs > timeLimitMs || count === maxResults) {
          dfd.resolve(Math.max(count, 0));
        } else {
          requestAnimationFrame(onTick);
        }
      }
      requestAnimationFrame(onTick);
    });
    return dfd.promise();
  };
  GfxProfiler.prototype.mean = function () {
    return this._prof ? this._prof.rawMean() : 0;
  };
  GfxProfiler.prototype.min = function () {
    return this._prof ? this._prof.min() : 0;
  };
  return GfxProfiler;
}(jquery, three, Profiler);
io_Loader = function () {
  //////////////////////////////////////////////////////////////////////////////
  var loaders = {};
  function Loader(source, options) {
    // Select a Loader automatically
    if (this.constructor === Loader) {
      var keys = Object.keys(loaders);
      for (var i = 0, n = keys.length; i < n; ++i) {
        var SomeLoader = loaders[keys[i]];
        if (SomeLoader.canLoad && SomeLoader.canLoad(source, options)) {
          return new SomeLoader(source, options);
        }
      }
      throw new Error('Could not select a suitable Loader');  // FIXME: proper error handling
    }
    this._source = source;
    this._options = options;
    this._agent = null;
  }
  Loader.prototype.abort = function () {
    this._agent.abort();
  };
  ////////////////////////////////////////////////////////////////////////////
  Loader.addCommonHandlers = function (obj, callback) {
    if (callback.error) {
      obj.addEventListener('error', function _onError(event) {
        callback.error(event.type);
      });
      obj.addEventListener('abort', function _onAbort(event) {
        callback.error(event.type);
      });
    }
    if (callback.progress) {
      obj.addEventListener('progress', function _onProgress(event) {
        if (event.lengthComputable) {
          callback.progress(event.loaded / event.total);
        } else {
          callback.progress();
        }
      });
    }
  };
  Loader.register = function (name, func) {
    loaders[name] = func;
  };
  ////////////////////////////////////////////////////////////////////////////
  return Loader;
}();
io_Parser = function () {
  //////////////////////////////////////////////////////////////////////////////
  var parsers = {};
  function Parser(data, options) {
    // Select a Parser automatically
    if (this.constructor === Parser) {
      var keys = Object.keys(parsers);
      for (var i = 0, n = keys.length; i < n; ++i) {
        var SomeParser = parsers[keys[i]];
        if (SomeParser.canParse && SomeParser.canParse(data, options)) {
          return new SomeParser(data, options);
        }
      }
      console.error('Could not parse the file. Format unknown.');
    }
    this._data = data;
    this._options = options;
  }
  ////////////////////////////////////////////////////////////////////////////
  // Class methods
  Parser.register = function (name, func) {
    parsers[name] = func;
  };
  ////////////////////////////////////////////////////////////////////////////
  // Instance methods
  Parser.prototype.parse = function (callback) {
    var self = this;
    setTimeout(function _parse() {
      try {
        self._parse(callback);
      } catch (err) {
        callback.error(err);
      }
    }, 0);
  };
  Parser.prototype.abort = function () {
    this._abort = true;
  };
  ////////////////////////////////////////////////////////////////////////////
  return Parser;
}();
io_FileLoader = function (Loader) {
  function FileLoader(source, options) {
    if (!options.fileName) {
      options.fileName = source.name;
    }
    Loader.call(this, source, options);
  }
  FileLoader.prototype = Object.create(Loader.prototype);
  FileLoader.prototype.constructor = FileLoader;
  FileLoader.prototype.load = function (callback) {
    var reader = new FileReader();
    this._agent = reader;
    if (callback.ready) {
      reader.addEventListener('load', function _onLoad(event) {
        callback.ready(event.target.result);
      });
    }
    Loader.addCommonHandlers(reader, callback);
    reader.readAsText(this._source);
  };
  FileLoader.canLoad = function (source, options) {
    var type = options.sourceType;
    return source instanceof File && (!type || type === 'file');
  };
  Loader.register('FileLoader', FileLoader);
  return FileLoader;
}(io_Loader);
io_MessageLoader = function (Loader) {
  function MessageLoader(source, options) {
    var idx = 0;
    if (!options.data) {
      idx = source.indexOf(':', 0);
      if (idx > 0) {
        options.data = window.atob(source.substring(idx + 1));
        options.fileType = source.substring(0, idx).toLowerCase();
      }
    }
    Loader.call(this, source, options);
  }
  MessageLoader.prototype = Object.create(Loader.prototype);
  MessageLoader.prototype.constructor = MessageLoader;
  MessageLoader.prototype.load = function (callback) {
    if (callback.progress) {
      callback.progress(0);
    }
    if (!this._options.data || this._options.data === null || this._options.data === '') {
      if (callback.error) {
        callback.error('No data found!');
      }
    }
    if (callback.progress) {
      callback.progress(0.5);
    }
    if (!this._options.dataType || this._options.dataType === null || this._options.dataType === '') {
      if (callback.error) {
        callback.error('No dataType found!');
      }
    }
    if (callback.progress) {
      callback.progress(1);
    }
    if (callback.ready) {
      callback.ready(this._options.data);
    }
  };
  MessageLoader.canLoad = function (source, options) {
    var type = options.sourceType;
    if (typeof source !== 'string') {
      return false;
    }
    var semiIdx = source.indexOf(':', 0);
    return typeof source === 'string' && (semiIdx === 3 || type === 'message');
  };
  Loader.register('MessageLoader', MessageLoader);
  return MessageLoader;
}(io_Loader);
io_XHRLoader = function (Loader) {
  function XHRLoader(source, options) {
    if (!options.fileName) {
      options.fileName = source.slice(source.lastIndexOf('/') + 1);
    }
    Loader.call(this, source, options);
  }
  XHRLoader.prototype = Object.create(Loader.prototype);
  XHRLoader.prototype.constructor = XHRLoader;
  XHRLoader.prototype.load = function (callback) {
    var request = new XMLHttpRequest();
    this._agent = request;
    if (callback.ready) {
      request.addEventListener('load', function _onLoad(event) {
        callback.ready(event.target.response);
      });
    }
    Loader.addCommonHandlers(request, callback);
    request.open('GET', this._source);
    request.overrideMimeType('text/plain; charset=utf-8');
    request.send();
  };
  XHRLoader.canLoad = function (source, options) {
    var type = options.sourceType;
    return typeof source === 'string' && (!type || type === 'url');
  };
  Loader.register('XHRLoader', XHRLoader);
  return XHRLoader;
}(io_Loader);
chem_Helix = function () {
  //////////////////////////////////////////////////////////////////////////////
  /**
   * Helical secondary structure of a protein.
   *
   * @param {number} serial  -
   * @param {string} name    -
   * @param {Residue} start  -
   * @param {Residue} end    -
   * @param {number} type    -
   * @param {string} comment -
   * @param {number} length  -
   *
   * @exports Helix
   * @constructor
   */
  function Helix(serial, name, start, end, type, comment, length) {
    this._serial = serial;
    this._name = name;
    this._start = start;
    this._end = end;
    this._type = type;
    this._comment = comment;
    this._length = length;
    this._residues = [];  // TODO: list or range? is it correct to use ranges?
  }
  Helix.prototype.type = 'helix';
  Helix.prototype.getName = function () {
    return this._name;
  };
  Helix.prototype._finalize = function (residueHash, complex) {
    var chainId = 0;
    var serId = 0;
    var iCodeId = 0;
    var midCode = 0;
    var res = null;
    var start = complex.splitUnifiedSerial(this._start);
    var end = complex.splitUnifiedSerial(this._end);
    for (chainId = start.chain; chainId <= end.chain; chainId++) {
      for (serId = start.serial; serId <= end.serial; serId++) {
        for (iCodeId = start.iCode; iCodeId <= end.iCode; iCodeId++) {
          midCode = complex.getUnifiedSerial(chainId, serId, iCodeId);
          if (typeof residueHash[midCode] !== 'undefined') {
            res = residueHash[midCode];
            res._secondary = this;
            this._residues.push(res);
          }
        }
      }
    }
    //Replace unfined serials by objects
    this._start = residueHash[this._start];
    this._end = residueHash[this._end];
  };
  return Helix;
}();
chem_Strand = function () {
  //////////////////////////////////////////////////////////////////////////////
  /**
   * A single strand of a sheet in a protein secondary structure.
   *
   * @param {Sheet} sheet   -
   * @param {Residue} start -
   * @param {Residue} end   -
   * @param {number} sense  -
   * @param {Atom} cur      -
   * @param {Atom} prev     -
   *
   * @exports Strand
   * @constructor
   */
  function Strand(sheet, start, end, sense, cur, prev) {
    this._sheet = sheet;
    this._start = start;
    this._end = end;
    this._sense = sense;
    this._cur = cur;
    this._prev = prev;
    this._residues = [];
  }
  Strand.prototype.type = 'strand';
  // Getters and setters
  Strand.prototype.getSheet = function () {
    return this._name;
  };
  Strand.prototype.setSheet = function (sheet) {
    this._sheet = sheet;
  };
  Strand.prototype.getStart = function () {
    return this._width;
  };
  Strand.prototype._finalize = function (serialAtomMap, residueHash, complex) {
    var chainId = 0;
    var serId = 0;
    var iCodeId = 0;
    var midCode = 0;
    var res = null;
    var start = complex.splitUnifiedSerial(this._start);
    var end = complex.splitUnifiedSerial(this._end);
    for (chainId = start.chain; chainId <= end.chain; chainId++) {
      for (serId = start.serial; serId <= end.serial; serId++) {
        for (iCodeId = start.iCode; iCodeId <= end.iCode; iCodeId++) {
          midCode = complex.getUnifiedSerial(chainId, serId, iCodeId);
          if (typeof residueHash[midCode] !== 'undefined') {
            res = residueHash[midCode];
            res._secondary = this;
            this._residues.push(res);
          }
        }
      }
    }
    var as = this._cur;
    if (!isNaN(as)) {
      this._cur = serialAtomMap[as];
    }
    as = this._prev;
    if (!isNaN(as)) {
      this._prev = serialAtomMap[as];
    }
    //Replace unfined serials by objects
    this._start = residueHash[this._start];
    this._end = residueHash[this._end];
  };
  return Strand;
}();
chem_Sheet = function (Strand) {
  //////////////////////////////////////////////////////////////////////////////
  /**
   * Sheet secondary structure of a protein.
   *
   * @param {string} name -
   * @param {number} width -
   *
   * @exports Sheet
   * @constructor
   */
  function Sheet(name, width) {
    this._name = name;
    this._width = width;
    this._strands = [];
  }
  // Getters and setters
  Sheet.prototype.getName = function () {
    return this._name;
  };
  Sheet.prototype.getWidth = function () {
    return this._width;
  };
  Sheet.prototype.addStrand = function (strnad) {
    this._strands.push(strnad);
  };
  Sheet.prototype.addEmptyStrand = function () {
    this._strands.push(new Strand(null, null, null, null, null, null));
  };
  Sheet.prototype._finalize = function (serialAtomMap, residueHash, complex) {
    var s = this._strands;
    for (var i = 0, n = s.length; i < n; ++i) {
      s[i]._finalize(serialAtomMap, residueHash, complex);
    }
    if (s.length !== this._width) {
      console.log('Sheet ' + this._name + ' is inconsistent.');
    }
  };
  return Sheet;
}(chem_Strand);
io_PDBParser = function (Parser, Complex, AtomType, Helix, Sheet, Strand, Bond, THREE, settings, utils) {
  var TAG_LENGTH = 6;
  var CRLF = '\n';
  var CRLF_LENGTH = CRLF.length;
  // FIXME: It is always 1, isn't it?
  function PDBParser(data, options) {
    Parser.call(this, data, options);
    this._complex = null;
    this._chain = null;
    this._residue = null;
    this._sheet = null;
    this._serialAtomMap = null;
    this._modelId = 1;
    this._compaundFound = false;
    this._biomoleculeFound = false;
    this._allowedChainsIDs = null;
    this._lastMolId = -1;
    options.fileType = 'pdb';
  }
  ////////////////////////////////////////////////////////////////////////////
  // Inheritance
  PDBParser.prototype = Object.create(Parser.prototype);
  PDBParser.prototype.constructor = PDBParser;
  ////////////////////////////////////////////////////////////////////////////
  // Class methods
  PDBParser.canParse = function (data, options) {
    var type = options.fileType;
    var name = options.fileName;
    var EXT_LEN = 4;
    return typeof data === 'string' && (!type || type === 'pdb') && (!name || name.toLowerCase().lastIndexOf('.pdb') === name.length - EXT_LEN);
  };
  ////////////////////////////////////////////////////////////////////////////
  // Auxiliary class
  function PDBStream(data) {
    this._data = data;
    this._start = 0;
    this._next = 0;
    this._end = data.length;
    this.next();
  }
  PDBStream.prototype = {
    constructor: PDBStream,
    end: function () {
      return this._start >= this._end;
    },
    next: function () {
      this._start = this._next;
      var next = this._data.indexOf(CRLF, this._start);
      this._next = next > 0 ? next + CRLF_LENGTH : this._end;
    },
    readString: function (begin, end) {
      return this._data.slice(this._start + begin - 1, Math.min(this._start + end, this._next));
    },
    readChar: function (pos) {
      pos = this._start + pos - 1;
      return pos < this._next ? this._data[pos] : ' ';
    },
    readCharCode: function (pos) {
      pos = this._start + pos - 1;
      return pos < this._next ? this._data.charCodeAt(pos) : 32;
    },
    readInt: function (begin, end) {
      return parseInt(this._data.slice(this._start + begin - 1, Math.min(this._start + end, this._next)), 10);
    },
    readFloat: function (begin, end) {
      return parseFloat(this._data.slice(this._start + begin - 1, Math.min(this._start + end, this._next)));
    }
  };
  ////////////////////////////////////////////////////////////////////////////
  // Instance methods
  PDBParser.prototype._finalize = function () {
    if (!settings.now.singleUnit) {
      this._allowedChainsIDs = null;
    }
    this._fixBondsArray();
    this._fixChains();
    // create secondary structure etc.
    this._complex.finalize(this._serialAtomMap, true);  /* NOTE: Slow. Only for badly formatted files.
                                                        var atoms = null;
                                                        var i = 0;
                                                        if (settings.now.singleUnit) {
                                                          atoms = this._complex._atoms;
                                                          for (i = atoms.length - 1; i >= 0; i--) {
                                                            if (!atoms[i].getResidue().getChain().isVisible()) {
                                                              //delete this atom
                                                              atoms.splice(i, 1);
                                                            }
                                                          }
                                                        }
                                                        */
  };
  PDBParser.prototype._fixChains = function () {
    var idChainMap = {};
    var complex = this._complex;
    var i = 0;
    var chain = null;
    var id = 0;
    if (this._allowedChainsIDs === null) {
      //All chains are allowed in this case
      for (i = 0; i < complex._chains.length; i++) {
        chain = complex._chains[i];
        chain._visible = true;
      }
      return;
    }
    //prepare
    for (i = 0; i < complex._chains.length; i++) {
      chain = complex._chains[i];
      idChainMap[chain._name.charCodeAt(0)] = chain;
      chain._visible = false;
    }
    //Fix chains visibility
    for (i = 0; i < this._allowedChainsIDs.length; i++) {
      id = this._allowedChainsIDs[i];
      idChainMap[id]._visible = true;
    }
  };
  /* NOTE: Slow and clumsy. And only for badly formatted files.
  PDBParser.prototype._atomNameScan = function(str) {
    var i = 0;
    var code = null;
    var codeA = 'A'.charCodeAt(0);
    var codeZ = 'Z'.charCodeAt(0);
    var s = str.toUpperCase();
    for (i = s.length - 1; i >= 0; i--) { // FIXME: What for?
      code = s.charCodeAt(i);
      if (codeA <= code && code <= codeZ) {
        continue;
      } else {
        s = s.slice(0, i) + s.slice(i + 1, s.length);
      }
    }
    return s;
  };
  */
  // FIXME: This function is redundant, CONECT records always follow ATOM and HETATM. Build the map online.
  PDBParser.prototype._fixBondsArray = function () {
    var serialAtomMap = this._serialAtomMap = {};
    var complex = this._complex;
    var atoms = complex._atoms;
    var i = 0, ni = atoms.length;
    for (; i < ni; ++i) {
      var atom = atoms[i];
      serialAtomMap[atom._serial] = atom;
    }
    var bonds = complex._bonds;
    var j = 0, nj = bonds.length;
    for (; j < nj; ++j) {
      var bond = bonds[j];
      if (bond._right < bond._left) {
        console.log('_fixBondsArray: Logic error.');
      }
      bond._left = serialAtomMap[bond._left] || null;
      bond._right = serialAtomMap[bond._right] || null;
    }
  };
  PDBParser.prototype._parseATOM = function (stream) {
    if (this._modelId !== 1) {
      return;
    }
    /* eslint-disable no-magic-numbers */
    var het = stream.readCharCode(1) === 72;
    // field names according to wwPDB Format
    var serial = stream.readInt(7, 11);
    var name = stream.readString(13, 16);
    var altLoc = stream.readChar(17);
    var resName = stream.readString(18, 20).trim();
    var chainID = stream.readChar(22);
    var resSeq = stream.readInt(23, 26);
    var iCode = stream.readChar(27);
    var x = stream.readFloat(31, 38);
    var y = stream.readFloat(39, 46);
    var z = stream.readFloat(47, 54);
    var occupancy = stream.readFloat(55, 60);
    var tempFactor = stream.readFloat(61, 66);
    var element = stream.readString(77, 78).trim() || name.slice(0, 2).trim();
    var charge = stream.readInt(79, 80) || 0;
    /* eslint-enable no-magic-numbers */
    var isAllowed = false;
    var len = 0;
    var i = 0;
    if (settings.now.singleUnit) {
      if (this._allowedChainsIDs !== null && this._allowedChainsIDs.length > 0) {
        len = this._allowedChainsIDs.length;
        for (i = 0; i < len; i++) {
          if (this._allowedChainsIDs[i] === chainID.charCodeAt(0)) {
            isAllowed = true;
            break;
          }
        }
      } else {
        isAllowed = true;
      }
      if (!isAllowed) {
        return;
      }
    }
    var type = AtomType.PeriodicTable[element];
    if (!type) {
      AtomType.PeriodicTable[element] = new AtomType(AtomType.PeriodicTable.length, element, 'Unknown', 0, 0.01, 0.01, [0]);
      type = AtomType.PeriodicTable[element];
    }
    var role = AtomType.Role[name.trim()];
    // FIXME: Should not trim name, since " CA " and "CA  " are different.
    // NOTE: Residues of a particular chain are not required to be listed next to each other.
    // https://github.com/biasmv/pv/commit/7319b898b7473ba380c26699e3b028b2b1a7e1a1
    var chain = this._chain;
    if (!chain || chain.getName() !== chainID) {
      this._chain = chain = this._complex.getChain(chainID) || this._complex.addChain(chainID);
      this._residue = null;
    }
    var residue = this._residue;
    if (!residue || residue.getSequence() !== resSeq || residue.getICode() !== iCode) {
      this._residue = residue = chain.addResidue(resName, resSeq, iCode);
    }
    // TODO: optimize atom positions storage? what for? (and occupancy? tempFactor?)
    var xyz = new THREE.Vector3(x, y, z);
    residue.addAtom(name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge);
  };
  PDBParser.prototype._parseENDMDL = function () {
    this._modelId += 1;
  };
  PDBParser.prototype._parseCONECT = function (stream) {
    /* eslint-disable no-magic-numbers */
    var serial0 = stream.readInt(7, 11);
    var serial1 = stream.readInt(12, 16);
    var serial2 = stream.readInt(17, 21);
    var serial3 = stream.readInt(22, 26);
    var serial4 = stream.readInt(27, 31);
    /* eslint-enable no-magic-numbers */
    var complex = this._complex;
    // Keep bonds ordered by atom serial
    if (serial1 && serial1 > serial0) {
      complex.addBond(serial0, serial1, 0, Bond.BondType.UNKNOWN, true);
    }
    if (serial2 && serial2 > serial0) {
      complex.addBond(serial0, serial2, 0, Bond.BondType.UNKNOWN, true);
    }
    if (serial3 && serial3 > serial0) {
      complex.addBond(serial0, serial3, 0, Bond.BondType.UNKNOWN, true);
    }
    if (serial4 && serial4 > serial0) {
      complex.addBond(serial0, serial4, 0, Bond.BondType.UNKNOWN, true);
    }
  };
  PDBParser.prototype._parseCOMPND = function (stream) {
    /* eslint-disable no-magic-numbers */
    var compoundStr = stream.readString(8, 10);
    var compoundInt = parseInt(compoundStr, 10);
    var contStr = stream.readString(11, 80);
    var chainStr = contStr.substring(0, 17 - 11 + 1);
    var cDataStr = contStr.substring(17 - 11 + 1, 80);
    /* eslint-enable no-magic-numbers */
    var Ids = null;
    var i = 0;
    var cont = null;
    //Only if biomolecule not yet defined
    if (!this._biomoleculeFound) {
      if (compoundStr.trim() === '') {
        this._allowedChainsIDs = null;
      } else if (compoundInt > 0) {
        cont = chainStr.toUpperCase();
        if (cont === ' CHAIN:' && !this._compaundFound) {
          this._compaundFound = true;
          cont = cDataStr.toUpperCase();
          Ids = cont.split(',');
          this._allowedChainsIDs = utils.allocateTyped(Int32Array, Ids.length);
          for (i = 0; i < Ids.length; i++) {
            this._allowedChainsIDs[i] = Ids[i].trim().charCodeAt(0);
          }
        }
      }
    }
  };
  PDBParser.prototype._parseSOURCE = function (stream) {
    /* eslint-disable no-magic-numbers */
    var sourceStr = stream.readString(8, 10);
    var sourceInt = parseInt(sourceStr, 10);
    var contStr = stream.readString(11, 17);
    /* eslint-enable no-magic-numbers */
    var Ids = null;
    var i = 0;
    var cont = null;
    //only if biomolecule not yet defined
    if (!this._biomoleculeFound && !this._compaundFound) {
      if (sourceStr.trim() === '') {
        this._allowedChainsIDs = null;
      } else if (sourceInt > 0) {
        cont = contStr.toUpperCase();
        if (cont === ' CHAIN:' && !this._sourceFound) {
          this._sourceFound = true;
          Ids = cont.split(',');
          this._allowedChainsIDs = utils.allocateTyped(Int32Array, Ids.length);
          for (i = 0; i < Ids.length; i++) {
            this._allowedChainsIDs[i] = Ids[i].trim().charCodeAt(0);
          }
        }
      }
    }
  };
  PDBParser.prototype._parseREMARKIfIndicatorHere = function (stream, bioTagIndicator) {
    /* eslint-disable no-magic-numbers */
    var biomoleculeWord = stream.readString(12, 23).toUpperCase();
    var biomolData = stream.readString(25, 80);
    var chainsWord = stream.readString(35, 41).toUpperCase();
    var chainsData = stream.readString(43, 80);
    var biomoleculeTag = 350;
    /* eslint-enable no-magic-numbers */
    var Ids = null;
    var i = 0;
    var splRes = null;
    var cont = null;
    //only if biomolecule not yet defined
    if (parseInt(bioTagIndicator, 10) === biomoleculeTag) {
      if (biomoleculeWord !== null && biomoleculeWord !== '' && biomoleculeWord === 'BIOMOLECULE:') {
        if (biomolData.split(',').length === 1) {
          if (!this._biomoleculeFound && parseInt(biomolData.split(',')[0].trim(), 10) === 1) {
            this._biomoleculeFound = true;
            this._allowedChainsIDs = null;
            this._lastMolId = 1;
          } else {
            this._lastMolId = parseInt(biomolData.split(',')[0].trim(), 10);
          }
        }
      } else if (this._lastMolId === 1 && this._biomoleculeFound && chainsWord === 'CHAINS:') {
        cont = chainsData;
        if (cont !== null && cont !== '') {
          Ids = [];
          if (this._allowedChainsIDs !== null) {
            for (i = 0; i < this._allowedChainsIDs.length; i++) {
              Ids.push(this._allowedChainsIDs[i]);
            }
          }
          splRes = cont.split(',');
          for (i = 0; i < splRes.length; i++) {
            if (splRes[i].trim() !== '') {
              Ids.push(splRes[i].trim().charCodeAt(0));
            }
          }
          this._allowedChainsIDs = utils.allocateTyped(Int32Array, Ids.length);
          Ids.sort();
          for (i = 0; i < Ids.length; i++) {
            this._allowedChainsIDs[i] = Ids[i];
          }
        }
      }
    }
  };
  PDBParser.prototype._parseREMARK = function (stream) {
    /* eslint-disable no-magic-numbers */
    var bioTagIndicator = stream.readString(8, 10).trim();
    /* eslint-enable no-magic-numbers */
    //only if biomolecule not yet defined
    if (bioTagIndicator !== '') {
      this._parseREMARKIfIndicatorHere(stream, bioTagIndicator);
    }
  };
  PDBParser.prototype._parseHELIX = function (stream) {
    /* eslint-disable no-magic-numbers */
    var fields = [
      20,
      22,
      32,
      34
    ];
    /* eslint-enable no-magic-numbers */
    this._parseSTRUCTURE(stream, fields, function (obj) {
      this._complex.addHelix(obj);
    }.bind(this));
  };
  PDBParser.prototype._parseSHEET = function (stream) {
    /* eslint-disable no-magic-numbers */
    var fields = [
      22,
      23,
      33,
      34
    ];
    /* eslint-enable no-magic-numbers */
    this._parseSTRUCTURE(stream, fields, function (obj) {
      this._complex.addSheet(obj);
    }.bind(this));
  };
  PDBParser.prototype._parseSTRUCTURE = function (stream, pars, adder) {
    // FIXME: HELIX and SHEET have nothing in common
    var startId = 0;
    var startIndex = 1;
    var endId = 2;
    var endIndex = 3;
    //identify fields: debugging and stuff
    /* eslint-disable no-magic-numbers */
    var codeOfS = 83;
    //var twoLinesMaxLen = 2 * 80;
    var serialNumber = stream.readInt(8, 10);
    var structureName = stream.readString(12, 14).trim();
    // FIXME: LString(3) forbids trim()
    var comment = stream.readString(41, 70).trim();
    var helLength = stream.readInt(72, 76);
    var helType = stream.readInt(39, 40);
    var shWidth = stream.readInt(15, 16);
    var shCur = stream.readInt(42, 45);
    var shPrev = stream.readInt(57, 60);
    /* eslint-enable no-magic-numbers */
    //file fields
    var startChainID = stream.readString(pars[startId], pars[endId] + 1).charCodeAt(0);
    // FIXME: no need in these
    var endChainID = stream.readString(pars[endId], pars[endId] + 1).charCodeAt(0);
    var startSequenceNumber = stream.readInt(pars[startIndex], pars[startIndex] + 3);
    var iCodeStr = stream.readString(pars[startIndex] + 4, pars[startIndex] + 4);
    var startICode = 0;
    if (iCodeStr.length > 0) {
      startICode = iCodeStr.charCodeAt(0);
    }
    var endSequenceNumber = stream.readInt(pars[endIndex], pars[endIndex] + 3);
    iCodeStr = stream.readString(pars[endIndex] + 4, pars[endIndex] + 4);
    var endICode = 0;
    if (iCodeStr.length > 0) {
      endICode = iCodeStr.charCodeAt(0);
    }
    //TODO: Consider to remove block if it is not needed
    /*
    var startInsertionCode = stream.readStringRange(pars[startIndex] + number4, pars[startIndex] + number5);
    // some files are chopped to remove trailing whitespace
    var endInsertionCode = ' ';
    var line = stream.readStringRange(0, twoLinesMaxLen);
    var nIdx = line.indexOf("\n");
    if (nIdx > 0) {
      line = line.slice(0, nIdx - 1);
    }
    if (line.length > pars[endIndex] + number4) {
      endInsertionCode = line.charAt(pars[endIndex] + number4);
    }*/
    var obj = null;
    var strand = null;
    var cs = this._sheet;
    if (stream.readCharCode(1) === codeOfS) {
      if (cs !== null && cs.getName() !== structureName) {
        cs = null;
        this._sheet = null;
      }
      if (cs === null) {
        this._sheet = obj = new Sheet(structureName, shWidth);
        adder(obj);
      } else {
        obj = cs;
      }
      strand = new Strand(obj, this._complex.getUnifiedSerial(startChainID, startSequenceNumber, startICode), this._complex.getUnifiedSerial(endChainID, endSequenceNumber, endICode), helType, shCur, shPrev);
      obj.addStrand(strand);
      strand = null;
    } else {
      obj = new Helix(serialNumber, structureName, this._complex.getUnifiedSerial(startChainID, startSequenceNumber, startICode), this._complex.getUnifiedSerial(endChainID, endSequenceNumber, endICode), helType, comment, helLength);
      adder(obj);
    }
  };
  PDBParser.prototype._parseHEADER = function (stream) {
    var metadata = this._complex.metadata;
    metadata.classification = stream.readString(11, 50).trim();
    metadata.date = stream.readString(51, 59).trim();
    var id = stream.readString(63, 66).trim();
    metadata.id = id;
    if (id) {
      this._complex.name = id;
    }
  };
  PDBParser.prototype._parseTITLE = function (stream) {
    var metadata = this._complex.metadata;
    metadata.title = metadata.title || [];
    var line = stream.readInt(9, 10) || 1;
    metadata.title[line - 1] = stream.readString(11, 80).trim();
  };
  var tagParsers = {
    'HEADER': PDBParser.prototype._parseHEADER,
    'TITLE ': PDBParser.prototype._parseTITLE,
    'ATOM  ': PDBParser.prototype._parseATOM,
    'HETATM': PDBParser.prototype._parseATOM,
    'ENDMDL': PDBParser.prototype._parseENDMDL,
    'CONECT': PDBParser.prototype._parseCONECT,
    'COMPND': PDBParser.prototype._parseCOMPND,
    'REMARK': PDBParser.prototype._parseREMARK,
    'SOURCE': PDBParser.prototype._parseSOURCE,
    'HELIX ': PDBParser.prototype._parseHELIX,
    'SHEET ': PDBParser.prototype._parseSHEET
  };
  PDBParser.prototype._parse = function (callback) {
    var stream = new PDBStream(this._data);
    var result = this._complex = new Complex();
    // parse PDB line by line
    while (!stream.end()) {
      var tag = stream.readString(1, TAG_LENGTH);
      var func = tagParsers[tag];
      if (func) {
        func.call(this, stream);
      }
      stream.next();
    }
    if (this.hasOwnProperty('_abort')) {
      callback.error(new Error('Aborted'));
      return;
    }
    // Resolve indices and serials to objects
    this._finalize();
    // cleanup
    this._allowedChainsIDs = null;
    this._serialAtomMap = null;
    this._sheet = null;
    this._residue = null;
    this._chain = null;
    this._complex = null;
    if (result.getAtomCount() === 0) {
      callback.error(new Error('Loaded file does not contain valid atoms.<br> Loading as empty...'));
      return;
    }
    if (this.hasOwnProperty('_abort')) {
      callback.error(new Error('Aborted'));
      return;
    }
    callback.ready(result);
  };
  Parser.register('PDBParser', PDBParser);
  return PDBParser;
}(io_Parser, chem_Complex, chem_AtomType, chem_Helix, chem_Sheet, chem_Strand, chem_Bond, three, settings, utils);
io_MOLParser = function (Parser, Complex) {
  function MOLParser(data, options) {
    Parser.call(this, data, options);
    this._complex = null;
    options.fileType = 'mol';
  }
  MOLParser.prototype = Object.create(Parser.prototype);
  MOLParser.prototype.constructor = MOLParser;
  MOLParser.prototype.parse = function (callback) {
    var result = this._complex = new Complex();
    // TODO: Make asynchronous
    // parse MOL
    // ...
    // cleanup
    this._complex = null;
    callback.ready(result);
  };
  MOLParser.canParse = function (data, options) {
    var type = options.fileType;
    var name = options.fileName;
    var EXT_LEN = 4;
    return typeof data === 'string' && (!type || type === 'mol') && (!name || name.toLowerCase().lastIndexOf('.mol') === name.length - EXT_LEN);
  };
  Parser.register('MOLParser', MOLParser);
  return MOLParser;
}(io_Parser, chem_Complex);
mathjax = {};
io_CMLParser = function (Parser, Complex, AtomType, Helix, Sheet, Strand, AtomName, SGroup, Bond, THREE, JAX) {
  var cOrderCharCodes = {
    A: 0,
    S: 1,
    D: 2,
    T: 3
  };
  function CMLParser(data, options) {
    Parser.call(this, data, options);
    this._complex = null;
    this._sheet = null;
    this._residue = null;
    this._serialAtomMap = null;
    this._modelId = 1;
    this._compaundFound = false;
    this._biomoleculeFound = false;
    this._allowedChainsIDs = null;
    this._lastMolId = -1;
    this._readOnlyOneMolecule = false;
    options.fileType = 'cml';
  }
  ////////////////////////////////////////////////////////////////////////////
  // Inheritance
  CMLParser.prototype = Object.create(Parser.prototype);
  CMLParser.prototype.constructor = CMLParser;
  ////////////////////////////////////////////////////////////////////////////
  // Class methods
  CMLParser.canParse = function (data, options) {
    var type = options.fileType;
    var name = options.fileName;
    var EXT_LEN = 4;
    var re = new RegExp('^\\s*?\\<\\?xml');
    var re1 = new RegExp('^\\s*?\\<cml');
    var dataHasXML = data.match(re) || data.match(re1);
    return typeof data === 'string' && dataHasXML !== null && (!type || type === 'cml') && (!name || name.toLowerCase().lastIndexOf('.cml') === name.length - EXT_LEN);
  };
  ////////////////////////////////////////////////////////////////////////////
  // Instance methods
  CMLParser.prototype._rebuidBondIndexes = function (atoms, bonds) {
    var count = atoms.length;
    var i = 0;
    for (i = 0; i < count; i++) {
      var atomId = atoms[i].id;
      var countBonds = bonds.length;
      var j = 0;
      for (j = 0; j < countBonds; j++) {
        var idxs = bonds[j].atomRefs2.split(' ');
        if (idxs[0] === atomId) {
          bonds[j].start = i;
        }
        if (idxs[1] === atomId) {
          bonds[j].end = i;
        }
      }
    }
  };
  CMLParser.prototype._createSGroup = function (molecule, moleculeArr) {
    var newGroup = null;
    newGroup = new SGroup(molecule.id, molecule.fieldData, new THREE.Vector3(parseFloat(molecule.x), parseFloat(molecule.y), 0), molecule.atomRefs, molecule);
    if (molecule.placement === 'Relative') {
      newGroup._center = new THREE.Vector3(0, 0, 0);
    }
    if (molecule.fieldName === 'MDLBG_FRAGMENT_CHARGE') {
      newGroup._charge = parseInt(molecule.fieldData, 10) || 0;
    }
    if (molecule.fieldName === 'MDLBG_FRAGMENT_COEFFICIENT') {
      newGroup._repeat = parseInt(molecule.fieldData, 10) || 1;
    }
    moleculeArr.push(newGroup);
  };
  CMLParser.prototype._extractSGroup = function (molecule, moleculeArr) {
    if (!Array.isArray(moleculeArr)) {
      moleculeArr = [];
    }
    if (molecule) {
      if (Array.isArray(molecule)) {
        var count = molecule.length;
        var i = 0;
        for (i = 0; i < count; i++) {
          if (molecule[i].molecule) {
            moleculeArr = moleculeArr.concat(this._extractSGroup(molecule[i].molecule));
          }
          this._createSGroup(molecule[i], moleculeArr);
        }
      } else {
        if (molecule.molecule) {
          if (molecule.molecule) {
            moleculeArr = moleculeArr.concat(this._extractSGroup(molecule.molecule));
          }
        }
        this._createSGroup(molecule, moleculeArr);
      }
    }
    return moleculeArr;
  };
  CMLParser.prototype._extractSGroups = function (molecule, atoms) {
    var moleculeArr = this._extractSGroup(molecule);
    var count = atoms.length;
    var i = 0;
    var j = 0;
    var firstAtomRef = null;
    var atomsRef = null;
    for (i = 0; i < count; i++) {
      var atomId = atoms[i].id;
      for (j = 0; j < moleculeArr.length; j++) {
        firstAtomRef = moleculeArr[j]._atoms.split(' ')[0];
        if (firstAtomRef === atomId) {
          if (!atoms[i].sgroupRef) {
            atoms[i].sgroupRef = [];
          }
          atoms[i].sgroupRef.push(moleculeArr[j]);
        }
      }
    }
    //build sGroups centers
    var atomMap = {};
    //sgrpmap cache
    var mapEntry = null;
    var nLimon = 100000000;
    var bLow = new THREE.Vector3(nLimon, nLimon, nLimon);
    var bHight = new THREE.Vector3(-nLimon, -nLimon, -nLimon);
    function cycleFuncInner(e) {
      mapEntry = atomMap[e];
      if (mapEntry) {
        moleculeArr[j]._atoms.push(mapEntry.a);
      }
    }
    function cycleFunc(e) {
      mapEntry = atomMap[e];
      if (mapEntry) {
        bLow.set(Math.min(bLow.x, mapEntry.x), Math.min(bLow.y, mapEntry.y), Math.min(bLow.z, mapEntry.z));
        bHight.set(Math.max(bHight.x, mapEntry.x), Math.max(bHight.y, mapEntry.y), Math.max(bHight.z, mapEntry.z));
        cycleFuncInner(e);
      }
    }
    for (i = 0; i < atoms.length; i++) {
      atomMap[atoms[i].id] = {};
      atomMap[atoms[i].id].x = atoms[i].x2;
      if (atoms[i].x3) {
        atomMap[atoms[i].id].x = atoms[i].x3;
      }
      atomMap[atoms[i].id].x = parseFloat(atomMap[atoms[i].id].x);
      atomMap[atoms[i].id].y = atoms[i].y2;
      if (atoms[i].y3) {
        atomMap[atoms[i].id].y = atoms[i].y3;
      }
      atomMap[atoms[i].id].y = parseFloat(atomMap[atoms[i].id].y);
      atomMap[atoms[i].id].z = '0.0';
      if (atoms[i].z3) {
        atomMap[atoms[i].id].z = atoms[i].z3;
      }
      atomMap[atoms[i].id].z = parseFloat(atomMap[atoms[i].id].z);
      atomMap[atoms[i].id].a = atoms[i];
    }
    for (j = 0; j < moleculeArr.length; j++) {
      if (moleculeArr[j]._center !== null) {
        bLow.set(nLimon, nLimon, nLimon);
        bHight.set(-nLimon, -nLimon, -nLimon);
        atomsRef = moleculeArr[j]._atoms.split(' ');
        moleculeArr[j]._atoms = [];
        atomsRef.forEach(cycleFunc);
        moleculeArr[j]._center.addVectors(bLow, bHight);
        moleculeArr[j]._center.multiplyScalar(0.5);
      } else {
        atomsRef = moleculeArr[j]._atoms.split(' ');
        moleculeArr[j]._atoms = [];
        atomsRef.forEach(cycleFuncInner);
      }
    }
    atomMap = null;
  };
  CMLParser.prototype._traverseData = function (dom) {
    function isArray(o) {
      return Object.prototype.toString.apply(o) === '[object Array]';
    }
    function parseNode(xmlNode, result) {
      if (xmlNode.nodeName === '#text' && xmlNode.nodeValue.trim() === '') {
        return;
      }
      var jsonNode = {};
      jsonNode.xmlNode = xmlNode;
      var existing = result[xmlNode.nodeName];
      if (existing) {
        if (!isArray(existing)) {
          result[xmlNode.nodeName] = [
            existing,
            jsonNode
          ];
        } else {
          result[xmlNode.nodeName].push(jsonNode);
        }
      } else {
        result[xmlNode.nodeName] = jsonNode;
      }
      var length = 0;
      var i = 0;
      if (xmlNode.attributes) {
        length = xmlNode.attributes.length;
        for (i = 0; i < length; i++) {
          var attribute = xmlNode.attributes[i];
          jsonNode[attribute.nodeName] = attribute.nodeValue;
        }
      }
      length = xmlNode.childNodes.length;
      for (i = 0; i < length; i++) {
        parseNode(xmlNode.childNodes[i], jsonNode);
      }
    }
    var result = {};
    if (dom.childNodes.length) {
      parseNode(dom.childNodes[0], result);
    }
    return result;
  };
  CMLParser.prototype._findSuitableMolecule = function (data, molSet) {
    var key = null;
    var i = 0;
    var tobj = data;
    for (key in tobj) {
      if (key === 'xmlNode') {
        continue;
      } else if (key === 'molecule') {
        if (tobj.molecule) {
          if (tobj.molecule.atomArray && tobj.molecule.atomArray.atom) {
            molSet.push(tobj);
          }
          if (Array.isArray(tobj.molecule)) {
            for (i = 0; i < tobj.molecule.length; i++) {
              if (tobj.molecule[i].atomArray && tobj.molecule[i].atomArray.atom) {
                molSet.push({ molecule: tobj.molecule[i] });
              }
            }
          }
        }
      } else if (tobj[key] && tobj[key] !== null && typeof tobj[key] === 'object') {
        this._findSuitableMolecule(tobj[key], molSet);
      }
    }
  };
  CMLParser.prototype._selectComponents = function (text) {
    var parser = new DOMParser();
    var doc = parser.parseFromString(text, 'application/xml');
    var traversedData = this._traverseData(doc);
    var rawData;
    var self = this;
    function prepareComponentCompound(data) {
      var tc = 0;
      var atoms = [];
      if (data.molecule && data.molecule.atomArray && data.molecule.atomArray.atom) {
        if (!Array.isArray(data.molecule.atomArray.atom)) {
          atoms.push(data.molecule.atomArray.atom);
        } else {
          atoms = data.molecule.atomArray.atom;
        }
      } else if (!data.molecule) {
        var ret = {};
        ret.atomLabels = null;
        ret.labelsCount = 1;
        return ret;
      }
      if (data.molecule.molecule) {
        self._extractSGroups(data.molecule.molecule, atoms);
      }
      var atom;
      var i = 0;
      var count = atoms.length;
      for (i = 0; i < count; i++) {
        atom = atoms[i];
        atom.edges = [];
      }
      var localBond = [];
      if (data.molecule.bondArray && data.molecule.bondArray.bond) {
        if (!Array.isArray(data.molecule.bondArray.bond)) {
          localBond.push(data.molecule.bondArray.bond);
        } else {
          localBond = data.molecule.bondArray.bond;
        }
      }
      var bond;
      count = localBond.length;
      self._rebuidBondIndexes(atoms, localBond);
      function addCurrBond() {
        bond = localBond[i];
        atom = atoms[bond.start];
        if (!atom) {
          return false;
        }
        atom.edges.push(bond.end);
        atom = atoms[bond.end];
        if (!atom) {
          return false;
        }
        atom.edges.push(bond.start);
        return true;
      }
      for (i = 0; i < count; i++) {
        if (!addCurrBond()) {
          //ignore invalid bond
          continue;
        }
        var orderAttr = bond.xmlNode.getAttribute('order');
        tc = parseInt(orderAttr, 10);
        // the default bond order is unknown
        localBond[i].order = 0;
        localBond[i].type = Bond.BondType.UNKNOWN;
        if (tc > 1) {
          localBond[i].order = tc;
        } else {
          // another option - bond order is a string
          var order = cOrderCharCodes[orderAttr];
          if (order !== undefined) {
            localBond[i].order = order;
            if (orderAttr === 'A') {
              localBond[i].type = Bond.BondType.AROMATIC;
            }
          }
        }
      }
      count = atoms.length;
      for (i = 0; i < count; i++) {
        atom = atoms[i];
        atom.edges.sort();
      }
      var labels = self._breadWidthSearch(atoms, 0);
      //for now
      var retStruct = {};
      retStruct.atoms = atoms;
      retStruct.bonds = localBond;
      retStruct.labels = labels.atomLabels;
      retStruct.count = Math.min(1, labels.labelsCount);
      //for now
      retStruct.curr = -1;
      retStruct.originalCML = doc;
      return retStruct;
    }
    if (traversedData.cml) {
      rawData = traversedData.cml;
    } else {
      rawData = traversedData;
    }
    var retData = [];
    var filteredData = [];
    this._findSuitableMolecule(rawData, filteredData);
    if (this._readOnlyOneMolecule && filteredData.length > 1) {
      filteredData.splice(1, filteredData.length - 1);
    }
    filteredData.forEach(function (d) {
      var rd = prepareComponentCompound(d);
      if (rd.atoms.length > 0) {
        retData.push(rd);
      }
    });
    return retData;
  };
  CMLParser.prototype._packLabel = function (compId, molId) {
    var shift = 16;
    return (molId << shift) + compId;
  };
  CMLParser.prototype._unpackLabel = function (l) {
    var shift = 16;
    var mask = (1 << shift) - 1;
    return {
      molId: l >>> shift,
      compId: l & mask
    };
  };
  CMLParser.prototype._breadWidthSearch = function (atoms, molID) {
    var atomLabels = new Array(atoms.length);
    var id = 0;
    for (id = 0; id < atomLabels.length; id++) {
      atomLabels[id] = this._packLabel(0, molID);
    }
    var breadthQueue = [];
    var componentID = 0;
    var labeledAtoms = atoms.length;
    while (labeledAtoms > 0) {
      componentID++;
      var startID = -1;
      for (id = 0; id < atomLabels.length; id++) {
        if (this._unpackLabel(atomLabels[id]).compId === 0) {
          startID = id;
          break;
        }
      }
      if (startID < 0) {
        break;
      }
      //Bread first search
      breadthQueue.push(atoms[startID]);
      atomLabels[startID] = this._packLabel(componentID, molID);
      labeledAtoms--;
      while (breadthQueue.length > 0) {
        var curr = breadthQueue.shift();
        var i = 0;
        if (!curr) {
          continue;
        }
        for (i = 0; i < curr.edges.length; i++) {
          if (atomLabels[curr.edges[i]] !== componentID) {
            breadthQueue.push(atoms[curr.edges[i]]);
            atomLabels[curr.edges[i]] = componentID;
            labeledAtoms--;
          }
        }
      }
    }
    var ret = {};
    ret.atomLabels = atomLabels;
    ret.labelsCount = componentID;
    return ret;
  };
  CMLParser.prototype._parseBond = function (eAtom, mainAtom, order, type) {
    if (eAtom >= 0) {
      var h = [
        Math.min(eAtom, mainAtom),
        Math.max(eAtom, mainAtom)
      ];
      this._complex.addBond(h[0], h[1], order, type, true);
    }
  };
  CMLParser.prototype._fixBondsArray = function () {
    var serialAtomMap = this._serialAtomMap = {};
    var complex = this._complex;
    var atoms = complex._atoms;
    var i = 0, ni = atoms.length;
    for (; i < ni; ++i) {
      var atom = atoms[i];
      serialAtomMap[atom._serial] = atom;
    }
    var bonds = complex._bonds;
    var j = 0, nj = bonds.length;
    for (; j < nj; ++j) {
      var bond = bonds[j];
      if (bond._right < bond._left) {
        console.log('_fixBondsArray: Logic error.');
      }
      bond._left = serialAtomMap[bond._left] || null;
      bond._right = serialAtomMap[bond._right] || null;
    }
  };
  CMLParser.prototype._parseSet = function (varData) {
    var complex = this._complex = new Complex();
    var data = varData;
    var currentLabel = data.curr;
    var atoms = data.atoms;
    var labels = data.labels;
    var atom = null;
    var i = 0;
    var j = 0;
    var count = atoms.length;
    var objRef = null;
    var sGrp = null;
    function addFunc(a) {
      a.xmlNodeRef = atom;
      if (atom.x2) {
        atom.x3 = atom.x2;
        delete atom.x2;
      }
      if (atom.y2) {
        atom.y3 = atom.y2;
        delete atom.y2;
      }
      if (!atom.z3) {
        atom.z3 = '0.0';
      }
      atom.complexAtom = a;
    }
    var nodeHText = '';
    var atomCharge = 0;
    var texString = '';
    var texInner = '';
    var texRight = '';
    var chains = {};
    var lLabel = null;
    //parse atoms in label order
    var reorder = [];
    for (i = 0; i < count; i++) {
      reorder.push(i);
    }
    reorder.sort(function (a, b) {
      return labels[a] - labels[b];
    });
    for (i = 0; i < count; i++) {
      atomCharge = 0;
      lLabel = labels[reorder[i]];
      if (this._unpackLabel(lLabel).molId === this._unpackLabel(currentLabel).molId) {
        atom = atoms[reorder[i]];
        var atomHtmlNode = null;
        texString = texRight = texInner = '';
        if (atom.isotopeNumber || atom.formalCharge || atom.mrvValence || atom.radical) {
          texString = '\\(';
          texInner = '\\text{' + atom.elementType + '}';
          if (atom.radical) {
            nodeHText = '';
            switch (atom.radical) {
            case 'monovalent':
              nodeHText += '\\dot';
              break;
            case 'divalent1':
              nodeHText += '\\ddot';
              break;
            case 'divalent3':
              nodeHText += '\\overset{{}_{\\wedge\\wedge}}';
              break;
            default:
              nodeHText += '\\tilde';
              break;
            }
            nodeHText += '{';
            texInner = nodeHText + texInner + '}';
          }
          if (atom.isotopeNumber) {
            texString += '{\\vphantom{' + texInner + '}}^{' + atom.isotopeNumber.toString() + '}';
          }
          if (atom.formalCharge) {
            atomCharge = parseInt(atom.formalCharge, 10);
            if (atomCharge < 0) {
              nodeHText = (-atomCharge).toString() + '\\vphantom{1}-\\vphantom{1}';
            } else {
              nodeHText = atomCharge.toString() + '\\text{+}';
            }
            if (nodeHText.charCodeAt(0) === 49) {
              nodeHText = nodeHText.substring(1);
            }
            texRight = nodeHText;
          }
          nodeHText = '';
          if (atom.mrvValence) {
            nodeHText = '';
            switch (parseInt(atom.mrvValence, 10)) {
            case 1:
              nodeHText = 'I';
              break;
            case 2:
              nodeHText = 'II';
              break;
            case 3:
              nodeHText = 'III';
              break;
            case 4:
              nodeHText = 'IV';
              break;
            case 5:
              nodeHText = 'V';
              break;
            case 6:
              nodeHText = 'VI';
              break;
            case 7:
              nodeHText = 'VII';
              break;
            case 8:
              nodeHText = 'VIII';
              break;
            default:
              nodeHText = 'IX';
              break;
            }
            texRight += '\\text{(' + nodeHText + ')}';
          }
          if (texRight.length > 0) {
            texString += '{' + texInner + '}^{' + texRight + '}\\)';
          } else {
            texString += texInner + '\\)';
          }
          var rnd = Math.random();
          atomHtmlNode = JAX.HTML.Element(//eslint-disable-line new-cap
          'span', {
            id: rnd.toString(),
            style: { fontSize: '150%' }
          }, [texString]);
          JAX.Hub.Queue([
            'Typeset',
            JAX.Hub,
            atomHtmlNode
          ]);  //eslint-disable-line new-cap
        }
        var atomFullNameStruct = new AtomName(atom.elementType, atomHtmlNode);
        if (atom.sgroupRef) {
          var k = 0;
          var countRef = atom.sgroupRef.length;
          for (k = 0; k < countRef; ++k) {
            complex._sgroups.push(atom.sgroupRef[k]);
          }
        }
        if (atom.x3 || atom.x2) {
          var currAtomComp = this._unpackLabel(lLabel).compId;
          var chainID = String.fromCharCode('A'.charCodeAt(0) + currAtomComp);
          var resSeq = currAtomComp;
          var iCode = ' ';
          var strLabel = currAtomComp.toString();
          if (strLabel.length === 1) {
            strLabel = '0' + strLabel;
          }
          var resName = 'N' + strLabel;
          var chain = chains[chainID];
          if (!chain || chain.getName() !== chainID) {
            chains[chainID] = chain = this._complex.getChain(chainID) || this._complex.addChain(chainID);
            this._residue = null;
          }
          var residue = this._residue;
          if (!residue || residue.getSequence() !== resSeq || residue.getICode() !== iCode) {
            this._residue = residue = chain.addResidue(resName, resSeq, iCode);
          }
          //_x, _y, _z, mname, mindex, atomNameFull, atomName, chainID, serial, isHet, atlLocInd, atomNameToTypeF
          var xyz = null;
          if (atom.x3) {
            xyz = new THREE.Vector3(parseFloat(atom.x3), parseFloat(atom.y3), parseFloat(atom.z3));
          } else if (atom.x2) {
            xyz = new THREE.Vector3(parseFloat(atom.x2), parseFloat(atom.y2), 0);
          }
          var atomType = AtomType.PeriodicTable[atom.elementType.toUpperCase()];
          if (!atomType) {
            atomType = JSON.parse(JSON.stringify(AtomType.PeriodicTable[Object.keys(AtomType.PeriodicTable)[Object.keys(AtomType.PeriodicTable).length - 1]]));
            atomType.number += 1;
            atomType.name = atom.elementType.toUpperCase();
            atomType.fullName = 'Unknown';
            AtomType.PeriodicTable[atom.elementType.toUpperCase()] = atomType;
          }
          var atomSerial = parseInt(atom.id.replace(/[^0-9]/, ''), 10);
          var added = residue.addAtom(atomFullNameStruct, atomType, xyz, AtomType.Role.SG, true, atomSerial, ' ', 1, 32, atomCharge);
          if (atom.hydrogenCount) {
            added._hydrogenCount = parseInt(atom.hydrogenCount, 10);
          }
          if (atom.mrvValence) {
            added._valence = parseInt(atom.mrvValence, 10);
          }
          addFunc(added);
        }
      }
    }
    chains = null;
    for (i = 0; i < data.bonds.length; i++) {
      var cb = data.bonds[i];
      if (this._unpackLabel(labels[cb.start]).molId === this._unpackLabel(currentLabel).molId && this._unpackLabel(labels[cb.end]).molId === this._unpackLabel(currentLabel).molId) {
        atom = atoms[cb.start];
        if (!atom || !atoms[cb.end]) {
          continue;  //skip invalid
        }
        this._parseBond(parseInt(atom.id.replace(/[^0-9]/, ''), 10), parseInt(atoms[cb.end].id.replace(/[^0-9]/, ''), 10), cb.order, cb.type);
      }
    }
    for (i = 0; i < this._complex.getSGroupCount(); i++) {
      sGrp = this._complex.getSGroups()[i];
      for (j = 0; j < sGrp._atoms.length; j++) {
        objRef = sGrp._atoms[j].complexAtom;
        sGrp._atoms[j] = objRef;
      }
    }
    for (i = 0; i < count; i++) {
      if (this._unpackLabel(labels[i]).molId === this._unpackLabel(currentLabel).molId) {
        atom = atoms[i];
        atom.complexAtom = null;
        delete atom.complexAtom;
      }
    }
    objRef = null;
    this._complex.originalCML = data.originalCML;
    this._fixBondsArray();
    this._complex.finalize(this._serialAtomMap, false);
    this._serialAtomMap = null;
    this._complex = null;
    return complex;
  };
  CMLParser.prototype._parse = function (callback) {
    var complexes = [];
    var self = this;
    var moleculaSet = this._selectComponents(this._data);
    moleculaSet.forEach(function (molSet) {
      molSet.curr = 2;
      var i = 0;
      if (molSet.count === 0) {
        molSet.count = 1;
      }
      for (i = 0; i < molSet.count; i++) {
        if (self.hasOwnProperty('_abort')) {
          callback.error(new Error('Aborted'));
          return;
        }
        molSet.curr = i + 1;
        complexes.push(self._parseSet(molSet, false));
      }
    });
    var totalAtomsParsed = 0;
    complexes.forEach(function (c) {
      totalAtomsParsed += c.getAtomCount();
    });
    if (totalAtomsParsed <= 0) {
      callback.error(new Error('Loaded file does not contain valid atoms.<br> Loading as empty...'));
      return;
    }
    if (this.hasOwnProperty('_abort')) {
      callback.error(new Error('Aborted'));
      return;
    }
    if (complexes.length > 1) {
      var joinedComplex = new Complex();
      joinedComplex.joinComplexes(complexes);
      joinedComplex.originalCML = complexes[0].originalCML;
      callback.ready(joinedComplex);
    }
    if (complexes.length === 1) {
      callback.ready(complexes[0]);
    }
    if (complexes.length === 0) {
      callback.ready(new Complex());
    }
  };
  Parser.register('CMLParser', CMLParser);
  return CMLParser;
}(io_Parser, chem_Complex, chem_AtomType, chem_Helix, chem_Sheet, chem_Strand, chem_AtomName, chem_SGroup, chem_Bond, three, mathjax);
io_io = function (Loader, Parser) {
  return {
    Loader: Loader,
    Parser: Parser
  };
}(io_Loader, io_Parser);
gfx_CSS2DObject = function (jQuery, THREE) {
  function CSS2DObject(element) {
    THREE.Object3D.call(this);
    var self = this;
    this._element = element;
    this._element.style.position = 'absolute';
    this.addEventListener('removed', function () {
      if (self._element.parentNode !== null) {
        self._element.parentNode.removeChild(self._element);
      }
    });
  }
  CSS2DObject.prototype = Object.create(THREE.Object3D.prototype);
  CSS2DObject.prototype.constructor = CSS2DObject;
  CSS2DObject.prototype.getElement = function () {
    return this._element;
  };
  /**
   * Sets label transparency.
   *
   * @param {number} transp    - in [0; 1] 1 means fully transparent
   */
  CSS2DObject.prototype.setTransparency = function (transp) {
    var el = this.getElement();
    if (el === null) {
      return;
    }
    if (transp === 1) {
      el.style.display = 'none';
      return;
    }
    el.style.display = 'inline';
    var op = 1 - transp;
    var top = op.toString();
    var op100 = op * 100;
    el.style.opacity = top;
    el.style.filter = 'alpha(opacity=' + op100 + ')';  // IE fallback
  };
  CSS2DObject.prototype.clone = function () {
    var obj = new CSS2DObject(this._element);
    obj.copy(this);
    return obj;
  };
  return CSS2DObject;
}(jquery, three);
gfx_gfxutils = function (THREE, CSS2DObject) {
  THREE.Object3D.prototype.resetTransform = function () {
    this.position.set(0, 0, 0);
    this.quaternion.set(0, 0, 0, 1);
    this.scale.set(1, 1, 1);
  };
  // render a tiny transparent quad in the center of the screen
  THREE.WebGLRenderer.prototype.renderDummyQuad = function () {
    var _material = new THREE.MeshBasicMaterial({
      opacity: 0,
      depthWrite: false
    });
    var _scene = new THREE.Scene();
    var _quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(0.01, 0.01), _material);
    _scene.add(_quad);
    var _camera = new THREE.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -10000, 10000);
    _camera.position.z = 100;
    return function (renderTarget) {
      this.render(_scene, _camera, renderTarget);
    };
  }();
  THREE.WebGLRenderer.prototype.renderScreenQuad = function () {
    var _scene = new THREE.Scene();
    var _quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(1, 1));
    _scene.add(_quad);
    var _camera = new THREE.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -10000, 10000);
    _camera.position.z = 100;
    return function (material, renderTarget) {
      _quad.material = material;
      this.render(_scene, _camera, renderTarget);
    };
  }();
  THREE.WebGLRenderer.prototype.renderScreenQuadFromTex = function () {
    var _material = new THREE.ShaderMaterial({
      uniforms: {
        srcTex: {
          type: 't',
          value: null
        },
        opacity: {
          type: 'f',
          value: 1
        }
      },
      vertexShader: 'varying vec2 vUv; ' + 'void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }',
      fragmentShader: 'varying vec2 vUv; uniform sampler2D srcTex; uniform float opacity;' + 'void main() { vec4 color = texture2D(srcTex, vUv); gl_FragColor = vec4(color.xyz, color.a * opacity); }',
      transparent: true,
      depthTest: false,
      depthWrite: false
    });
    return function (srcTex, opacity, renderTarget) {
      _material.uniforms.srcTex.value = srcTex;
      _material.transparent = opacity < 1;
      _material.uniforms.opacity.value = opacity;
      this.renderScreenQuad(_material, renderTarget);
    };
  }();
  // TODO: move to a new Camera class?
  /**
   * @param {number} angle - Field of view in degrees.
   */
  THREE.PerspectiveCamera.prototype.setMinimalFov = function (angle) {
    if (this.aspect >= 1) {
      this.fov = angle;
    } else {
      this.fov = THREE.Math.radToDeg(2 * Math.atan(Math.tan(THREE.Math.degToRad(angle) * 0.5) / this.aspect));
    }
  };
  /**
   * @param {number} radius - Radius of bounding sphere in angstroms to fit on screen.
   * @param {number} angle - Field of view in degrees.
   */
  THREE.PerspectiveCamera.prototype.setDistanceToFit = function (radius, angle) {
    this.position.z = radius / Math.sin(0.5 * THREE.Math.degToRad(angle));
  };
  function _calcCylinderMatrix(posBegin, posEnd, radius) {
    var posCenter = posBegin.clone().lerp(posEnd, 0.5);
    var matScale = new THREE.Matrix4();
    matScale.makeScale(radius, posBegin.distanceTo(posEnd), radius);
    var matRotHalf = new THREE.Matrix4();
    matRotHalf.makeRotationX(Math.PI / 2);
    var matRotLook = new THREE.Matrix4();
    var vUp = new THREE.Vector3(0, 1, 0);
    matRotLook.lookAt(posCenter, posEnd, vUp);
    matRotLook.multiply(matRotHalf);
    matRotLook.multiply(matScale);
    matRotLook.setPosition(posCenter);
    return matRotLook;
  }
  function _calcChunkMatrix(eye, target, up, rad) {
    var matScale = new THREE.Matrix4();
    matScale.makeScale(rad.x, rad.y, 0);
    var matRotLook = new THREE.Matrix4();
    matRotLook.lookAt(eye, target, up);
    matRotLook.multiply(matScale);
    matRotLook.setPosition(eye);
    return matRotLook;
  }
  function _forEachMeshInGroup(group, process) {
    function processObj(object) {
      if (object instanceof THREE.Mesh) {
        process(object);
      }
      for (var i = 0, l = object.children.length; i < l; i++) {
        processObj(object.children[i]);
      }
    }
    processObj(group);
  }
  function _countMeshTriangles(mesh) {
    var geom = mesh.geometry;
    if (geom instanceof THREE.InstancedBufferGeometry) {
      var attribs = geom.attributes;
      for (var property in attribs) {
        if (attribs.hasOwnProperty(property) && attribs[property] instanceof THREE.InstancedBufferAttribute) {
          var currAttr = attribs[property];
          var indexSize = geom.index ? geom.index.array.length / 3 : 0;
          return indexSize * currAttr.array.length / currAttr.itemSize;
        }
      }
      return 0;
    }
    if (geom instanceof THREE.BufferGeometry) {
      return geom.index ? geom.index.array.length / 3 : 0;
    }
    return geom.faces ? geom.faces.length : 0;
  }
  function _countTriangles(group) {
    var totalCount = 0;
    _forEachMeshInGroup(group, function (mesh) {
      totalCount += _countMeshTriangles(mesh);
    });
    return totalCount;
  }
  function _groupHasGeometryToRender(group) {
    var hasGeoms = false;
    group.traverse(function (node) {
      if (node.hasOwnProperty('geometry') || node instanceof CSS2DObject) {
        hasGeoms = true;
      }
    });
    return hasGeoms;
  }
  THREE.BufferAttribute.prototype.copyAtList = function (attribute, indexList) {
    console.assert(this.itemSize === attribute.itemSize, 'DEBUG: BufferAttribute.copyAtList buffers have different item size.');
    var itemSize = this.itemSize;
    for (var i = 0, n = indexList.length; i < n; ++i) {
      for (var j = 0; j < itemSize; ++j) {
        this.array[i * itemSize + j] = attribute.array[indexList[i] * itemSize + j];
      }
    }
    return this;
  };
  function RCGroup() {
    THREE.Group.call(this);
  }
  RCGroup.prototype = Object.create(THREE.Group.prototype);
  RCGroup.prototype.constructor = RCGroup;
  RCGroup.prototype.raycast = function (raycaster, intersects) {
    if (!this.visible) {
      return;
    }
    var children = this.children;
    for (var i = 0, n = children.length; i < n; ++i) {
      children[i].raycast(raycaster, intersects);
    }
  };
  RCGroup.prototype.enableSubset = function (mask, innerOnly) {
    var children = this.children;
    for (var i = 0, n = children.length; i < n; ++i) {
      if (children[i].enableSubset) {
        children[i].enableSubset(mask, innerOnly);
      }
    }
  };
  RCGroup.prototype.disableSubset = function (mask, innerOnly) {
    var children = this.children;
    for (var i = 0, n = children.length; i < n; ++i) {
      if (children[i].disableSubset) {
        children[i].disableSubset(mask, innerOnly);
      }
    }
  };
  RCGroup.prototype.getSubset = function (mask, innerOnly) {
    var totalSubset = [];
    var children = this.children;
    for (var i = 0, n = children.length; i < n; ++i) {
      if (children[i].getSubset) {
        Array.prototype.push.apply(totalSubset, children[i].getSubset(mask, innerOnly));
      }
    }
    return totalSubset;
  };
  function fillArray(array, value, startIndex, endIndex) {
    startIndex = typeof startIndex !== 'undefined' ? startIndex : 0;
    endIndex = typeof endIndex !== 'undefined' ? endIndex : array.length;
    for (var i = startIndex; i < endIndex; ++i) {
      array[i] = value;
    }
  }
  return {
    calcCylinderMatrix: _calcCylinderMatrix,
    calcChunkMatrix: _calcChunkMatrix,
    forEachMeshInGroup: _forEachMeshInGroup,
    countTriangles: _countTriangles,
    groupHasGeometryToRender: _groupHasGeometryToRender,
    RCGroup: RCGroup,
    fillArray: fillArray
  };
}(three, gfx_CSS2DObject);
gfx_modes_buildBondLines = function (THREE) {
  function getCylinderCount(bondOrder) {
    return bondOrder < 2 ? 1 : bondOrder;
  }
  function LinesGroup(LinesBuilderName, component, colorer, mode, mask, material) {
    THREE.Group.call(this);
    var complex = component.getComplex();
    complex.propagateAtoms();
    this._component = component;
    this._collisionGeo = null;
    this._atomRad = mode.calcAtomRadius();
    this._mesh = null;
    this._material = material;
    this._selMaterial = this.initSelectionMaterial();
    var bondsGeo = this._createBondsGeo(LinesBuilderName, component, colorer, mode, mask, material);
    if (bondsGeo === null) {
      return;
    }
    this.add(bondsGeo);
  }
  LinesGroup.prototype = Object.create(THREE.Group.prototype);
  LinesGroup.prototype.constructor = LinesGroup;
  LinesGroup.prototype.initSelectionMaterial = function () {
    var mat = this._material.createInstance();
    mat.setValues({
      vertexColors: THREE.VertexColors,
      transparent: false,
      fog: true,
      side: THREE.DoubleSide
    });
    mat.setUberOptions({
      specular: new THREE.Color(1381653),
      shininess: 30
    });
    return mat;
  };
  LinesGroup.prototype._createBondsGeo = function (LinesBuilderName, component, colorer, mode, mask, material) {
    var drawMultiple = mode.drawMultiorderBonds();
    var self = this;
    var bondsCount = 0;
    var complex = component.getComplex();
    component.forEachBond(function (bond) {
      var atom1 = bond._left;
      var atom2 = bond._right;
      if (!(atom1._mask & mask) || !(atom2._mask & mask)) {
        return;
      }
      bondsCount += drawMultiple ? getCylinderCount(bond._order) : 1;
    });
    if (bondsCount === 0) {
      return null;
    }
    var builder = new LinesBuilderName(bondsCount, material);
    this._builder = builder;
    this._chunksToIdc = new Array(bondsCount);
    var chunksToIdx = this._chunksToIdc;
    var currBondIdx = 0;
    var bondDir = new THREE.Vector3();
    var cStepSize = 0.15;
    component.forEachBond(function (bond) {
      var atom1 = bond._left;
      var atom2 = bond._right;
      if (!(atom1._mask & mask) || !(atom2._mask & mask)) {
        return;
      }
      var a1Pos = atom1._position;
      var a2Pos = atom2._position;
      var a1Hangs = atom1._bonds.length === 1;
      var a2Hangs = atom2._bonds.length === 1;
      bondDir.subVectors(a2Pos, a1Pos);
      var len = bondDir.length();
      var normDir = bond.calcNormalDir();
      var order = drawMultiple ? getCylinderCount(bond._order) : 1;
      for (var j = 0; j < order; ++j) {
        var leftPos = a1Pos.clone();
        var rightPos = a2Pos.clone();
        var scale = order % 2 === 0 ? ((j / 2 | 0) + 0.5) * (1 - 2 * (j % 2)) : ((j + 1) / 2 | 0) * (-1 + 2 * (j % 2));
        chunksToIdx[currBondIdx] = bond._index;
        if (order === 2 && (!a1Hangs && !a2Hangs)) {
          scale -= 0.5;
          scale *= -1;
        }
        if (!a1Hangs && !a2Hangs && order > 1 && scale !== 0) {
          leftPos.lerpVectors(a1Pos, a2Pos, cStepSize / len);
          rightPos.lerpVectors(a1Pos, a2Pos, 1 - cStepSize / len);
        }
        scale *= cStepSize;
        leftPos.addScaledVector(normDir, scale);
        rightPos.addScaledVector(normDir, scale);
        builder.addItem(currBondIdx++, leftPos, rightPos, self._atomRad, colorer.getAtomColor(atom1, complex), colorer.getAtomColor(atom2, complex));
      }
    });
    return builder.getObjects();
  };
  LinesGroup.prototype._calcChunksList = function (mask, innerOnly) {
    if (this._chunksToIdc === null) {
      return [];
    }
    var chunksList = [];
    var bonds = this._component.getComplex()._bonds;
    var chunksToIdx = this._chunksToIdc;
    for (var i = 0, n = chunksToIdx.length; i < n; ++i) {
      var bond = bonds[chunksToIdx[i]];
      if (bond._left._mask & mask && (!innerOnly || bond._right._mask & mask)) {
        chunksList.push(2 * i);
      }
      if (bond._right._mask & mask && (!innerOnly || bond._left._mask & mask)) {
        chunksList.push(2 * i + 1);
      }
    }
    return chunksList;
  };
  LinesGroup.prototype.raycast = function (raycaster, intersects) {
    if (this._builder === null) {
      return;
    }
    var inters = [];
    var bonds = this._component.getComplex()._bonds;
    this._builder.raycast(raycaster, inters);
    var chunksToIdx = this._chunksToIdc;
    // process inters array - arr object references
    for (var i = 0, n = inters.length; i < n; ++i) {
      if (!inters[i].hasOwnProperty('chunkIdx')) {
        continue;
      }
      var chunkIdx = inters[i].chunkIdx;
      var bondIdx = chunksToIdx[Math.floor(chunkIdx / 2)];
      if (bondIdx < bonds.length) {
        var bond = bonds[bondIdx];
        inters[i].atom = chunkIdx % 2 === 0 ? bond._left : bond._right;
        intersects.push(inters[i]);
      }
    }
  };
  LinesGroup.prototype.getSubset = function (mask, innerOnly) {
    innerOnly = innerOnly !== undefined ? innerOnly : false;
    var chunksList = this._calcChunksList(mask, innerOnly);
    if (chunksList.length === 0) {
      return [];
    }
    var selObjects = this._builder.getSubset(chunksList);
    for (var objIdx = 0, objCount = selObjects.length; objIdx < objCount; ++objIdx) {
      selObjects[objIdx]._component = this._component;
    }
    return selObjects;
  };
  LinesGroup.prototype._changeSubsetOpacity = function (mask, value, innerOnly) {
    var chunksList = this._calcChunksList(mask, innerOnly);
    if (chunksList.length === 0) {
      return;
    }
    this._builder.setOpacity(chunksList, value);
  };
  LinesGroup.prototype.enableSubset = function (mask, innerOnly) {
    innerOnly = innerOnly !== undefined ? innerOnly : true;
    this._changeSubsetOpacity(mask, 1, innerOnly);
  };
  LinesGroup.prototype.disableSubset = function (mask, innerOnly) {
    innerOnly = innerOnly !== undefined ? innerOnly : true;
    this._changeSubsetOpacity(mask, 0, innerOnly);
  };
  function buildBondLines(LinesBuilderName, component, colorer, mode, _polyComplexity, mask, material) {
    return new LinesGroup(LinesBuilderName, component, colorer, mode, mask, material);
  }
  return buildBondLines;
}(three);
gfx_modes_SphereCollisionGeo = function (THREE) {
  //////////////////////////////////////////////////////////////////////////////
  function CollisionSphere(position, radius) {
    this._position = position;
    this._radius = radius;
  }
  CollisionSphere.prototype.raycast = function () {
    var sphere = new THREE.Sphere();
    return function raycast(parentMatrix, raycaster) {
      sphere.set(this._position, this._radius);
      sphere.applyMatrix4(parentMatrix);
      var p = raycaster.ray.intersectSphere(sphere);
      if (p) {
        return {
          distance: raycaster.ray.origin.distanceTo(p),
          point: p
        };
      }
      return null;
    };
  }();
  //////////////////////////////////////////////////////////////////////////////
  function CollisionSpheresGeo(count) {
    this._objects = new Array(count);
    this.boundingSphere = new THREE.Sphere();
    this.boundingBox = new THREE.Box3();
  }
  CollisionSpheresGeo.constructor = CollisionSpheresGeo;
  CollisionSpheresGeo.prototype.addSphere = function (idx, position, radius) {
    this._objects[idx] = new CollisionSphere(position, radius);
  };
  CollisionSpheresGeo.prototype.raycast = function (parentMatrix, raycaster, intersects) {
    for (var i = 0; i < this._objects.length; ++i) {
      var inters = this._objects[i].raycast(parentMatrix, raycaster, intersects);
      if (inters) {
        inters.chunkIdx = i;
        intersects.push(inters);
      }
    }
  };
  CollisionSpheresGeo.prototype.computeBoundingSphere = function () {
    var objects = this._objects;
    var n = objects.length;
    var i = 0;
    var boundingBox = this.boundingBox;
    boundingBox.makeEmpty();
    for (; i < n; ++i) {
      boundingBox.expandByPoint(objects[i]._position);
    }
    // Build bounding sphere
    var radiusSquared = 0;
    var center = boundingBox.isEmpty() ? new THREE.Vector3() : boundingBox.center();
    for (i = 0; i < n; ++i) {
      var pos = objects[i]._position;
      var lengthSquared = center.distanceToSquared(pos);
      if (radiusSquared < lengthSquared) {
        radiusSquared = lengthSquared;
      }
    }
    this.boundingSphere.set(center, Math.sqrt(radiusSquared));
  };
  return CollisionSpheresGeo;
}(three);
gfx_shaders_UberMaterial = function (THREE) {
  var INSTANCED_SPRITE_OVERSCALE = 1.3;
  var defaultUniforms = THREE.UniformsUtils.merge([
    THREE.UniformsLib.common,
    THREE.UniformsLib.aomap,
    THREE.UniformsLib.lightmap,
    THREE.UniformsLib.emissivemap,
    THREE.UniformsLib.bumpmap,
    THREE.UniformsLib.normalmap,
    THREE.UniformsLib.displacementmap,
    THREE.UniformsLib.fog,
    THREE.UniformsLib.lights,
    {
      'specular': {
        type: 'c',
        value: new THREE.Color(1118481)
      },
      'shininess': {
        type: 'f',
        value: 30
      },
      'fixedColor': {
        type: 'c',
        value: new THREE.Color(16777215)
      },
      'zOffset': {
        type: 'f',
        value: 0
      },
      'zClipValue': {
        type: 'f',
        value: 0
      }
    }
  ]);
  var uberOptionNames = [
    'shininess',
    'opacity',
    'zOffset',
    'diffuse',
    'specular',
    'fixedColor',
    'zClipCoef',
    'zClipValue'
  ];
  var vertexShader = [
    'varying vec3 vViewPosition;',
    '#ifndef FLAT_SHADED',
    '\tvarying vec3 vNormal;',
    '#endif',
    '#ifdef ATTR_ALPHA_COLOR',
    '  attribute float alphaColor;',
    '  varying float alphaCol;',
    '#endif',
    // ATTR_COLOR duplicates USE_COLOR define which we cannot set directly
    '#if defined(ATTR_COLOR) && !defined(USE_COLOR)',
    '  attribute vec3 color;',
    // this is defined in vertex shader prefix under #ifdef USE_COLOR
    '  #define USE_COLOR',
    '#endif',
    '#ifdef ATTR_COLOR2',
    '  attribute vec3 color2;',
    '  varying vec3 vColor2;',
    '  #ifndef INTERPOLATE_UV',
    '    #define INTERPOLATE_UV',
    '  #endif',
    '#endif',
    '#include <common>',
    '#include <uv_pars_vertex>',
    '#include <uv2_pars_vertex>',
    '#include <displacementmap_pars_vertex>',
    '#include <envmap_pars_vertex>',
    '#include <lights_phong_pars_vertex>',
    '#include <color_pars_vertex>',
    '#include <morphtarget_pars_vertex>',
    '#include <skinning_pars_vertex>',
    '#include <shadowmap_pars_vertex>',
    '#include <logdepthbuf_pars_vertex>',
    '#ifdef INSTANCED_POS',
    '  attribute vec4 offset;',
    '  varying vec4 instOffset;',
    '#endif',
    '#ifdef INSTANCED_SPRITE',
    '  varying vec4 spritePosEye;',
    '#endif',
    '#ifdef INTERPOLATE_UV',
    '\tvarying vec2 vUv;',
    '#endif',
    '#ifdef INSTANCED_MATRIX',
    '  attribute vec4 matVector1;',
    '  attribute vec4 matVector2;',
    '  attribute vec4 matVector3;',
    '  attribute vec4 invmatVector1;',
    '  attribute vec4 invmatVector2;',
    '  attribute vec4 invmatVector3;',
    '  varying vec4 matVec1;',
    '  varying vec4 matVec2;',
    '  varying vec4 matVec3;',
    '  varying vec4 invmatVec1;',
    '  varying vec4 invmatVec2;',
    '  varying vec4 invmatVec3;',
    '#endif',
    'void main() {',
    '\t#include <uv_vertex>',
    '\t#include <uv2_vertex>',
    '\t#include <color_vertex>',
    '\t#include <beginnormal_vertex>',
    '\t#include <morphnormal_vertex>',
    '\t#include <skinbase_vertex>',
    '\t#include <skinnormal_vertex>',
    '\t#include <defaultnormal_vertex>',
    '#ifdef ATTR_ALPHA_COLOR',
    '  alphaCol = alphaColor;',
    '#endif',
    '#ifdef INSTANCED_MATRIX',
    '  transformedNormal = vec3(' + ' dot(objectNormal, matVector1.xyz), ' + ' dot(objectNormal, matVector2.xyz), ' + ' dot(objectNormal, matVector3.xyz));',
    '  transformedNormal = normalMatrix * transformedNormal;',
    '#endif',
    '#ifndef FLAT_SHADED',
    // Normal computed with derivatives when FLAT_SHADED
    '\tvNormal = normalize(transformedNormal);',
    '#endif',
    '\t#include <begin_vertex>',
    '\t#include <displacementmap_vertex>',
    '\t#include <morphtarget_vertex>',
    '\t#include <skinning_vertex>',
    '\t#include <project_vertex>',
    '#ifdef INSTANCED_POS',
    '  instOffset = offset;',
    '  #ifdef INSTANCED_SPRITE',
    '    spritePosEye = modelViewMatrix * vec4( offset.xyz, 1.0 );',
    '    float scale = length(modelViewMatrix[0]);',
    '    mvPosition = spritePosEye + vec4( position * offset.w * scale * ' + INSTANCED_SPRITE_OVERSCALE + ', 0.0 );',
    '    spritePosEye.w = offset.w * scale;',
    '  #else',
    '    mvPosition = modelViewMatrix * vec4( offset.xyz + position * offset.w, 1.0 );',
    '  #endif',
    '#endif',
    '#ifdef INSTANCED_MATRIX',
    '  matVec1 = matVector1;',
    '  matVec2 = matVector2;',
    '  matVec3 = matVector3;',
    '  invmatVec1 = invmatVector1;',
    '  invmatVec2 = invmatVector2;',
    '  invmatVec3 = invmatVector3;',
    '  #ifdef INSTANCED_SPRITE',
    // calculate eye coords of cylinder endpoints
    '    vec4 v = vec4(0, -0.5, 0, 1);',
    '    vec4 p1 = modelViewMatrix * vec4(' + '      dot(v, matVector1), ' + '      dot(v, matVector2), ' + '      dot(v, matVector3), 1.0);',
    '    v.y = 0.5;',
    '    vec4 p2 = modelViewMatrix * vec4(' + '      dot(v, matVector1), ' + '      dot(v, matVector2), ' + '      dot(v, matVector3), 1.0);',
    // sprite is placed at the center of cylinder
    '    spritePosEye.xyz = mix(p1.xyz, p2.xyz, 0.5);',
    '    spritePosEye.w = 1.0;',
    // basic sprite size at screen plane (covers only cylinder axis)
    '    vec2 spriteSizeScreen = abs(p2.xy / p2.z - p1.xy / p1.z);',
    // cylinder radius in eye space
    '    float rad = length(modelViewMatrix[0]) * length(vec3(matVector1.x, matVector2.x, matVector3.x));',
    // full sprite size in eye coords
    '    float minZ = min(abs(p1.z), abs(p2.z));',
    '    vec2 spriteSize = ' + INSTANCED_SPRITE_OVERSCALE + ' * abs(spritePosEye.z) *' + '      (spriteSizeScreen + 2.0 * rad / minZ);',
    '    mvPosition = spritePosEye + vec4( position.xy * 0.5 * spriteSize, 0, 0 );',
    '  #else',
    '    vec4 pos = vec4(position, 1.0);',
    '    mvPosition = modelViewMatrix * vec4(' + '      dot(pos, matVector1), ' + '      dot(pos, matVector2), ' + '      dot(pos, matVector3), 1.0 );',
    '  #endif',
    '#endif',
    'gl_Position = projectionMatrix * mvPosition;',
    '\t#include <logdepthbuf_vertex>',
    '\tvViewPosition = - mvPosition.xyz;',
    '\t#include <worldpos_vertex>',
    '\t#include <envmap_vertex>',
    '\t#include <lights_phong_vertex>',
    '\t#include <shadowmap_vertex>',
    '#ifdef ATTR_COLOR2',
    '  vColor2 = color2;',
    '#endif',
    '#ifdef INTERPOLATE_UV',
    '\t vUv = uv;',
    '#endif',
    '}'
  ].join('\n');
  var fragmentShader = [
    '#ifdef ATTR_ALPHA_COLOR',
    '  varying float alphaCol;',
    '#endif',
    '#if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)',
    '  uniform float zOffset;',
    '  uniform mat4 projectionMatrix;',
    '  varying vec4 spritePosEye;',
    '#endif',
    '#ifdef SPHERE_SPRITE',
    '  uniform mat4 modelViewMatrix;',
    '  uniform mat4 invModelViewMatrix;',
    '  uniform mat3 normalMatrix;',
    '  varying vec4 instOffset;',
    '  float intersect_ray_sphere(in vec3 origin, in vec3 ray, out vec3 point) {',
    // intersect XZ-projected ray with circle
    '    float a = dot(ray, ray);',
    '    float b = dot(ray, origin);',
    '    float c = dot(origin, origin) - 1.0;',
    '    float det = b * b - a * c;',
    '    if (det < 0.0) return -1.0;',
    '    float t1 = (-b - sqrt(det)) / a;',
    '    float t2 = (-b + sqrt(det)) / a;',
    // calculate both intersection points
    '    vec3 p1 = origin + ray * t1;',
    '    vec3 p2 = origin + ray * t2;',
    // choose nearest point
    '    if (t1 >= 0.0) {',
    '      point = p1;',
    '      return t1;',
    '    }',
    '    if (t2 >= 0.0) {',
    '      point = p2;',
    '      return t2;',
    '    }',
    '    return -1.0;',
    '  }',
    '  float get_sphere_point(in vec3 pixelPosEye, out vec3 point) {',
    // transform camera pos into sphere local coords
    '    vec4 v = invModelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);',
    '    vec3 origin = (v.xyz - instOffset.xyz) / instOffset.w;',
    // transform (camera -> pixel) ray into cylinder local coords
    '    v = invModelViewMatrix * vec4(pixelPosEye, 0.0);',
    '    vec3 ray = normalize(v.xyz);',
    '    return intersect_ray_sphere(origin, ray, point);',
    '  }',
    '#endif',
    '#ifdef CYLINDER_SPRITE',
    '  uniform mat4 modelViewMatrix;',
    '  uniform mat4 invModelViewMatrix;',
    '  uniform mat3 normalMatrix;',
    '  varying vec4 matVec1;',
    '  varying vec4 matVec2;',
    '  varying vec4 matVec3;',
    '  varying vec4 invmatVec1;',
    '  varying vec4 invmatVec2;',
    '  varying vec4 invmatVec3;',
    '  float intersect_ray_cylinder(in vec3 origin, in vec3 ray, out vec3 point) {',
    // intersect XZ-projected ray with circle
    '    float a = dot(ray.xz, ray.xz);',
    '    float b = dot(ray.xz, origin.xz);',
    '    float c = dot(origin.xz, origin.xz) - 1.0;',
    '    float det = b * b - a * c;',
    '    if (det < 0.0) return -1.0;',
    '    float t1 = (-b - sqrt(det)) / a;',
    '    float t2 = (-b + sqrt(det)) / a;',
    // calculate both intersection points
    '    vec3 p1 = origin + ray * t1;',
    '    vec3 p2 = origin + ray * t2;',
    // choose nearest point
    '    float halfHeight = 0.5;',
    '    if (t1 >= 0.0 && p1.y >= -halfHeight && p1.y <= halfHeight) {',
    '      point = p1;',
    '      return t1;',
    '    }',
    '    if (t2 >= 0.0 && p2.y >= -halfHeight && p2.y <= halfHeight) {',
    '      point = p2;',
    '      return t2;',
    '    }',
    '    return -1.0;',
    '  }',
    '  float get_cylinder_point(in vec3 pixelPosEye, out vec3 point) {',
    // transform camera pos into cylinder local coords
    '    vec4 v = invModelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);',
    '    vec3 origin = vec3(' + '      dot(v, invmatVec1), ' + '      dot(v, invmatVec2), ' + '      dot(v, invmatVec3));',
    // transform (camera -> pixel) ray into cylinder local coords
    '    v = invModelViewMatrix * vec4(pixelPosEye, 0.0);',
    '    vec3 ray = vec3(' + '      dot(v, invmatVec1), ' + '      dot(v, invmatVec2), ' + '      dot(v, invmatVec3));',
    '    ray = normalize(ray);',
    '    return intersect_ray_cylinder(origin, ray, point);',
    '  }',
    '#endif',
    '#if defined(ATTR_COLOR) && !defined(USE_COLOR)',
    '  #define USE_COLOR',
    '#endif',
    '#ifdef ATTR_COLOR2',
    '  varying vec3 vColor2;',
    '  #ifndef INTERPOLATE_UV',
    '    #define INTERPOLATE_UV',
    '  #endif',
    '#endif',
    '#ifdef INTERPOLATE_UV',
    '\tvarying vec2 vUv;',
    '#endif',
    'uniform vec3 diffuse;',
    'uniform vec3 fixedColor;',
    'uniform vec3 emissive;',
    'uniform vec3 specular;',
    'uniform float shininess;',
    'uniform float opacity;',
    'uniform float zClipValue;',
    '#include <common>',
    '#include <color_pars_fragment>',
    '#include <uv_pars_fragment>',
    '#include <uv2_pars_fragment>',
    '#include <map_pars_fragment>',
    '#include <alphamap_pars_fragment>',
    '#include <aomap_pars_fragment>',
    '#include <lightmap_pars_fragment>',
    '#include <emissivemap_pars_fragment>',
    '#include <envmap_pars_fragment>',
    '#include <fog_pars_fragment>',
    '#include <bsdfs>',
    '#include <lights_pars>',
    '#include <lights_phong_pars_fragment>',
    '#include <shadowmap_pars_fragment>',
    '#include <bumpmap_pars_fragment>',
    '#include <normalmap_pars_fragment>',
    '#include <specularmap_pars_fragment>',
    '#include <logdepthbuf_pars_fragment>',
    'void main() {',
    '#ifdef ZCLIP',
    '  if (vViewPosition.z < zClipValue) discard;',
    '#endif',
    '#ifdef SPHERE_SPRITE',
    'vec4 pixelPosEye;',
    'vec3 normal;',
    /* quick-and-dirty method
        '  normal.xy = ' + INSTANCED_SPRITE_OVERSCALE + ' * (2.0 * vUv - 1.0);',
        '  float r2 = dot(normal.xy, normal.xy);',
        '  if (r2 > 1.0) discard; ',
        '  float normalZ = sqrt(1.0 - r2);',
        '  normal.z = normalZ;',
        '  normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );',
        '  pixelPosEye = vec4(spritePosEye.xyz, 1.0);',
        '  pixelPosEye.z += spritePosEye.w * normalZ;',
    */
    // ray-trace sphere surface
    '  {',
    '    vec3 p;',
    '    if (get_sphere_point(-vViewPosition, p) < 0.0) discard;',
    // pixelPosEye = modelViewMatrix * vec4(instOffset.xyz + p * instOffset.w, 1.0);
    '    pixelPosEye = vec4(spritePosEye.xyz, 1.0);',
    '    pixelPosEye.z += instOffset.w *' + '      (modelViewMatrix[0][2] * p.x +' + '       modelViewMatrix[1][2] * p.y +' + '       modelViewMatrix[2][2] * p.z);',
    '    normal = normalize(normalMatrix * p);',
    '  }',
    '#endif',
    '#ifdef CYLINDER_SPRITE',
    '  vec4 pixelPosEye;',
    '  vec3 normal;',
    '  float cylinderY = 0.0;',
    // ray-trace cylinder surface
    '  {',
    '    vec3 p;',
    '    if (get_cylinder_point(-vViewPosition, p) < 0.0) discard;',
    '    cylinderY = 0.5 * (p.y + 1.0);',
    '    vec4 v = vec4(p, 1.0);',
    '    pixelPosEye = modelViewMatrix * vec4(' + '      dot(v, matVec1), ' + '      dot(v, matVec2), ' + '      dot(v, matVec3), 1.0);',
    '    vec3 localNormal = normalize(vec3(p.x, 0.0, p.z));',
    '    normal = vec3(' + '      dot(localNormal, matVec1.xyz), ' + '      dot(localNormal, matVec2.xyz), ' + '      dot(localNormal, matVec3.xyz));',
    '    normal = normalize(normalMatrix * normal);',
    '  }',
    '#endif',
    ' vec3 vertexColor = vColor;',
    '#ifdef ATTR_COLOR2',
    '  #ifdef CYLINDER_SPRITE',
    '    float colorCoef = cylinderY;',
    // cylinder parameter is calculated from ray-tracing
    '  #else',
    '    float colorCoef = vUv.y;',
    // cylinder parameter is interpolated as tex coord
    '  #endif',
    // choose either color or color2
    '  vertexColor = mix(vColor2, vColor, step(0.5, colorCoef));',
    '#endif',
    // negative red component is a special condition
    ' if (vertexColor.x < 0.0) discard;',
    ' float totalOpacity = opacity;',
    '#ifdef ATTR_ALPHA_COLOR',
    ' totalOpacity *= alphaCol;',
    '#endif',
    // discard fully transparent pixels
    ' if (totalOpacity == 0.0) discard;',
    '#ifdef FAKE_OPACITY',
    // discard pixels in checker pattern
    '  vec2 dm_coord = floor(gl_FragCoord.xy);',
    '  dm_coord = fract(dm_coord * 0.5);',
    '  if (totalOpacity < 1.0 && (dm_coord.x < 0.5 ^^ dm_coord.y < 0.5)) discard;',
    '  vec4 diffuseColor = vec4(diffuse, 1.0);',
    '#else',
    '  vec4 diffuseColor = vec4(diffuse, totalOpacity);',
    '#endif',
    '\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );',
    '\tvec3 totalEmissiveRadiance = emissive;',
    '\t#include <logdepthbuf_fragment>',
    '\t#include <map_fragment>',
    ' diffuseColor.rgb *= vertexColor;',
    // #include <color_fragment>
    '\t#include <alphamap_fragment>',
    '\t#include <alphatest_fragment>',
    '\t#include <specularmap_fragment>',
    '#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)',
    '\t#include <normal_fragment>',
    '#endif',
    '\t#include <emissivemap_fragment>',
    '\t#include <lights_phong_fragment>',
    '#ifdef USE_LIGHTS',
    '\t#include <lights_template>',
    '#else',
    '\treflectedLight.directDiffuse = material.diffuseColor;',
    '#endif',
    '\t#include <aomap_fragment>',
    '\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + ' + 'reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;',
    '\t#include <envmap_fragment>',
    '#ifdef OVERRIDE_COLOR',
    ' gl_FragColor = vec4(fixedColor, diffuseColor.a);',
    '#else',
    '\tgl_FragColor = vec4(outgoingLight, diffuseColor.a);',
    '#endif',
    '\t#include <premultiplied_alpha_fragment>',
    '\t#include <tonemapping_fragment>',
    '\t#include <encodings_fragment>',
    '\t#include <fog_fragment>',
    '#if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)',
    ' vec4 pixelPosScreen = projectionMatrix * pixelPosEye;',
    ' gl_FragDepthEXT = 0.5 * (pixelPosScreen.z / pixelPosScreen.w + 1.0) + zOffset;',
    '#endif',
    '}'
  ].join('\n');
  function UberMaterial(params) {
    THREE.ShaderMaterial.call(this);
    this.instancedPos = false;
    this.instancedMatrix = false;
    this.instancedSprite = false;
    this.attrColor = false;
    this.attrColor2 = false;
    this.attrAlphaColor = false;
    this.overrideColor = false;
    this.sphereSprite = false;
    this.cylinderSprite = false;
    this.zClip = false;
    this.fakeOpacity = false;
    this.transparent = true;
    // properties that convert to uniforms
    this.uberOptions = {
      diffuse: new THREE.Color(16777215),
      specular: new THREE.Color(1118481),
      shininess: 30,
      opacity: 1,
      fixedColor: new THREE.Color(16777215),
      zOffset: 0,
      zClipCoef: 2,
      zClipValue: 0,
      copy: function (source) {
        this.diffuse.copy(source.diffuse);
        this.specular.copy(source.specular);
        this.shininess = source.shininess;
        this.opacity = source.opacity;
        this.fixedColor.copy(source.fixedColor);
        this.zOffset = source.zOffset;
        this.zClipCoef = source.zClipCoef;
        this.zClipValue = source.zClipValue;
      }
    };
    // set default values
    THREE.ShaderMaterial.prototype.setValues.call(this, {
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      uniforms: THREE.UniformsUtils.clone(defaultUniforms),
      lights: true,
      fog: true,
      side: THREE.DoubleSide
    });
    this.setValues(params);
  }
  UberMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
  UberMaterial.prototype.constructor = UberMaterial;
  UberMaterial.prototype.copy = function (source) {
    THREE.ShaderMaterial.prototype.copy.call(this, source);
    this.instancedPos = source.instancedPos;
    this.instancedMatrix = source.instancedMatrix;
    this.instancedSprite = source.instancedSprite;
    this.attrColor = source.attrColor;
    this.attrColor2 = source.attrColor2;
    this.attrAlphaColor = source.attrAlphaColor;
    this.overrideColor = source.overrideColor;
    this.sphereSprite = source.sphereSprite;
    this.cylinderSprite = source.cylinderSprite;
    this.zClip = source.zClip;
    this.fakeOpacity = source.fakeOpacity;
    this.uberOptions.copy(source.uberOptions);
    return this;
  };
  // create copy of this material
  // its options are prototyped after this material's options
  UberMaterial.prototype.createInstance = function () {
    var inst = new UberMaterial();
    inst.copy(this);
    inst.uberOptions = Object.create(this.uberOptions);
    return inst;
  };
  UberMaterial.prototype.setValues = function (values) {
    if (typeof values === 'undefined') {
      return;
    }
    // set direct values
    THREE.ShaderMaterial.prototype.setValues.call(this, values);
    var defines = { PHONG: 1 };
    var extensions = {};
    if (this.instancedPos) {
      defines.INSTANCED_POS = 1;
    }
    if (this.instancedMatrix) {
      defines.INSTANCED_MATRIX = 1;
    }
    if (this.instancedSprite) {
      defines.INSTANCED_SPRITE = 1;
    }
    if (this.attrColor) {
      defines.ATTR_COLOR = 1;
    }
    if (this.attrColor2) {
      defines.ATTR_COLOR2 = 1;
    }
    if (this.attrAlphaColor) {
      defines.ATTR_ALPHA_COLOR = 1;
    }
    if (this.overrideColor) {
      defines.OVERRIDE_COLOR = 1;
    }
    if (this.sphereSprite) {
      defines.SPHERE_SPRITE = 1;
      extensions.fragDepth = 1;
    }
    if (this.cylinderSprite) {
      defines.CYLINDER_SPRITE = 1;
      extensions.fragDepth = 1;
    }
    if (this.zClip) {
      defines.ZCLIP = 1;
    }
    if (this.fakeOpacity) {
      defines.FAKE_OPACITY = 1;
    }
    if (this.lights) {
      defines.USE_LIGHTS = 1;
    }
    // set dependent values
    this.defines = defines;
    this.extensions = extensions;
  };
  UberMaterial.prototype.setUberOptions = function (values) {
    if (typeof values === 'undefined') {
      return;
    }
    for (var key in values) {
      if (!values.hasOwnProperty(key)) {
        continue;
      }
      if (this.uberOptions[key] instanceof THREE.Color) {
        this.uberOptions[key] = values[key].clone();
      } else {
        this.uberOptions[key] = values[key];
      }
    }
  };
  UberMaterial.prototype.updateUniforms = function () {
    var self = this;
    uberOptionNames.forEach(function (p) {
      if (self.uniforms.hasOwnProperty(p)) {
        if (self.uberOptions[p] instanceof THREE.Color) {
          self.uniforms[p].value = self.uberOptions[p].clone();
        } else {
          self.uniforms[p].value = self.uberOptions[p];
        }
      }
    });
    this.transparent = true;
  };
  return UberMaterial;
}(three);
gfx_modes_BufferGeometryWrapper32 = function (THREE, gfxutils, utils) {
  function BufferGeometryWrapper32(chunkSize, facesPerChunk, chunksCount, material) {
    var pointsCount = chunksCount * chunkSize;
    this._positions = utils.allocateTyped(Float32Array, pointsCount * 3);
    this._colors = utils.allocateTyped(Float32Array, pointsCount * 3);
    this._normals = utils.allocateTyped(Float32Array, pointsCount * 3);
    this._alpha = utils.allocateTyped(Float32Array, pointsCount);
    gfxutils.fillArray(this._alpha, 1);
    var ArrayType = pointsCount > 65536 ? Uint32Array : Uint16Array;
    this._indices = utils.allocateTyped(ArrayType, chunksCount * facesPerChunk * 3);
    this._material = material;
    this._material.vertexColors = THREE.VertexColors;
    this._chunkSize = chunkSize;
    this._facesPerChunk = facesPerChunk;
    this._indexArray = utils.allocateTyped(ArrayType, facesPerChunk * 3);
    this._startIdx = 0;
    this._faceIdx = 0;
    this._currChunkColor = null;
    this._mesh = null;
  }
  BufferGeometryWrapper32.prototype = {
    constructor: BufferGeometryWrapper32,
    // Chunk is monochromatic
    startChunk: function (color) {
      this._currChunkColor = color;
    },
    setPosition: function (inChunkIdx, pos) {
      var positions = this._positions;
      var vtxIdx = this._startIdx + inChunkIdx;
      positions[vtxIdx * 3] = pos.x;
      positions[vtxIdx * 3 + 1] = pos.y;
      positions[vtxIdx * 3 + 2] = pos.z;
    },
    setChunkPositions: function (posArray) {
      this._positions.set(posArray, this._startIdx * 3);
    },
    setNormal: function (inChunkIdx, normal) {
      var normals = this._normals;
      var vtxIdx = this._startIdx + inChunkIdx;
      normals[vtxIdx * 3] = normal.x;
      normals[vtxIdx * 3 + 1] = normal.y;
      normals[vtxIdx * 3 + 2] = normal.z;
    },
    setChunkNormals: function (normalsArray) {
      this._normals.set(normalsArray, this._startIdx * 3);
    },
    setFace: function (inChunkIdx, currFace) {
      var faceIdx = this._faceIdx + inChunkIdx;
      var indices = this._indices;
      var startIdx = this._startIdx;
      indices[faceIdx * 3] = startIdx + currFace.a;
      indices[faceIdx * 3 + 1] = startIdx + currFace.b;
      indices[faceIdx * 3 + 2] = startIdx + currFace.c;
    },
    setChunkIndex: function (indexArray) {
      var tmpArray = this._indexArray;
      var startIdx = this._startIdx;
      var idcSize = this._facesPerChunk * 3;
      for (var i = 0; i < idcSize; ++i) {
        tmpArray[i] = indexArray[i] + startIdx;
      }
      this._indices.set(tmpArray, this._faceIdx * 3);
    },
    endChunk: function () {
      var chunkSize = this._chunkSize;
      var colors = this._colors;
      var color = new THREE.Color(this._currChunkColor);
      for (var vtxIdx = this._startIdx, endIdx = this._startIdx + chunkSize; vtxIdx < endIdx; ++vtxIdx) {
        colors[vtxIdx * 3] = color.r;
        colors[vtxIdx * 3 + 1] = color.g;
        colors[vtxIdx * 3 + 2] = color.b;
      }
      this._startIdx += this._chunkSize;
      this._faceIdx += this._facesPerChunk;
    },
    getObjects: function () {
      var geo = new THREE.BufferGeometry();
      geo.setIndex(new THREE.BufferAttribute(this._indices, 1));
      geo.addAttribute('position', new THREE.BufferAttribute(this._positions, 3));
      geo.addAttribute('normal', new THREE.BufferAttribute(this._normals, 3));
      geo.addAttribute('color', new THREE.BufferAttribute(this._colors, 3));
      geo.addAttribute('alphaColor', new THREE.BufferAttribute(this._alpha, 1));
      geo.computeBoundingSphere();
      this._indices = null;
      this._positions = null;
      this._normals = null;
      this._colors = null;
      this._mesh = new THREE.Mesh(geo, this._material);
      return this._mesh;
    },
    raycast: function (raycaster, intersects) {
      //this._geomWrapper.raycast(raycaster, intersects);
      console.assert(this._mesh, 'DEBUG: BufferGeometryWrapper 32 mesh is null, however raycast was called.');
      var inters = [];
      this._mesh.updateMatrixWorld();
      this._mesh.raycast(raycaster, inters);
      var facesPerChunk = this._facesPerChunk;
      for (var i = 0, n = inters.length; i < n; ++i) {
        if (!inters[i].hasOwnProperty('faceIndex')) {
          continue;
        }
        inters[i].chunkIdx = Math.floor(inters[i].faceIndex / facesPerChunk);
        intersects.push(inters[i]);
      }
    },
    getSubset: function (chunkIndices) {
      var chunkSize = this._chunkSize;
      var chunksCount = chunkIndices.length;
      var pointsCount = chunksCount * chunkSize;
      var geo = this._mesh.geometry;
      var positions = utils.allocateTyped(Float32Array, pointsCount * 3);
      var colors = utils.allocateTyped(Float32Array, pointsCount * 3);
      var normals = utils.allocateTyped(Float32Array, pointsCount * 3);
      var alpha = utils.allocateTyped(Float32Array, pointsCount);
      gfxutils.fillArray(alpha, 1);
      var facesPerChunk = this._facesPerChunk;
      var origPositions = geo.getAttribute('position').array;
      var origNormals = geo.getAttribute('normal').array;
      var origColors = geo.getAttribute('color').array;
      var origIndex = geo.getIndex().array;
      var ArrayType = origPositions.length / 3 > 65536 ? Uint32Array : Uint16Array;
      var indices = utils.allocateTyped(ArrayType, chunksCount * facesPerChunk * 3);
      for (var i = 0; i < chunksCount; ++i) {
        // copy point information
        var dstPtOffset = i * chunkSize * 3;
        var ptIdxBegin = chunkIndices[i] * chunkSize * 3;
        var ptIdxEnd = ptIdxBegin + chunkSize * 3;
        positions.set(origPositions.subarray(ptIdxBegin, ptIdxEnd), dstPtOffset);
        colors.set(origColors.subarray(ptIdxBegin, ptIdxEnd), dstPtOffset);
        normals.set(origNormals.subarray(ptIdxBegin, ptIdxEnd), dstPtOffset);
        // copy triangles information
        var dstFaceOffset = i * facesPerChunk * 3;
        var trIdxBegin = i * facesPerChunk * 3;
        var trIdxEnd = trIdxBegin + facesPerChunk * 3;
        var arr = origIndex.subarray(trIdxBegin, trIdxEnd);
        indices.set(arr, dstFaceOffset);
      }
      geo = new THREE.BufferGeometry();
      geo.setIndex(new THREE.BufferAttribute(indices, 1));
      geo.addAttribute('position', new THREE.BufferAttribute(positions, 3));
      geo.addAttribute('normal', new THREE.BufferAttribute(normals, 3));
      geo.addAttribute('color', new THREE.BufferAttribute(colors, 3));
      geo.addAttribute('alphaColor', new THREE.BufferAttribute(alpha, 1));
      geo.computeBoundingSphere();
      return [new THREE.Mesh(geo, this._material)];
    },
    setOpacity: function (chunkIndices, value) {
      if (this._mesh === null || !this._mesh.geometry) {
        return;
      }
      var chunkSize = this._chunkSize;
      var geom = this._mesh.geometry;
      var alphaArr = geom.getAttribute('alphaColor').array;
      for (var i = 0, n = chunkIndices.length; i < n; ++i) {
        var vtxStart = chunkIndices[i] * chunkSize;
        var vtxEnd = (chunkIndices[i] + 1) * chunkSize;
        for (var vtxIndex = vtxStart; vtxIndex < vtxEnd; ++vtxIndex) {
          alphaArr[vtxIndex] = value;
        }
      }
      geom.getAttribute('alphaColor').needsUpdate = true;
    }
  };
  return BufferGeometryWrapper32;
}(three, gfx_gfxutils, utils);
gfx_modes_InstancedSphereBuilder = function (THREE, settings, gfxutils, UberMaterial, Geom32Wrapper, SphereCollisionGeo, utils) {
  function InstancedSphereBuilder(sphereGeometry, instanceCount, material) {
    this._sphGeometry = sphereGeometry;
    this._offsets = new THREE.InstancedBufferAttribute(utils.allocateTyped(Float32Array, instanceCount * 4), 4, 1);
    this._colors = new THREE.InstancedBufferAttribute(utils.allocateTyped(Float32Array, instanceCount * 3), 3, 1);
    var alpha = utils.allocateTyped(Float32Array, instanceCount);
    gfxutils.fillArray(alpha, 1);
    this._alpha = new THREE.InstancedBufferAttribute(alpha, 1, 1);
    this._material = material.createInstance();
    var matParams = {
      instancedPos: true,
      attrColor: true,
      attrAlphaColor: true
    };
    if (settings.now.zSprites) {
      matParams.instancedSprite = true;
      matParams.sphereSprite = true;
    }
    this._material.setValues(matParams);
    // prepare collision geometry
    this._collisionGeo = new SphereCollisionGeo(instanceCount);
    this._mesh = null;
  }
  InstancedSphereBuilder.prototype = {
    constructor: InstancedSphereBuilder,
    addItem: function (itemIdx, itemPos, itemRad, colorVal) {
      var color = new THREE.Color(colorVal);
      this._offsets.setXYZW(itemIdx, itemPos.x, itemPos.y, itemPos.z, itemRad);
      this._colors.setXYZ(itemIdx, color.r, color.g, color.b);
      this._collisionGeo.addSphere(itemIdx, itemPos, itemRad);
    },
    getObjects: function () {
      var geom = new THREE.InstancedBufferGeometry().copy(this._sphGeometry);
      this._collisionGeo.computeBoundingSphere();
      geom.addAttribute('offset', this._offsets);
      geom.addAttribute('color', this._colors);
      geom.addAttribute('alphaColor', this._alpha);
      geom.boundingSphere = this._collisionGeo.boundingSphere;
      var mesh = new THREE.Mesh(geom, this._material);
      this._mesh = mesh;
      return mesh;
    },
    raycast: function (raycaster, intersects) {
      if (this._mesh === null) {
        return;
      }
      this._collisionGeo.raycast(this._mesh.matrixWorld, raycaster, intersects);
    },
    getSubset: function (chunkIndices) {
      var instanceCount = chunkIndices.length;
      var alpha = utils.allocateTyped(Float32Array, instanceCount);
      gfxutils.fillArray(alpha, 1);
      var alphaAttr = new THREE.InstancedBufferAttribute(alpha, 1, 1);
      var offsets = new THREE.InstancedBufferAttribute(utils.allocateTyped(Float32Array, instanceCount * 4), 4, 1);
      var colors = new THREE.InstancedBufferAttribute(utils.allocateTyped(Float32Array, instanceCount * 3), 3, 1);
      var geom = new THREE.InstancedBufferGeometry().copy(this._sphGeometry);
      offsets.copyAtList(this._offsets, chunkIndices);
      colors.copyAtList(this._colors, chunkIndices);
      geom.addAttribute('offset', offsets);
      geom.addAttribute('color', colors);
      geom.addAttribute('alphaColor', alphaAttr);
      geom.boundingSphere = this._collisionGeo.boundingSphere;
      return [new THREE.Mesh(geom, this._material)];
    },
    setOpacity: function (chunkIndices, value) {
      if (this._mesh === null || !this._mesh.geometry) {
        return;
      }
      var geom = this._mesh.geometry;
      var alphaArr = geom.getAttribute('alphaColor').array;
      for (var i = 0, n = chunkIndices.length; i < n; ++i) {
        alphaArr[chunkIndices[i]] = value;
      }
      geom.getAttribute('alphaColor').needsUpdate = true;
    }
  };
  return InstancedSphereBuilder;
}(three, settings, gfx_gfxutils, gfx_shaders_UberMaterial, gfx_modes_BufferGeometryWrapper32, gfx_modes_SphereCollisionGeo, utils);
gfx_modes_buildCrossAtoms = function (THREE, settings, SphereCollisionGeo, SphereBuilder) {
  function CrossGroup(CrossBuilderName, component, colorer, mode, mask, material) {
    THREE.Group.call(this);
    var complex = component.getComplex();
    complex.propagateAtoms();
    this._component = component;
    this._collisionGeo = null;
    this._atomRad = mode.calcAtomRadius();
    this._crossAtomsIdc = null;
    this._builder = null;
    this._mesh = this;
    this._material = material;
    this._selMaterial = this.initSelectionMaterial();
    var orphanedAtomsGeo = this._createOrphanedAtomsGeo(CrossBuilderName, mask, colorer, material);
    if (orphanedAtomsGeo !== null) {
      this.add(orphanedAtomsGeo);
      this._mesh = orphanedAtomsGeo;
    }
    this._prerareCollisionGeo(mask);
  }
  CrossGroup.prototype = Object.create(THREE.Group.prototype);
  CrossGroup.prototype.constructor = CrossGroup;
  CrossGroup.prototype.initSelectionMaterial = function () {
    var mat = this._material.createInstance();
    mat.setValues({
      transparent: false,
      fog: true,
      side: THREE.DoubleSide
    });
    mat.setUberOptions({
      specular: new THREE.Color(1381653),
      shininess: 30
    });
    return mat;
  };
  CrossGroup.prototype._createOrphanedAtomsGeo = function (CrossBuilder, mask, colorer, material) {
    var component = this._component;
    var atomsCount = 0;
    function checkAtom(atom) {
      if (!(atom._mask & mask)) {
        return false;
      }
      if (settings.now.labels !== 'no' && atom.isLabelVisible()) {
        return false;
      }
      var bonds = atom._bonds;
      for (var i = 0, n = bonds.length; i < n; ++i) {
        if (bonds[i]._left._mask & mask || bonds[i]._right._mask & mask) {
          return false;
        }
      }
      return true;
    }
    var crossAtomIdc = [];
    this._crossAtomsIdc = crossAtomIdc;
    component.forEachAtom(function (atom) {
      if (checkAtom(atom)) {
        ++atomsCount;
        crossAtomIdc.push(atom._index);
      }
    });
    if (atomsCount === 0) {
      return null;
    }
    var builder = new CrossBuilder(atomsCount, material);
    this._builder = builder;
    var self = this;
    var complex = component.getComplex();
    for (var i = 0; i < atomsCount; ++i) {
      var atom = complex._atoms[crossAtomIdc[i]];
      builder.addItem(i, atom._position, self._atomRad, colorer.getAtomColor(atom, complex));
    }
    return builder.getObjects();
  };
  CrossGroup.prototype._prerareCollisionGeo = function (mask) {
    var component = this._component;
    var atomCount = 0;
    component.forEachAtom(function (atom) {
      if (!(atom._mask & mask)) {
        return;
      }
      ++atomCount;
    });
    if (atomCount === 0) {
      return;
    }
    this._collisionAtomsIdc = new Array(atomCount);
    var atomsIdc = this._collisionAtomsIdc;
    this._collisionGeo = new SphereCollisionGeo(atomCount);
    var collisionGeo = this._collisionGeo;
    var currAtomIdx = 0;
    var rad = this._atomRad;
    component.forEachAtom(function (atom) {
      if (!(atom._mask & mask)) {
        return;
      }
      collisionGeo.addSphere(currAtomIdx, atom._position, rad);
      atomsIdc[currAtomIdx++] = atom._index;
    });
  };
  CrossGroup.prototype.raycast = function (raycaster, intersects) {
    var geo = this._collisionGeo;
    if (geo === null || this._mesh === null) {
      return;
    }
    var inters = [];
    this._collisionGeo.raycast(this._mesh.matrixWorld, raycaster, inters);
    var atoms = this._component._complex._atoms;
    var atomsIdc = this._collisionAtomsIdc;
    // process inters array - arr object references
    for (var i = 0, n = inters.length; i < n; ++i) {
      if (!inters[i].hasOwnProperty('chunkIdx')) {
        continue;
      }
      var atomIdx = atomsIdc[inters[i].chunkIdx];
      if (atomIdx < atoms.length) {
        inters[i].atom = atoms[atomIdx];
        intersects.push(inters[i]);
      }
    }
  };
  CrossGroup.prototype._calcChunksList = function (mask) {
    if (this._crossAtomsIdc === null) {
      return [];
    }
    var chunksList = [];
    var atoms = this._component.getComplex()._atoms;
    var atomsIdc = this._crossAtomsIdc;
    for (var i = 0, n = atomsIdc.length; i < n; ++i) {
      var atom = atoms[atomsIdc[i]];
      if (atom._mask & mask) {
        chunksList.push(i);
      }
    }
    return chunksList;
  };
  CrossGroup.prototype._getSelSubset = function (mask) {
    var component = this._component;
    var atomCount = 0;
    component.forEachAtom(function (atom) {
      if (!(atom._mask & mask)) {
        return;
      }
      ++atomCount;
    });
    if (atomCount === 0) {
      return [];
    }
    var polyComplexity = 4;
    var useSprites = settings.now.zSprites;
    var geo = useSprites ? new THREE.PlaneBufferGeometry(2, 2, 1, 1) : new THREE.SphereBufferGeometry(1, polyComplexity * 2, polyComplexity, 0, Math.PI * 2, 0, Math.PI);
    var builder = new SphereBuilder(geo, atomCount, this._selMaterial);
    var currAtomIdx = 0;
    var atomRad = this._atomRad;
    component.forEachAtom(function (atom) {
      if (!(atom._mask & mask)) {
        return;
      }
      builder.addItem(currAtomIdx++, atom._position, atomRad, 0);
    });
    var selObjects = builder.getObjects();
    selObjects._component = this._component;
    return [selObjects];
  };
  CrossGroup.prototype.getSubset = function (mask) {
    // selection
    var selSubset = this._getSelSubset(mask);
    // crosses
    var chunksList = this._calcChunksList(mask);
    if (chunksList.length === 0) {
      return selSubset;
    }
    var selObjects = this._builder.getSubset(chunksList);
    for (var objIdx = 0, objCount = selObjects.length; objIdx < objCount; ++objIdx) {
      selObjects[objIdx]._component = this._component;
      selSubset.push(selObjects[objIdx]);
    }
    return selSubset;
  };
  CrossGroup.prototype._changeSubsetOpacity = function (mask, value) {
    var chunksList = this._calcChunksList(mask);
    if (chunksList.length === 0) {
      return;
    }
    this._builder.setOpacity(chunksList, value);
  };
  CrossGroup.prototype.enableSubset = function (mask) {
    this._changeSubsetOpacity(mask, 1);
  };
  CrossGroup.prototype.disableSubset = function (mask) {
    this._changeSubsetOpacity(mask, 0);
  };
  function buildBondLines(CrossBuilderName, component, colorer, mode, _polyComplexity, mask, material) {
    return new CrossGroup(CrossBuilderName, component, colorer, mode, mask, material);
  }
  return buildBondLines;
}(three, settings, gfx_modes_SphereCollisionGeo, gfx_modes_InstancedSphereBuilder);
gfx_modes_ChunkedLineBuilder = function (THREE, gfxutils, utils) {
  function ChunkedLinesBuilder(instanceCount, chunkSize, material) {
    this._chunkSize = chunkSize;
    this._positions = new THREE.BufferAttribute(utils.allocateTyped(Float32Array, instanceCount * chunkSize * 3), 3);
    this._colors = new THREE.BufferAttribute(utils.allocateTyped(Float32Array, instanceCount * chunkSize * 3), 3);
    this._opacity = new THREE.BufferAttribute(utils.allocateTyped(Float32Array, instanceCount * chunkSize), 1);
    var matParams = {
      lights: false,
      vertexColors: THREE.VertexColors,
      attrAlphaColor: true
    };
    this._chunkIndex = 0;
    this._material = material.createInstance();
    this._material.setValues(matParams);
    this._mesh = null;
  }
  ChunkedLinesBuilder.prototype = {
    constructor: ChunkedLinesBuilder,
    startChunk: function (chunkIdx, colorVal, opacity) {
      var vtxIdx = chunkIdx * this._chunkSize;
      var endIdx = vtxIdx + this._chunkSize;
      var color = new THREE.Color(colorVal);
      var colors = this._colors;
      var opacityAttr = this._opacity;
      this._chunkIndex = chunkIdx;
      for (; vtxIdx < endIdx; ++vtxIdx) {
        colors.setXYZ(vtxIdx, color.r, color.g, color.b);
        opacityAttr.setX(vtxIdx, opacity);
      }
    },
    setVertex: function (vertexIndex, position) {
      this._positions.setXYZ(this._chunkSize * this._chunkIndex + vertexIndex, position.x, position.y, position.z);
    },
    getObjects: function () {
      var geometry = new THREE.BufferGeometry();
      geometry.addAttribute('position', this._positions);
      geometry.addAttribute('color', this._colors);
      geometry.addAttribute('alphaColor', this._opacity);
      geometry.computeBoundingSphere();
      this._geometry = geometry;
      this._mesh = new THREE.LineSegments(this._geometry, this._material);
      return this._mesh;
    },
    setOpacity: function (chunkIndices, value) {
      if (this._mesh === null || !this._mesh.geometry) {
        return;
      }
      var chunkSize = this._chunkSize;
      var geom = this._mesh.geometry;
      var alphaArr = geom.getAttribute('alphaColor').array;
      for (var i = 0, n = chunkIndices.length; i < n; ++i) {
        var vtxStart = chunkIndices[i] * chunkSize;
        var vtxEnd = (chunkIndices[i] + 1) * chunkSize;
        for (var vtxIndex = vtxStart; vtxIndex < vtxEnd; ++vtxIndex) {
          alphaArr[vtxIndex] = value;
        }
      }
      geom.getAttribute('alphaColor').needsUpdate = true;
    },
    getSubset: function (chunkIndices) {
      if (this._mesh === null || !this._mesh.geometry) {
        return [];
      }
      var chunkSize = this._chunkSize;
      var chunksCount = chunkIndices.length;
      var pointsCount = chunksCount * chunkSize;
      var geo = this._mesh.geometry;
      var positions = utils.allocateTyped(Float32Array, pointsCount * 3);
      var colors = utils.allocateTyped(Float32Array, pointsCount * 3);
      var alpha = utils.allocateTyped(Float32Array, pointsCount);
      gfxutils.fillArray(alpha, 1);
      var origPositions = geo.getAttribute('position').array;
      var origColors = geo.getAttribute('color').array;
      for (var i = 0; i < chunksCount; ++i) {
        // copy point information
        var dstPtOffset = i * chunkSize * 3;
        var ptIdxBegin = chunkIndices[i] * chunkSize * 3;
        var ptIdxEnd = ptIdxBegin + chunkSize * 3;
        positions.set(origPositions.subarray(ptIdxBegin, ptIdxEnd), dstPtOffset);
        colors.set(origColors.subarray(ptIdxBegin, ptIdxEnd), dstPtOffset);
      }
      geo = new THREE.BufferGeometry();
      geo.addAttribute('position', new THREE.BufferAttribute(positions, 3));
      geo.addAttribute('color', new THREE.BufferAttribute(colors, 3));
      geo.addAttribute('alphaColor', new THREE.BufferAttribute(alpha, 1));
      geo.computeBoundingSphere();
      return [new THREE.LineSegments(geo, this._material)];
    }
  };
  return ChunkedLinesBuilder;
}(three, gfx_gfxutils, utils);
gfx_modes_buildALoopsLines = function (THREE, settings, ChunkedLineBuilder) {
  function _slerp(omega, v1, v2, t) {
    var oSin = Math.sin(omega);
    return v1.clone().multiplyScalar(Math.sin((1 - t) * omega) / oSin).addScaledVector(v2, Math.sin(t * omega) / oSin);
  }
  function ALoopsLinesGroup(component, colorer, mode, polyComplexity, mask, material) {
    THREE.Group.call(this);
    this._component = component;
    var complex = component.getComplex();
    this._chunksToIdc = null;
    this._builder = null;
    var chunksCount = 0;
    if (!mode.showAromaticLoops()) {
      return;
    }
    component.forEachCycle(function (cycle) {
      var cycAtoms = cycle.atoms;
      console.assert(cycAtoms.length > 1);
      for (var i = 0, n = cycAtoms.length; i < n; ++i) {
        if (cycAtoms[i]._mask & mask) {
          ++chunksCount;
        }
      }
    });
    if (chunksCount === 0) {
      return;
    }
    var segmentsHeight = mode.getAromaticArcChunks();
    this._builder = new ChunkedLineBuilder(chunksCount, 2 * segmentsHeight, material);
    var builder = this._builder;
    this._chunksToIdc = new Array(chunksCount);
    var chunksToIdx = this._chunksToIdc;
    var chunkIdx = 0;
    var radOffset = mode.getAromaticOffset();
    var leprStep = 1 / segmentsHeight;
    component.forEachCycle(function (cycle) {
      var cycAtoms = cycle.atoms;
      var tmpDir = [];
      var center = cycle.center;
      var cycleRad = cycle.radius - radOffset;
      var n = cycAtoms.length;
      var i = 0;
      var prevPos = cycAtoms[n - 1]._position;
      var currPos = cycAtoms[i]._position;
      var prevVector = prevPos.clone().sub(center);
      var currVector = currPos.clone().sub(center);
      for (; i < n; ++i) {
        var omega = prevVector.angleTo(currVector);
        tmpDir.push(_slerp(omega, prevVector, currVector, 0.5).normalize());
        prevPos = currPos;
        currPos = cycAtoms[(i + 1) % n]._position;
        prevVector = currVector;
        currVector = currPos.clone().sub(center);
      }
      for (i = 0; i < n; ++i) {
        if (!(cycAtoms[i]._mask & mask)) {
          continue;
        }
        var start = tmpDir[i];
        var end = tmpDir[(i + 1) % n];
        var currAngle = start.angleTo(end);
        builder.startChunk(chunkIdx, colorer.getAtomColor(cycAtoms[i], complex), 1);
        var prevPt = _slerp(currAngle, start, end, 0).multiplyScalar(cycleRad).add(center);
        //do not replace with start
        for (var j = 1; j <= segmentsHeight; ++j) {
          var currPoint = _slerp(currAngle, start, end, j * leprStep).multiplyScalar(cycleRad).add(center);
          builder.setVertex(2 * j - 2, prevPt);
          builder.setVertex(2 * j - 1, currPoint);
          prevPt = currPoint;
        }
        chunksToIdx[chunkIdx++] = cycAtoms[i]._index;
      }
    });
    this.add(builder.getObjects());
  }
  ALoopsLinesGroup.prototype = Object.create(THREE.Group.prototype);
  ALoopsLinesGroup.prototype.constructor = ALoopsLinesGroup;
  ALoopsLinesGroup.prototype._calcChunksList = function (mask) {
    if (this._chunksToIdc === null) {
      return [];
    }
    var chunksList = [];
    var atoms = this._component.getComplex()._atoms;
    var atomsIdc = this._chunksToIdc;
    for (var i = 0, n = atomsIdc.length; i < n; ++i) {
      var atom = atoms[atomsIdc[i]];
      if (atom._mask & mask) {
        chunksList.push(i);
      }
    }
    return chunksList;
  };
  ALoopsLinesGroup.prototype.getSubset = function (mask) {
    var chunksList = this._calcChunksList(mask);
    if (chunksList.length === 0) {
      return [];
    }
    var selObjects = this._builder.getSubset(chunksList);
    for (var objIdx = 0, objCount = selObjects.length; objIdx < objCount; ++objIdx) {
      selObjects[objIdx]._component = this._component;
    }
    return selObjects;
  };
  ALoopsLinesGroup.prototype._changeSubsetOpacity = function (mask, value) {
    var chunksList = this._calcChunksList(mask);
    if (chunksList.length === 0) {
      return;
    }
    this._builder.setOpacity(chunksList, value);
  };
  ALoopsLinesGroup.prototype.enableSubset = function (mask) {
    this._changeSubsetOpacity(mask, 1);
  };
  ALoopsLinesGroup.prototype.disableSubset = function (mask) {
    this._changeSubsetOpacity(mask, 0);
  };
  function buildALoopsLines(complex, colorer, mode, polyComplexity, mask, material) {
    return new ALoopsLinesGroup(complex, colorer, mode, polyComplexity, mask, material);
  }
  return buildALoopsLines;
}(three, settings, gfx_modes_ChunkedLineBuilder);
gfx_modes_ChunkedObjectBuilder = function (THREE, utils) {
  var COMPS_PER_TRIANGLE = 3;
  var COMPS_PER_VERTEX = 3;
  function simpleArrayHelper(array) {
    return function () {
      return array;
    };
  }
  function processedArrayHelper(array, processor) {
    if (processor === null) {
      return simpleArrayHelper(array);
    }
    var vecCount = array.length / COMPS_PER_VERTEX | 0;
    var vectorArray = new Array(vecCount);
    var tmpArray = utils.allocateTyped(Float32Array, array.length);
    for (var i = 0; i < vecCount; ++i) {
      vectorArray[i] = new THREE.Vector3(0, 0, 0).fromArray(array, i * COMPS_PER_VERTEX);
    }
    return function () {
      for (var idx = 0; idx < vecCount; ++idx) {
        var vtx = processor(vectorArray[idx]);
        var offset = idx * COMPS_PER_VERTEX;
        tmpArray[offset] = vtx.x;
        tmpArray[offset + 1] = vtx.y;
        tmpArray[offset + 2] = vtx.z;
      }
      return tmpArray;
    };
  }
  function ChunkedObjectBuilder(GeometryWrapper, chunkGeometry, instanceCount, vertexProcessor, normalProcessor, material) {
    this._ptsPerChunk = chunkGeometry.getAttribute('position').count;
    this._facesPerChunk = chunkGeometry.index.count / COMPS_PER_TRIANGLE | 0;
    this.indexHelper = simpleArrayHelper(chunkGeometry.index.array);
    this.posHelper = processedArrayHelper(chunkGeometry.getAttribute('position').array, vertexProcessor);
    this.normalHelper = processedArrayHelper(chunkGeometry.getAttribute('normal').array, normalProcessor);
    var newMat = material.createInstance();
    var matParams = { attrAlphaColor: true };
    newMat.setValues(matParams);
    this._geomWrapper = new GeometryWrapper(this._ptsPerChunk, this._facesPerChunk, instanceCount, newMat);
  }
  ChunkedObjectBuilder.prototype = {
    constructor: ChunkedObjectBuilder,
    addItem: function (itemIdx, colorVal) {
      var geomWrapper = this._geomWrapper;
      geomWrapper.startChunk(colorVal);
      geomWrapper.setChunkPositions(this.posHelper());
      geomWrapper.setChunkNormals(this.normalHelper());
      geomWrapper.setChunkIndex(this.indexHelper());
      geomWrapper.endChunk();
    },
    raycast: function (raycaster, intersects) {
      this._geomWrapper.raycast(raycaster, intersects);
    },
    getObjects: function () {
      return this._geomWrapper.getObjects();
    },
    getSubset: function (chunkIndices) {
      return this._geomWrapper.getSubset(chunkIndices);
    },
    setOpacity: function (chunkIndices, value) {
      this._geomWrapper.setOpacity(chunkIndices, value);
    }
  };
  return ChunkedObjectBuilder;
}(three, utils);
gfx_modes_SimpleCylinderBuilder = function (THREE, ObjectBuilder, gfxutils) {
  function vertexProcessor(helperData) {
    return function (vertex) {
      return vertex.clone().applyMatrix4(helperData.mtx);
    };
  }
  function normalProcessor(helperData) {
    return function (normal) {
      return normal.clone().applyMatrix3(helperData.normalMatrix);
    };
  }
  function SimpleCylinderBuilder(GeomWrapper, chunkGeometry, instanceCount, material) {
    this.helperData = {};
    this._objBuilder = new ObjectBuilder(GeomWrapper, chunkGeometry, instanceCount * 2, vertexProcessor(this.helperData), normalProcessor(this.helperData), material);
  }
  SimpleCylinderBuilder.prototype = {
    constructor: SimpleCylinderBuilder,
    addItem: function (itemIdx, botPos, topPos, itemRad, colorVal1, colorVal2) {
      var centerPos = botPos.clone().lerp(topPos, 0.5);
      // 1st cylinder
      var mtx1 = gfxutils.calcCylinderMatrix(botPos, centerPos, itemRad);
      var normMtx1 = new THREE.Matrix3().getNormalMatrix(mtx1);
      this.helperData.mtx = mtx1;
      this.helperData.normalMatrix = normMtx1;
      this._objBuilder.addItem(2 * itemIdx, colorVal1);
      // 2nd cylinder
      mtx1.setPosition(centerPos.clone().lerp(topPos, 0.5));
      this._objBuilder.addItem(2 * itemIdx + 1, colorVal2);
    },
    getObjects: function () {
      return this._objBuilder.getObjects();
    },
    raycast: function (raycaster, intersects) {
      this._objBuilder.raycast(raycaster, intersects);
    },
    getSubset: function (chunkIndices) {
      return this._objBuilder.getSubset(chunkIndices);
    },
    setOpacity: function (chunkIndices, value) {
      this._geomWrapper.setOpacity(chunkIndices, value);
    }
  };
  SimpleCylinderBuilder.getMega = function (GeometryWrapper) {
    return function (a, b, c) {
      return new SimpleCylinderBuilder(GeometryWrapper, a, b, c);
    };
  };
  return SimpleCylinderBuilder;
}(three, gfx_modes_ChunkedObjectBuilder, gfx_gfxutils);
gfx_modes_CylinderBufferGeometry = function (THREE, utils) {
  var MAX_POINTS_COUNT_16BIT = 65536;
  var PTS_PER_TRIANGLE = 3;
  function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded) {
    THREE.BufferGeometry.call(this);
    var thetaStart = 0;
    var thetaLength = 2 * Math.PI;
    this.type = 'CylinderBufferGeometry';
    this.parameters = {
      radiusTop: radiusTop,
      radiusBottom: radiusBottom,
      height: height,
      radialSegments: radialSegments,
      heightSegments: heightSegments,
      openEnded: openEnded
    };
    var hasTop = openEnded === false && radiusTop > 0;
    var hasBottom = openEnded === false && radiusBottom > 0;
    var vertexCount = (heightSegments + 1) * radialSegments + hasTop * (radialSegments + 1) + hasBottom * (radialSegments + 1);
    var facesCount = (2 * heightSegments + hasTop + hasBottom) * radialSegments;
    var heightHalf = height / 2;
    /* eslint-disable no-magic-numbers */
    var positions = new THREE.BufferAttribute(utils.allocateTyped(Float32Array, vertexCount * 3), 3);
    var normals = new THREE.BufferAttribute(utils.allocateTyped(Float32Array, vertexCount * 3), 3);
    var indices = new THREE.Uint16Attribute(utils.allocateTyped(Uint16Array, facesCount * PTS_PER_TRIANGLE), 1);
    /* eslint-enable no-magic-numbers */
    var uvs = new THREE.BufferAttribute(utils.allocateTyped(Float32Array, vertexCount * 2), 2);
    console.assert(vertexCount < MAX_POINTS_COUNT_16BIT, 'DEBUG: Cylinder Geometry has too many vertices (65536 max).');
    var currVtxIdx = 0;
    var currFaceIdx = 0;
    var tanTheta = -(radiusBottom - radiusTop) / height;
    // setup cylinder data
    for (var y = 0; y <= heightSegments; y++) {
      // faces
      if (y !== heightSegments) {
        for (var i = 0; i < radialSegments; i++) {
          var v1 = currVtxIdx + i;
          var v2 = currVtxIdx + radialSegments + i;
          var v3 = currVtxIdx + radialSegments + (i + 1) % radialSegments;
          var v4 = currVtxIdx + (i + 1) % radialSegments;
          indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, v1, v4, v2);
          currFaceIdx++;
          indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, v2, v4, v3);
          currFaceIdx++;
        }
      }
      // vertices
      var v = y / heightSegments;
      var radius = v * (radiusBottom - radiusTop) + radiusTop;
      for (var x = 0; x < radialSegments; x++) {
        var u = x / radialSegments;
        var vx = radius * Math.sin(u * thetaLength + thetaStart);
        var vy = v * height - heightHalf;
        var vz = radius * Math.cos(u * thetaLength + thetaStart);
        var normal = new THREE.Vector3(vx, Math.sqrt(vx * vx + vz * vz) * tanTheta, vz).normalize();
        positions.setXYZ(currVtxIdx, vx, vy, vz);
        normals.setXYZ(currVtxIdx, normal.x, normal.y, normal.z);
        uvs.setXY(currVtxIdx, u, v);
        ++currVtxIdx;
      }
    }
    // top cap
    if (hasTop) {
      var startTIdx = currVtxIdx;
      var lastIdx = currVtxIdx + radialSegments;
      for (var fTIdx = 0; fTIdx < radialSegments; ++fTIdx) {
        var currSrcIdx = currVtxIdx - radialSegments;
        positions.setXYZ(currVtxIdx, positions.getX(currSrcIdx), positions.getY(currSrcIdx), positions.getZ(currSrcIdx));
        normals.setXYZ(currVtxIdx, 0, 1, 0);
        uvs.setXY(currVtxIdx, 0, 0);
        var nextTVtx = startTIdx + (fTIdx + 1) % radialSegments;
        indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, currVtxIdx, nextTVtx, lastIdx);
        currFaceIdx++;
        currVtxIdx++;
      }
      positions.setXYZ(currVtxIdx, 0, heightHalf, 0);
      normals.setXYZ(currVtxIdx, 0, 1, 0);
      uvs.setXY(currVtxIdx, 0, 0);
      ++currVtxIdx;
    }
    // bottom cap
    if (hasBottom) {
      var startBIdx = currVtxIdx;
      var lastBIdx = currVtxIdx + radialSegments;
      for (var fBIdx = 0; fBIdx < radialSegments; ++fBIdx) {
        var currSrcBIdx = fBIdx;
        positions.setXYZ(currVtxIdx, positions.getX(currSrcBIdx), positions.getY(currSrcBIdx), positions.getZ(currSrcBIdx));
        normals.setXYZ(currVtxIdx, 0, -1, 0);
        uvs.setXY(currVtxIdx, 1, 1);
        var nextBVtx = startBIdx + (fBIdx + 1) % radialSegments;
        indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, nextBVtx, currVtxIdx, lastBIdx);
        currFaceIdx++;
        currVtxIdx++;
      }
      positions.setXYZ(currVtxIdx, 0, -heightHalf, 0);
      normals.setXYZ(currVtxIdx, 0, -1, 0);
      uvs.setXY(currVtxIdx, 1, 1);
    }
    this.setIndex(indices);
    this.addAttribute('position', positions);
    this.addAttribute('normal', normals);
    this.addAttribute('uv', uvs);
  }
  CylinderBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
  CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;
  CylinderBufferGeometry.prototype.clone = function () {
    var parameters = this.parameters;
    return new CylinderBufferGeometry(parameters.radiusTop, parameters.radiusBottom, parameters.height, parameters.radialSegments, parameters.heightSegments, parameters.openEnded);
  };
  return CylinderBufferGeometry;
}(three, utils);
gfx_modes_LinesBuilder = function (THREE, settings, gfxutils, ChunkedLineBuilder, Geom32Wrapper, SimpleCylinderBuilder, CylinderBufferGeometry) {
  function LinesBuilder(instanceCount, material) {
    this._instanceCount = instanceCount;
    this._builder = new ChunkedLineBuilder(2 * instanceCount, 2, material);
    this._prepareCollisionGeo(material);
  }
  LinesBuilder.prototype = {
    constructor: LinesBuilder,
    _prepareCollisionGeo: function (material) {
      this._collisionMesh = null;
      var cylGeo = new CylinderBufferGeometry(1, 1, 1, 3, 3, true);
      this._collisionBuilder = new SimpleCylinderBuilder(Geom32Wrapper, cylGeo, this._instanceCount, material);
    },
    addItem: function (itemIdx, botPos, topPos, itemRad, colorVal1, colorVal2) {
      var half = 0.5;
      var centerPos = botPos.clone().lerp(topPos, half);
      this._collisionBuilder.addItem(itemIdx, botPos, topPos, itemRad, colorVal1, colorVal2);
      var builder = this._builder;
      builder.startChunk(2 * itemIdx, colorVal1, 1);
      builder.setVertex(0, botPos);
      builder.setVertex(1, centerPos);
      builder.startChunk(2 * itemIdx + 1, colorVal2, 1);
      builder.setVertex(0, centerPos);
      builder.setVertex(1, topPos);
    },
    raycast: function (raycaster, intersects) {
      if (this._collisionMesh === null) {
        return;
      }
      this._collisionBuilder.raycast(raycaster, intersects);
    },
    getObjects: function () {
      this._collisionMesh = this._collisionBuilder.getObjects();
      this._collisionMesh.geometry.computeBoundingSphere();
      this._mesh = this._builder.getObjects();
      this._collisionMesh.parent = this._mesh;
      return this._mesh;
    },
    getSubset: function (chunkIndices) {
      //TODO refactor
      return this._builder.getSubset(chunkIndices);
    },
    setOpacity: function (chunkIndices, value) {
      // TODO refactor chunkindices
      this._builder.setOpacity(chunkIndices, value);
    }
  };
  return LinesBuilder;
}(three, settings, gfx_gfxutils, gfx_modes_ChunkedLineBuilder, gfx_modes_BufferGeometryWrapper32, gfx_modes_SimpleCylinderBuilder, gfx_modes_CylinderBufferGeometry);
gfx_modes_LabelBuilder = function (CSS2DObject, THREE, settings, utils) {
  function adjustColor(color) {
    var r = color >> 16 & 255;
    var g = color >> 8 & 255;
    var b = color & 255;
    if (0.2126 * r + 0.7152 * g + 0.0722 * b > 127) {
      r = r * 3 / 10;
      g = g * 3 / 10;
      b = b * 3 / 10;
    } else {
      r = 255 - (255 - r) * 3 / 10;
      g = 255 - (255 - g) * 3 / 10;
      b = 255 - (255 - b) * 3 / 10;
    }
    return r << 16 | g << 8 | b;
  }
  function _buildLabel2D(pos, color, fieldTxt, mode) {
    var labels = settings.now.labels;
    if (labels === 'no') {
      return null;
    }
    var text = document.createElement('div');
    text.className = 'label label-' + labels;
    if (labels === 'obj' && mode) {
      text.style.color = utils.hexColor(mode.shortId === 'LN' ? color : adjustColor(color));
    }
    if (mode && mode.shortId !== 'LN') {
      text.style.background = 'transparent';
    }
    if (typeof fieldTxt === 'string') {
      var spanText = document.createElement('span');
      spanText.style.fontSize = '150%';
      var spanNodeP = document.createElement('span');
      var spanNodeText = document.createTextNode(fieldTxt);
      spanNodeP.appendChild(spanNodeText);
      spanText.appendChild(spanNodeP);
      text.appendChild(spanText);
    } else {
      text.appendChild(fieldTxt);  //text.style.paddingTop = '10px';
    }
    var label = new CSS2DObject(text);
    label.position.copy(pos);
    var el = label.getElement();
    el.style.visibility = 'visible';
    el.style.textAlign = 'center';
    el.style.verticalAlign = 'middle';
    return label;
  }
  function AtomLabelGroup(component, mode, colorer, mask) {
    THREE.Group.call(this);
    this._component = component;
    var complex = component.getComplex();
    var self = this;
    var lbl = null;
    this._atomsIdc = [];
    var chunksToIdx = this._atomsIdc;
    component.forEachAtom(function (atom) {
      if ((atom._mask & mask) === 0) {
        return;
      }
      var col = colorer.getAtomColor(atom, complex);
      if (atom.getName().getNode() !== null) {
        lbl = _buildLabel2D(atom.getPosition(), col, atom.getName().getNode(), mode);
        if (lbl !== null) {
          chunksToIdx.push(atom._index);
          self.add(lbl);
        }
        return;
      }
      var txt = null;
      if (atom.isLabelVisible()) {
        txt = atom.getVisualName();
        lbl = _buildLabel2D(atom.getPosition(), col, txt, mode);
        if (lbl !== null) {
          chunksToIdx.push(atom._index);
          self.add(lbl);
        }
      }
    });
  }
  AtomLabelGroup.prototype = Object.create(THREE.Group.prototype);
  AtomLabelGroup.prototype.constructor = AtomLabelGroup;
  AtomLabelGroup.prototype._calcChunksList = function (mask) {
    if (this._chunksToIdc === null) {
      return [];
    }
    var chunksList = [];
    var atoms = this._component.getComplex()._atoms;
    var atomsIdc = this._atomsIdc;
    for (var i = 0, n = atomsIdc.length; i < n; ++i) {
      var atom = atoms[atomsIdc[i]];
      if (atom._mask & mask) {
        chunksList.push(i);
      }
    }
    return chunksList;
  };
  AtomLabelGroup.prototype.getSubset = function (mask) {
    var chunksList = this._calcChunksList(mask);
    if (chunksList.length === 0) {
      return [];
    }
    var group = new THREE.Group();
    for (var i = 0, n = chunksList.length; i < n; ++i) {
      group.add(this.children[chunksList[i]].clone());
    }
    group._component = this._component;
    return [group];
  };
  /* This code is disabled due to the inability to clone CSS2dObjects properly.
  
    AtomLabelGroup.prototype._changeSubsetOpacity = function(mask, value) {
      var chunksList = this._calcChunksList(mask);
      if (chunksList.length === 0) {
        return;
      }
      for (var i = 0, n = chunksList.length; i < n; ++i) {
        this.children[chunksList[i]].getElement().style.visibility = value < 1.0 ? 'hidden' : 'visible';
      }
    };
  
    AtomLabelGroup.prototype.enableSubset = function(mask) {
      this._changeSubsetOpacity(mask, 1.0);
    };
  
    AtomLabelGroup.prototype.disableSubset = function(mask) {
      this._changeSubsetOpacity(mask, 0.0);
    };*/
  function LabelBuilder() {
  }
  LabelBuilder.prototype.buildSGroupMarkers = function (complex, groupLetters) {
    var sgroup = null;
    var actPos = null;
    var markColor = 0;
    for (var i = 0; i < complex.getSGroupCount(); i++) {
      sgroup = complex.getSGroups()[i];
      if (sgroup._center !== null) {
        actPos = new THREE.Vector3().copy(sgroup._position);
        actPos.add(sgroup._center);
        groupLetters.add(_buildLabel2D(actPos, markColor, sgroup._name));
      } else {
        groupLetters.add(_buildLabel2D(new THREE.Vector3().copy(sgroup._position), markColor, sgroup._name));
      }
    }
  };
  LabelBuilder.prototype.buildAtomMarks = function (component, mode, colorer, groupLetters, mask) {
    var marksGroup = new AtomLabelGroup(component, mode, colorer, mask);
    if (marksGroup.children.length === 0) {
      return;
    }
    groupLetters.add(marksGroup);
  };
  return LabelBuilder;
}(gfx_CSS2DObject, three, settings, utils);
gfx_modes_CrossBuilder = function (THREE, ChunkedLineBuilder) {
  var vectors = [
    new THREE.Vector3(1, 0, 0),
    new THREE.Vector3(-1, 0, 0),
    new THREE.Vector3(0, 1, 0),
    new THREE.Vector3(0, -1, 0),
    new THREE.Vector3(0, 0, 1),
    new THREE.Vector3(0, 0, -1)
  ];
  var vecCount = vectors.length;
  var vtx = new THREE.Vector3();
  function CrossBuilder(instanceCount, material) {
    this._builder = new ChunkedLineBuilder(instanceCount, vecCount, material);
  }
  CrossBuilder.prototype = {
    constructor: CrossBuilder,
    addItem: function (itemIdx, itemPos, itemRad, colorVal) {
      var builder = this._builder;
      builder.startChunk(itemIdx, colorVal, 1);
      for (var i = 0; i < vecCount; ++i) {
        vtx.copy(itemPos).addScaledVector(vectors[i], itemRad);
        builder.setVertex(i, vtx);
      }
    },
    getObjects: function () {
      return this._builder.getObjects();
    },
    getSubset: function (chunkIndices) {
      return this._builder.getSubset(chunkIndices);
    },
    setOpacity: function (chunkIndices, value) {
      this._builder.setOpacity(chunkIndices, value);
    }
  };
  return CrossBuilder;
}(three, gfx_modes_ChunkedLineBuilder);
gfx_modes_LinesMode = function (THREE, settings, gfxutils, buildBondsGeometry, buildOrphanedGeometry, buildALoopsGeometry, LinesBuilderName, LabelBuilder, CrossBuilder) {
  function LinesMode(opts) {
    this._labelBuilder = new LabelBuilder();
    this._opts = Object.create(opts);
  }
  LinesMode.prototype.id = 'LINES_MODE';
  LinesMode.prototype.shortId = 'LN';
  LinesMode.prototype.name = LinesMode.prototype.shortName = 'Lines';
  LinesMode.prototype.getUberOptions = function () {
    return {};
  };
  LinesMode.prototype.drawMultiorderBonds = function () {
    return this._opts.multibond;
  };
  LinesMode.prototype.calcAtomRadius = function () {
    return this._opts.atom;
  };
  LinesMode.prototype.getAromaticOffset = function () {
    return this._opts.offsarom;
  };
  LinesMode.prototype.getAromaticArcChunks = function () {
    return this._opts.chunkarom;
  };
  LinesMode.prototype.showAromaticLoops = function () {
    return this._opts.showarom;
  };
  LinesMode.prototype.buildGeometry = function (complex, colorer, mask, material) {
    var group = new gfxutils.RCGroup();
    var self = this;
    complex.forEachVisibleComponent(function (component) {
      var compGroup = new gfxutils.RCGroup();
      var linesGroup = buildBondsGeometry(LinesBuilderName, component, colorer, self, 0, mask, material);
      var orphanedGroup = buildOrphanedGeometry(CrossBuilder, component, colorer, self, 0, mask, material);
      var aLoops = buildALoopsGeometry(component, colorer, self, 0, mask, material);
      self._labelBuilder.buildAtomMarks(component, self, colorer, compGroup, mask);
      if (linesGroup.children.length === 0 && compGroup.children.length === 0 && orphanedGroup.children.length === 0 && aLoops.children.length === 0) {
        return;
      }
      if (linesGroup.children.length > 0) {
        compGroup.add(linesGroup);
      }
      compGroup.add(orphanedGroup);
      compGroup.add(aLoops);
      compGroup._component = component;
      group.add(compGroup);
    });
    self._labelBuilder.buildSGroupMarkers(complex, group);
    return group;
  };
  return LinesMode;
}(three, settings, gfx_gfxutils, gfx_modes_buildBondLines, gfx_modes_buildCrossAtoms, gfx_modes_buildALoopsLines, gfx_modes_LinesBuilder, gfx_modes_LabelBuilder, gfx_modes_CrossBuilder);
gfx_modes_buildSphereAtoms = function (THREE, settings, gfxutils) {
  function AtomsGroup(SphereBuilderName, component, colorer, mode, polyComplexity, mask, material) {
    THREE.Group.call(this);
    this._component = component;
    this._atomsIdc = null;
    this._builder = null;
    var atomCount = 0;
    var complex = component.getComplex();
    complex.propagateAtoms();
    component.forEachAtom(function (atom) {
      if (!(atom._mask & mask)) {
        return;
      }
      ++atomCount;
    });
    if (atomCount === 0) {
      return;
    }
    this._atomsIdc = new Array(atomCount);
    var atomsIdc = this._atomsIdc;
    var geo = settings.now.zSprites ? new THREE.PlaneBufferGeometry(2, 2, 1, 1) : new THREE.SphereBufferGeometry(1, polyComplexity * 2, polyComplexity, 0, Math.PI * 2, 0, Math.PI);
    var builder = new SphereBuilderName(geo, atomCount, material);
    this._builder = builder;
    var currAtomIdx = 0;
    component.forEachAtom(function (atom) {
      if (!(atom._mask & mask)) {
        return;
      }
      atomsIdc[currAtomIdx] = atom._index;
      builder.addItem(currAtomIdx++, atom._position, mode.calcAtomRadius(atom), colorer.getAtomColor(atom, complex));
    });
    var group = builder.getObjects();
    var boundingSphere = complex.boundingSphere;
    gfxutils.forEachMeshInGroup(group, function (mesh) {
      mesh.geometry.boundingSphere = boundingSphere.clone();
    });
    this.add(group);
  }
  AtomsGroup.prototype = Object.create(THREE.Group.prototype);
  AtomsGroup.prototype.constructor = AtomsGroup;
  AtomsGroup.prototype.raycast = function (raycaster, intersects) {
    if (this._builder === null) {
      return;
    }
    var inters = [];
    var atoms = this._component.getComplex()._atoms;
    this._builder.raycast(raycaster, inters);
    var atomsIdc = this._atomsIdc;
    // process inters array - arr object references
    for (var i = 0, n = inters.length; i < n; ++i) {
      if (!inters[i].hasOwnProperty('chunkIdx')) {
        continue;
      }
      var atomIdx = atomsIdc[inters[i].chunkIdx];
      if (atomIdx < atoms.length) {
        inters[i].atom = atoms[atomIdx];
        intersects.push(inters[i]);
      }
    }
  };
  AtomsGroup.prototype._calcChunksList = function (mask) {
    if (this._atomsIdc === null) {
      return [];
    }
    var chunksList = [];
    var atoms = this._component.getComplex()._atoms;
    var atomsIdc = this._atomsIdc;
    for (var i = 0, n = atomsIdc.length; i < n; ++i) {
      var atom = atoms[atomsIdc[i]];
      if (atom._mask & mask) {
        chunksList.push(i);
      }
    }
    return chunksList;
  };
  AtomsGroup.prototype.getSubset = function (mask) {
    var chunksList = this._calcChunksList(mask);
    if (chunksList.length === 0) {
      return [];
    }
    var selObjects = this._builder.getSubset(chunksList);
    for (var objIdx = 0, objCount = selObjects.length; objIdx < objCount; ++objIdx) {
      selObjects[objIdx]._component = this._component;
    }
    return selObjects;
  };
  AtomsGroup.prototype._changeSubsetOpacity = function (mask, value) {
    var chunksList = this._calcChunksList(mask);
    if (chunksList.length === 0) {
      return;
    }
    this._builder.setOpacity(chunksList, value);
  };
  AtomsGroup.prototype.enableSubset = function (mask) {
    this._changeSubsetOpacity(mask, 1);
  };
  AtomsGroup.prototype.disableSubset = function (mask) {
    this._changeSubsetOpacity(mask, 0);
  };
  function buildSphereAtoms(SphereBuilderName, component, colorer, mode, polyComplexity, mask, material) {
    return new AtomsGroup(SphereBuilderName, component, colorer, mode, polyComplexity, mask, material);
  }
  return buildSphereAtoms;
}(three, settings, gfx_gfxutils);
gfx_modes_buildAtomCollisionGeo = function (THREE) {
  //////////////////////////////////////////////////////////////////////////////
  function CollisionAtom(atom, mode) {
    this._atom = atom;
    this._radius = mode.calcAtomRadius(atom);
  }
  CollisionAtom.prototype.raycast = function () {
    var sphere = new THREE.Sphere();
    return function raycast(parentMatrix, raycaster, intersects) {
      sphere.set(this._atom._position, this._radius);
      sphere.applyMatrix4(parentMatrix);
      var p = raycaster.ray.intersectSphere(sphere);
      if (p) {
        intersects.push({
          distance: raycaster.ray.origin.distanceTo(p),
          point: p,
          object: this
        });
      }
    };
  }();
  //////////////////////////////////////////////////////////////////////////////
  function CollisionAtomGroup(complex, mode, mask) {
    THREE.Group.call(this);
    var self = this;
    this._objects = [];
    complex.forEachAtom(function (atom) {
      if ((atom._mask & mask) !== 0) {
        self._objects.push(new CollisionAtom(atom, mode));
      }
    });
  }
  CollisionAtomGroup.prototype = Object.create(THREE.Object3D.prototype);
  CollisionAtomGroup.constructor = CollisionAtomGroup;
  CollisionAtomGroup.prototype.raycast = function (raycaster, intersects) {
    for (var i = 0; i < this._objects.length; ++i) {
      this._objects[i].raycast(this.matrixWorld, raycaster, intersects);
    }
  };
  return function (complex, mode, mask) {
    return new CollisionAtomGroup(complex, mode, mask);
  };
}(three);
gfx_modes_buildCylinderBonds = function (THREE, settings, CylinderBufferGeometry, gfxutils) {
  function getCylinderCount(bondOrder) {
    return bondOrder < 2 ? 1 : bondOrder;
  }
  function BondsGroup(CylinderBuilderName, component, colorer, mode, polyComplexity, mask, material) {
    THREE.Group.call(this);
    this._component = component;
    this._chunksToIdc = null;
    this._builder = null;
    var bondsCount = 0;
    var drawMultiple = mode.drawMultiorderBonds();
    var complex = component.getComplex();
    complex.propagateAtoms();
    component.forEachBond(function (bond) {
      var atom1 = bond._left;
      var atom2 = bond._right;
      if (!(atom1._mask & mask) || !(atom2._mask & mask)) {
        return;
      }
      bondsCount += drawMultiple ? getCylinderCount(bond._order) : 1;
    });
    if (bondsCount === 0) {
      return;
    }
    var geo = settings.now.zSprites ? new THREE.PlaneBufferGeometry(2, 2, 1, 1) : new CylinderBufferGeometry(1, 1, 1, Math.max(3, polyComplexity), 2, true);
    var builder = new CylinderBuilderName(geo, bondsCount, material);
    this._builder = builder;
    this._chunksToIdc = new Array(bondsCount);
    var chunksToIdx = this._chunksToIdc;
    var currBondIdx = 0;
    var stickRad = mode.calcStickRadius();
    var emptyOffset = mode.calcSpaceFraction();
    var normDir;
    var leftPos = new THREE.Vector3();
    var rightPos = new THREE.Vector3();
    component.forEachBond(function (bond) {
      var atom1 = bond._left;
      var atom2 = bond._right;
      if (!(atom1._mask & mask) || !(atom2._mask & mask)) {
        return;
      }
      normDir = bond.calcNormalDir();
      var order = drawMultiple ? getCylinderCount(bond._order) : 1;
      var minRad = Math.min(mode.calcAtomRadius(atom1), mode.calcAtomRadius(atom2));
      var dist = 2 * minRad / order;
      var currStickRad = drawMultiple ? Math.min(stickRad, dist * 0.5 * (1 - emptyOffset)) : stickRad;
      for (var j = 0; j < order; ++j) {
        var scale = dist * (order % 2 === 0 ? ((j / 2 | 0) + 0.5) * (1 - 2 * (j % 2)) : ((j + 1) / 2 | 0) * (-1 + 2 * (j % 2)));
        chunksToIdx[currBondIdx] = bond._index;
        leftPos.copy(atom1._position);
        leftPos.addScaledVector(normDir, scale);
        rightPos.copy(atom2._position);
        rightPos.addScaledVector(normDir, scale);
        builder.addItem(currBondIdx++, leftPos, rightPos, currStickRad, colorer.getAtomColor(atom1, complex), colorer.getAtomColor(atom2, complex));
      }
    });
    var group = builder.getObjects();
    var boundingSphere = complex.boundingSphere;
    gfxutils.forEachMeshInGroup(group, function (mesh) {
      mesh.geometry.boundingSphere = boundingSphere.clone();
    });
    this.add(group);
  }
  BondsGroup.prototype = Object.create(THREE.Group.prototype);
  BondsGroup.prototype.constructor = BondsGroup;
  BondsGroup.prototype.raycast = function (raycaster, intersects) {
    if (this._builder === null) {
      return;
    }
    var inters = [];
    var bonds = this._component.getComplex()._bonds;
    this._builder.raycast(raycaster, inters);
    var chunksToIdx = this._chunksToIdc;
    // process inters array - arr object references
    for (var i = 0, n = inters.length; i < n; ++i) {
      if (!inters[i].hasOwnProperty('chunkIdx')) {
        continue;
      }
      var chunkIdx = inters[i].chunkIdx;
      var bondIdx = chunksToIdx[Math.floor(chunkIdx / 2)];
      if (bondIdx < bonds.length) {
        var bond = bonds[bondIdx];
        inters[i].atom = chunkIdx % 2 === 0 ? bond._left : bond._right;
        intersects.push(inters[i]);
      }
    }
  };
  BondsGroup.prototype._calcChunksList = function (mask, innerOnly) {
    if (this._chunksToIdc === null) {
      return [];
    }
    var chunksList = [];
    var bonds = this._component.getComplex()._bonds;
    var chunksToIdx = this._chunksToIdc;
    for (var i = 0, n = chunksToIdx.length; i < n; ++i) {
      var bond = bonds[chunksToIdx[i]];
      if (bond._left._mask & mask && (!innerOnly || bond._right._mask & mask)) {
        chunksList.push(2 * i);
      }
      if (bond._right._mask & mask && (!innerOnly || bond._left._mask & mask)) {
        chunksList.push(2 * i + 1);
      }
    }
    return chunksList;
  };
  /**
   * Builds subset geometry by ATOMS index list
   *
   * @param {Number} mask - Representation mask
   * @param {Boolean} innerOnly - if true returns inner bonds only - without halves
   * @returns {Array} Subset geometry
   */
  BondsGroup.prototype.getSubset = function (mask, innerOnly) {
    innerOnly = innerOnly !== undefined ? innerOnly : false;
    var chunksList = this._calcChunksList(mask, innerOnly);
    if (chunksList.length === 0) {
      return [];
    }
    var selObjects = this._builder.getSubset(chunksList);
    for (var objIdx = 0, objCount = selObjects.length; objIdx < objCount; ++objIdx) {
      selObjects[objIdx]._component = this._component;
    }
    return selObjects;
  };
  BondsGroup.prototype._changeSubsetOpacity = function (mask, value, innerOnly) {
    var chunksList = this._calcChunksList(mask, innerOnly);
    if (chunksList.length === 0) {
      return;
    }
    this._builder.setOpacity(chunksList, value);
  };
  BondsGroup.prototype.enableSubset = function (mask, innerOnly) {
    innerOnly = innerOnly !== undefined ? innerOnly : true;
    this._changeSubsetOpacity(mask, 1, innerOnly);
  };
  BondsGroup.prototype.disableSubset = function (mask, innerOnly) {
    innerOnly = innerOnly !== undefined ? innerOnly : true;
    this._changeSubsetOpacity(mask, 0, innerOnly);
  };
  function buildCylinderBonds(CylinderBuilderName, component, colorer, mode, polyComplexity, mask, material) {
    return new BondsGroup(CylinderBuilderName, component, colorer, mode, polyComplexity, mask, material);
  }
  return buildCylinderBonds;
}(three, settings, gfx_modes_CylinderBufferGeometry, gfx_gfxutils);
gfx_modes_InstancedCylinderBuilder = function (THREE, settings, gfxutils, UberMaterial, Geom32Wrapper, SimpleCylinderBuilder, CylinderBufferGeometry, utils) {
  function sortNumber(a, b) {
    return a - b;
  }
  function InstancedCylinderBuilder(cylinderGeometry, instanceCount, material) {
    this._cylGeometry = cylinderGeometry;
    this._matVector1 = new THREE.InstancedBufferAttribute(utils.allocateTyped(Float32Array, instanceCount * 4), 4, 1);
    this._matVector2 = new THREE.InstancedBufferAttribute(utils.allocateTyped(Float32Array, instanceCount * 4), 4, 1);
    this._matVector3 = new THREE.InstancedBufferAttribute(utils.allocateTyped(Float32Array, instanceCount * 4), 4, 1);
    var alpha = utils.allocateTyped(Float32Array, instanceCount);
    gfxutils.fillArray(alpha, 1);
    this._alpha = new THREE.InstancedBufferAttribute(alpha, 1, 1);
    if (settings.now.zSprites) {
      this._invmatVector1 = new THREE.InstancedBufferAttribute(utils.allocateTyped(Float32Array, instanceCount * 4), 4, 1);
      this._invmatVector2 = new THREE.InstancedBufferAttribute(utils.allocateTyped(Float32Array, instanceCount * 4), 4, 1);
      this._invmatVector3 = new THREE.InstancedBufferAttribute(utils.allocateTyped(Float32Array, instanceCount * 4), 4, 1);
    }
    this._color1 = new THREE.InstancedBufferAttribute(utils.allocateTyped(Float32Array, instanceCount * 3), 3, 1);
    this._color2 = new THREE.InstancedBufferAttribute(utils.allocateTyped(Float32Array, instanceCount * 3), 3, 1);
    this._material = material.createInstance();
    var matParams = {
      instancedMatrix: true,
      attrColor: true,
      attrColor2: true,
      attrAlphaColor: true
    };
    if (settings.now.zSprites) {
      matParams.instancedSprite = true;
      matParams.cylinderSprite = true;
    }
    this._material.setValues(matParams);
    this._mesh = null;
    // prepare collision geometry
    this._prepareCollisionGeo(material);
  }
  InstancedCylinderBuilder.prototype = {
    constructor: InstancedCylinderBuilder,
    _prepareCollisionGeo: function (material) {
      this._collisionMesh = null;
      var cylGeo = new CylinderBufferGeometry(1, 1, 1, 3, 3, true);
      this._collisionBuilder = new SimpleCylinderBuilder(Geom32Wrapper, cylGeo, this._matVector1.count, material);
    },
    addItem: function (itemIdx, botPos, topPos, itemRad, colorVal1, colorVal2) {
      var matrix = gfxutils.calcCylinderMatrix(botPos, topPos, itemRad);
      var me = matrix.elements;
      this._collisionBuilder.addItem(itemIdx, botPos, topPos, itemRad, colorVal1, colorVal2);
      this._matVector1.setXYZW(itemIdx, me[0], me[4], me[8], me[12]);
      this._matVector2.setXYZW(itemIdx, me[1], me[5], me[9], me[13]);
      this._matVector3.setXYZW(itemIdx, me[2], me[6], me[10], me[14]);
      if (settings.now.zSprites) {
        var invMatrix = new THREE.Matrix4().getInverse(matrix);
        me = invMatrix.elements;
        this._invmatVector1.setXYZW(itemIdx, me[0], me[4], me[8], me[12]);
        this._invmatVector2.setXYZW(itemIdx, me[1], me[5], me[9], me[13]);
        this._invmatVector3.setXYZW(itemIdx, me[2], me[6], me[10], me[14]);
      }
      var firstColor = new THREE.Color(colorVal1);
      var secondColor = new THREE.Color(colorVal2);
      this._color1.setXYZ(itemIdx, firstColor.r, firstColor.g, firstColor.b);
      this._color2.setXYZ(itemIdx, secondColor.r, secondColor.g, secondColor.b);
    },
    getObjects: function () {
      this._collisionMesh = this._collisionBuilder.getObjects();
      this._collisionMesh.geometry.computeBoundingSphere();
      var geom = new THREE.InstancedBufferGeometry().copy(this._cylGeometry);
      geom.addAttribute('matVector1', this._matVector1);
      geom.addAttribute('matVector2', this._matVector2);
      geom.addAttribute('matVector3', this._matVector3);
      if (settings.now.zSprites) {
        geom.addAttribute('invmatVector1', this._invmatVector1);
        geom.addAttribute('invmatVector2', this._invmatVector2);
        geom.addAttribute('invmatVector3', this._invmatVector3);
      }
      geom.addAttribute('color', this._color1);
      geom.addAttribute('color2', this._color2);
      geom.addAttribute('alphaColor', this._alpha);
      this._mesh = new THREE.Mesh(geom, this._material);
      this._collisionMesh.parent = this._mesh;
      geom.boundingSphere = this._collisionMesh.geometry.boundingSphere;
      return this._mesh;
    },
    raycast: function (raycaster, intersects) {
      if (this._collisionMesh === null) {
        return;
      }
      this._collisionBuilder.raycast(raycaster, intersects);
    },
    _prepareCylinderInfo: function (chunkIndices) {
      chunkIndices.sort(sortNumber);
      var chunksIdx = [];
      var cylinderInfo = [];
      for (var i = 0, n = chunkIndices.length; i < n; ++i) {
        var val = chunkIndices[i];
        var even = (val | 0) % 2 === 0;
        var newPar = {
          first: false,
          second: false
        };
        if (even) {
          newPar.first = true;
          newPar.second = i + 1 < n && chunkIndices[i + 1] === chunkIndices[i] + 1;
          if (newPar.second) {
            ++i;
          }
        } else {
          newPar.second = true;
        }
        chunksIdx.push(Math.floor(val / 2));
        cylinderInfo.push(newPar);
      }
      return {
        indices: chunksIdx,
        cylinderInfo: cylinderInfo
      };
    },
    _assignOpacity: function (cylinderInfo, color1, color2) {
      for (var i = 0, n = cylinderInfo.length; i < n; ++i) {
        var info = cylinderInfo[i];
        if (!info.first) {
          color1.setX(i, -0.5);
        }
        if (!info.second) {
          color2.setX(i, -0.5);
        }
      }
    },
    getSubset: function (chunkIndices) {
      var info = this._prepareCylinderInfo(chunkIndices);
      var cylinderIndices = info.indices;
      var instanceCount = cylinderIndices.length;
      var matVector1 = new THREE.InstancedBufferAttribute(utils.allocateTyped(Float32Array, instanceCount * 4), 4, 1);
      var matVector2 = new THREE.InstancedBufferAttribute(utils.allocateTyped(Float32Array, instanceCount * 4), 4, 1);
      var matVector3 = new THREE.InstancedBufferAttribute(utils.allocateTyped(Float32Array, instanceCount * 4), 4, 1);
      var alpha = utils.allocateTyped(Float32Array, instanceCount);
      gfxutils.fillArray(alpha, 1);
      var alphaAttr = new THREE.InstancedBufferAttribute(alpha, 1, 1);
      var invmatVector1, invmatVector2, invmatVector3;
      if (settings.now.zSprites) {
        invmatVector1 = new THREE.InstancedBufferAttribute(utils.allocateTyped(Float32Array, instanceCount * 4), 4, 1);
        invmatVector2 = new THREE.InstancedBufferAttribute(utils.allocateTyped(Float32Array, instanceCount * 4), 4, 1);
        invmatVector3 = new THREE.InstancedBufferAttribute(utils.allocateTyped(Float32Array, instanceCount * 4), 4, 1);
      }
      var color1 = new THREE.InstancedBufferAttribute(utils.allocateTyped(Float32Array, instanceCount * 3), 3, 1);
      var color2 = new THREE.InstancedBufferAttribute(utils.allocateTyped(Float32Array, instanceCount * 3), 3, 1);
      var geom = new THREE.InstancedBufferGeometry().copy(this._cylGeometry);
      matVector1.copyAtList(this._matVector1, cylinderIndices);
      matVector2.copyAtList(this._matVector2, cylinderIndices);
      matVector3.copyAtList(this._matVector3, cylinderIndices);
      if (settings.now.zSprites) {
        invmatVector1.copyAtList(this._invmatVector1, cylinderIndices);
        invmatVector2.copyAtList(this._invmatVector2, cylinderIndices);
        invmatVector3.copyAtList(this._invmatVector3, cylinderIndices);
      }
      color1.copyAtList(this._color1, cylinderIndices);
      color2.copyAtList(this._color2, cylinderIndices);
      this._assignOpacity(info.cylinderInfo, color1, color2);
      geom.addAttribute('matVector1', matVector1);
      geom.addAttribute('matVector2', matVector2);
      geom.addAttribute('matVector3', matVector3);
      if (settings.now.zSprites) {
        geom.addAttribute('invmatVector1', invmatVector1);
        geom.addAttribute('invmatVector2', invmatVector2);
        geom.addAttribute('invmatVector3', invmatVector3);
      }
      geom.addAttribute('color', color1);
      geom.addAttribute('color2', color2);
      geom.addAttribute('alphaColor', alphaAttr);
      if (this._collisionMesh !== null) {
        geom.boundingSphere = this._collisionMesh.geometry.boundingSphere;
      }
      return [new THREE.Mesh(geom, this._material)];
    },
    setOpacity: function (chunkIndices, value) {
      if (this._mesh === null || !this._mesh.geometry) {
        return;
      }
      var geom = this._mesh.geometry;
      var alphaArr = geom.getAttribute('alphaColor').array;
      for (var i = 0, n = chunkIndices.length; i < n; ++i) {
        alphaArr[Math.floor(chunkIndices[i] / 2)] = value;
      }
      geom.getAttribute('alphaColor').needsUpdate = true;
    }
  };
  return InstancedCylinderBuilder;
}(three, settings, gfx_gfxutils, gfx_shaders_UberMaterial, gfx_modes_BufferGeometryWrapper32, gfx_modes_SimpleCylinderBuilder, gfx_modes_CylinderBufferGeometry, utils);
gfx_modes_ExtrudedObjectBuilder = function () {
  function ExtrudedObjectBuilder(GeometryWrapper, shape, chunkSize, chunksCount, material) {
    this._shape = shape;
    var ptsCount = shape.length;
    var ptsPerChunk = chunkSize * ptsCount;
    var facesPerChunk = (chunkSize - 1) * ptsCount * 2;
    var newMat = material.createInstance();
    var matParams = { attrAlphaColor: true };
    newMat.setValues(matParams);
    this._geomWrapper = new GeometryWrapper(ptsPerChunk, facesPerChunk, chunksCount, newMat);
  }
  ExtrudedObjectBuilder.prototype = {
    constructor: ExtrudedObjectBuilder,
    addRing: function (idx, matrix) {
      var ptsCount = this._shape.length;
      var inChunkStartIdx = idx * ptsCount;
      var inChunkFaceIdx = (idx - 1) * ptsCount * 2;
      var processedPoints = new Array(ptsCount);
      var geomWrapper = this._geomWrapper;
      for (var i = 0; i < ptsCount; ++i) {
        processedPoints[i] = this._shape[i].clone().applyMatrix4(matrix);
      }
      for (var vtxIdx = 0; vtxIdx < ptsCount; ++vtxIdx) {
        var point = processedPoints[vtxIdx];
        var nextPt = processedPoints[(vtxIdx + 1) % ptsCount];
        var prevPt = processedPoints[(vtxIdx + ptsCount - 1) % ptsCount];
        var prevToCurr = point.clone().sub(prevPt).normalize();
        var nextToCurr = point.clone().sub(nextPt).normalize();
        var currNormal = prevToCurr.add(nextToCurr).normalize();
        var ptIdx = inChunkStartIdx + vtxIdx;
        geomWrapper.setPosition(ptIdx, point);
        geomWrapper.setNormal(ptIdx, currNormal);
        if (idx !== 0) {
          var nextVtx = (vtxIdx + 1) % ptsCount;
          var face1 = {
            a: inChunkStartIdx + vtxIdx,
            b: inChunkStartIdx + nextVtx,
            c: inChunkStartIdx + vtxIdx - ptsCount
          };
          geomWrapper.setFace(inChunkFaceIdx + 2 * vtxIdx, face1);
          var face2 = {
            a: inChunkStartIdx + nextVtx,
            b: inChunkStartIdx - ptsCount + nextVtx,
            c: inChunkStartIdx + vtxIdx - ptsCount
          };
          geomWrapper.setFace(inChunkFaceIdx + 2 * vtxIdx + 1, face2);
        }
      }
    },
    addChunk: function (itemIdx, matrices, colorVal) {
      var mtxCount = matrices.length;
      var geomWrapper = this._geomWrapper;
      geomWrapper.startChunk(colorVal);
      for (var ringIdx = 0; ringIdx < mtxCount; ++ringIdx) {
        this.addRing(ringIdx, matrices[ringIdx]);
      }
      geomWrapper.endChunk();
    },
    raycast: function (raycaster, intersects) {
      this._geomWrapper.raycast(raycaster, intersects);
    },
    getObjects: function () {
      return this._geomWrapper.getObjects();
    },
    getSubset: function (chunkIndices) {
      return this._geomWrapper.getSubset(chunkIndices);
    },
    setOpacity: function (chunkIndices, value) {
      this._geomWrapper.setOpacity(chunkIndices, value);
    }
  };
  return ExtrudedObjectBuilder;
}();
gfx_modes_buildALoopsTorus = function (THREE, settings, ExtrudedObjectBuilder, gfxutils) {
  var calcChunkMatrix = gfxutils.calcChunkMatrix;
  function _createShape(rad, parts) {
    var pts = [];
    for (var i = 0; i < parts; ++i) {
      var a = 2 * i / parts * Math.PI;
      pts.push(new THREE.Vector3(Math.cos(a) * rad, Math.sin(a) * rad, 0));
    }
    return pts;
  }
  function _slerp(omega, v1, v2, t) {
    var oSin = Math.sin(omega);
    return v1.clone().multiplyScalar(Math.sin((1 - t) * omega) / oSin).addScaledVector(v2, Math.sin(t * omega) / oSin);
  }
  function ALoopsTorusGroup(GeomWrapperName, component, colorer, mode, polyComplexity, mask, material) {
    THREE.Group.call(this);
    this._component = component;
    var complex = component.getComplex();
    this._chunksToIdc = null;
    this._builder = null;
    var chunksCount = 0;
    if (!mode.showAromaticLoops()) {
      return;
    }
    component.forEachCycle(function (cycle) {
      var cycAtoms = cycle.atoms;
      console.assert(cycAtoms.length > 1);
      for (var i = 0, n = cycAtoms.length; i < n; ++i) {
        if (cycAtoms[i]._mask & mask) {
          ++chunksCount;
        }
      }
    });
    if (chunksCount === 0) {
      return;
    }
    var torusRad = mode.getAromRadius();
    var segmentsHeight = polyComplexity;
    this._builder = new ExtrudedObjectBuilder(GeomWrapperName, _createShape(1, Math.max(polyComplexity, 3)), segmentsHeight + 1, chunksCount, material);
    var builder = this._builder;
    this._chunksToIdc = new Array(chunksCount);
    var chunksToIdx = this._chunksToIdc;
    var chunkIdx = 0;
    var radiusV = new THREE.Vector2(torusRad, torusRad);
    var radOffset = mode.calcStickRadius() + 2 * torusRad;
    var leprStep = 1 / segmentsHeight;
    var lookAtVector = new THREE.Vector3();
    component.forEachCycle(function (cycle) {
      var cycAtoms = cycle.atoms;
      var tmpDir = [];
      var center = cycle.center;
      var cycleRad = cycle.radius - radOffset;
      var n = cycAtoms.length;
      var i = 0;
      var prevPos = cycAtoms[n - 1]._position;
      var currPos = cycAtoms[i]._position;
      var prevVector = prevPos.clone().sub(center);
      var currVector = currPos.clone().sub(center);
      var upDir = currVector.clone().cross(prevVector).normalize();
      for (; i < n; ++i) {
        var omega = prevVector.angleTo(currVector);
        tmpDir.push(_slerp(omega, prevVector, currVector, 0.5).normalize());
        prevPos = currPos;
        currPos = cycAtoms[(i + 1) % n]._position;
        prevVector = currVector;
        currVector = currPos.clone().sub(center);
      }
      for (i = 0; i < n; ++i) {
        if (!(cycAtoms[i]._mask & mask)) {
          continue;
        }
        var start = tmpDir[i];
        var end = tmpDir[(i + 1) % n];
        var currAngle = start.angleTo(end);
        var mtc = [];
        for (var j = 0; j <= segmentsHeight; ++j) {
          var currPoint = _slerp(currAngle, start, end, j * leprStep).multiplyScalar(cycleRad).add(center);
          var currDir = currPoint.clone().sub(center).cross(upDir);
          lookAtVector.addVectors(currPoint, currDir);
          mtc.push(calcChunkMatrix(currPoint, lookAtVector, upDir, radiusV));
        }
        chunksToIdx[chunkIdx] = cycAtoms[i]._index;
        builder.addChunk(chunkIdx++, mtc, colorer.getAtomColor(cycAtoms[i], complex));
      }
    });
    this.add(builder.getObjects());
  }
  ALoopsTorusGroup.prototype = Object.create(THREE.Group.prototype);
  ALoopsTorusGroup.prototype.constructor = ALoopsTorusGroup;
  ALoopsTorusGroup.prototype.raycast = function (raycaster, intersects) {
    if (this._builder === null) {
      return;
    }
    var inters = [];
    var atoms = this._component.getComplex()._atoms;
    this._builder.raycast(raycaster, inters);
    var chunksToIdx = this._chunksToIdc;
    // process inters array - arr object references
    for (var i = 0, n = inters.length; i < n; ++i) {
      if (!inters[i].hasOwnProperty('chunkIdx')) {
        continue;
      }
      var atomIdx = chunksToIdx[inters[i].chunkIdx];
      if (atomIdx < atoms.length) {
        inters[i].atom = atoms[atomIdx];
        intersects.push(inters[i]);
      }
    }
  };
  ALoopsTorusGroup.prototype._calcChunksList = function (mask) {
    if (this._chunksToIdc === null) {
      return [];
    }
    var chunksList = [];
    var atoms = this._component.getComplex()._atoms;
    var atomsIdc = this._chunksToIdc;
    for (var i = 0, n = atomsIdc.length; i < n; ++i) {
      var atom = atoms[atomsIdc[i]];
      if (atom._mask & mask) {
        chunksList.push(i);
      }
    }
    return chunksList;
  };
  ALoopsTorusGroup.prototype.getSubset = function (mask) {
    var chunksList = this._calcChunksList(mask);
    if (chunksList.length === 0) {
      return [];
    }
    var selObjects = this._builder.getSubset(chunksList);
    for (var objIdx = 0, objCount = selObjects.length; objIdx < objCount; ++objIdx) {
      selObjects[objIdx]._component = this._component;
    }
    return selObjects;
  };
  ALoopsTorusGroup.prototype._changeSubsetOpacity = function (mask, value) {
    var chunksList = this._calcChunksList(mask);
    if (chunksList.length === 0) {
      return;
    }
    this._builder.setOpacity(chunksList, value);
  };
  ALoopsTorusGroup.prototype.enableSubset = function (mask) {
    this._changeSubsetOpacity(mask, 1);
  };
  ALoopsTorusGroup.prototype.disableSubset = function (mask) {
    this._changeSubsetOpacity(mask, 0);
  };
  function buildALoopsTorus(GeomWrapperName, complex, colorer, mode, polyComplexity, mask, material) {
    return new ALoopsTorusGroup(GeomWrapperName, complex, colorer, mode, polyComplexity, mask, material);
  }
  return buildALoopsTorus;
}(three, settings, gfx_modes_ExtrudedObjectBuilder, gfx_gfxutils);
gfx_modes_BufferGeometryWrapper16 = function (THREE, BaseWrapper) {
  function BufferGeometryWrapper16(chunkSize, facesPerChunk, chunksCount, material) {
    var TOTAL_AVAILABLE_PTS = 65536;
    var pointsCount = chunksCount * chunkSize;
    if (pointsCount <= TOTAL_AVAILABLE_PTS) {
      return new BaseWrapper(chunkSize, facesPerChunk, chunksCount, material);
    }
    var chunksPerGeom = TOTAL_AVAILABLE_PTS / chunkSize | 0;
    var geomCount = pointsCount / (chunksPerGeom * chunkSize) | 0;
    var baseWrappers = [];
    for (var i = 0; i < geomCount; ++i) {
      baseWrappers.push(new BaseWrapper(chunkSize, facesPerChunk, chunksPerGeom, material));
    }
    var lastGeomSize = pointsCount % (chunksPerGeom * chunkSize) / chunkSize | 0;
    if (lastGeomSize > 0) {
      baseWrappers.push(new BaseWrapper(chunkSize, facesPerChunk, lastGeomSize, material));
    }
    this._baseWrappers = baseWrappers;
    this._wrapperIdx = 0;
    this._chunkIdx = 0;
    this._chunksPerGeom = chunksPerGeom;
  }
  BufferGeometryWrapper16.prototype = {
    constructor: BufferGeometryWrapper16,
    // Chunk is monochromatic
    startChunk: function (color) {
      this._baseWrappers[this._wrapperIdx].startChunk(color);
    },
    setPosition: function (inChunkIdx, pos) {
      this._baseWrappers[this._wrapperIdx].setPosition(inChunkIdx, pos);
    },
    setNormal: function (inChunkIdx, normal) {
      this._baseWrappers[this._wrapperIdx].setNormal(inChunkIdx, normal);
    },
    setFace: function (inChunkIdx, currFace) {
      this._baseWrappers[this._wrapperIdx].setFace(inChunkIdx, currFace);
    },
    setChunkPositions: function (posArray) {
      this._baseWrappers[this._wrapperIdx].setChunkPositions(posArray);
    },
    setChunkNormals: function (normalsArray) {
      this._baseWrappers[this._wrapperIdx].setChunkNormals(normalsArray);
    },
    setChunkIndex: function (indexArray) {
      this._baseWrappers[this._wrapperIdx].setChunkIndex(indexArray);
    },
    endChunk: function () {
      this._baseWrappers[this._wrapperIdx].endChunk();
      ++this._chunkIdx;
      if (this._chunkIdx >= this._chunksPerGeom) {
        ++this._wrapperIdx;
        this._chunkIdx = 0;
      }
    },
    raycast: function (raycaster, intersects) {
      var wrappers = this._baseWrappers;
      var chunksPerGeom = this._chunksPerGeom;
      for (var wrapIdx = 0, wrapCount = wrappers.length; wrapIdx < wrapCount; ++wrapIdx) {
        var inters = [];
        wrappers[wrapIdx].raycast(raycaster, inters);
        for (var i = 0, n = inters.length; i < n; ++i) {
          if (!inters[i].hasOwnProperty('chunkIdx')) {
            continue;
          }
          inters[i].chunkIdx += wrapIdx * chunksPerGeom;
          intersects.push(inters[i]);
        }
      }
    },
    getObjects: function () {
      var objects = new THREE.Group();
      var wrappers = this._baseWrappers;
      for (var wrapIdx = 0, wrapCount = wrappers.length; wrapIdx < wrapCount; ++wrapIdx) {
        objects.add(wrappers[wrapIdx].getObjects());
      }
      return objects;
    },
    getSubset: function (chunkIndices) {
      var wrappers = this._baseWrappers;
      var wrappersCount = wrappers.length;
      var chunksPerGeom = this._chunksPerGeom;
      var wrappersChunks = new Array(wrappersCount);
      for (var i = 0; i < wrappersCount; ++i) {
        wrappersChunks[i] = [];
      }
      for (var chunkIdx = 0, n = chunkIndices.length; chunkIdx < n; ++chunkIdx) {
        var idx = chunkIndices[chunkIdx];
        wrappersChunks[idx / chunksPerGeom | 0].push(idx % chunksPerGeom);
      }
      var geoms = [];
      for (var wrIdx = 0; wrIdx < wrappersCount; ++wrIdx) {
        var subs = wrappers[wrIdx].getSubset(wrappersChunks[wrIdx]);
        if (subs.length > 0) {
          Array.prototype.push.apply(geoms, subs);
        }
      }
      return geoms;
    },
    setOpacity: function (chunkIndices, value) {
      var wrappers = this._baseWrappers;
      var wrappersCount = wrappers.length;
      var chunksPerGeom = this._chunksPerGeom;
      var wrappersChunks = new Array(wrappersCount);
      for (var i = 0; i < wrappersCount; ++i) {
        wrappersChunks[i] = [];
      }
      for (var chunkIdx = 0, n = chunkIndices.length; chunkIdx < n; ++chunkIdx) {
        var idx = chunkIndices[chunkIdx];
        wrappersChunks[idx / chunksPerGeom | 0].push(idx % chunksPerGeom);
      }
      for (var wrIdx = 0; wrIdx < wrappersCount; ++wrIdx) {
        wrappers[wrIdx].setOpacity(wrappersChunks[wrIdx], value);
      }
    }
  };
  return BufferGeometryWrapper16;
}(three, gfx_modes_BufferGeometryWrapper32);
gfx_modes_LicoriceMode = function (THREE, settings, gfxutils, buildAtomsGeometry, buildAtomCollisionGeo, SphereBuilder, buildBondsGeometry, CylinderBuilder, LabelBuilder, buildAromaticLoops, GeometryWrapper) {
  var SphereBuilderName = SphereBuilder;
  // uncomment for instanced builder
  //var SphereBuilderName = SphereBuilder.getMega(GeometryWrapper);
  var CylinderBuilderName = CylinderBuilder;
  //var CylinderBuilderName = CylinderBuilder.getMega(GeometryWrapper);
  function LicoriceMode(opts) {
    this._labelBuilder = new LabelBuilder();
    this._opts = Object.create(opts);
  }
  LicoriceMode.prototype.id = 'LICORICE_MODE';
  LicoriceMode.prototype.shortId = 'LC';
  LicoriceMode.prototype.name = LicoriceMode.prototype.shortName = 'Licorice';
  LicoriceMode.prototype.calcAtomRadius = function (_atom) {
    return this._opts.bond;
  };
  LicoriceMode.prototype.getUberOptions = function () {
    return {};
  };
  LicoriceMode.prototype.calcStickRadius = function () {
    return this._opts.bond;
  };
  LicoriceMode.prototype.calcSpaceFraction = function () {
    return this._opts.space;
  };
  LicoriceMode.prototype.getAromRadius = function () {
    return this._opts.aromrad;
  };
  LicoriceMode.prototype.showAromaticLoops = function () {
    return this._opts.showarom;
  };
  LicoriceMode.prototype.drawMultiorderBonds = function () {
    return this._opts.multibond;
  };
  LicoriceMode.prototype.buildGeometry = function (complex, colorer, mask, material) {
    var group = new gfxutils.RCGroup();
    var self = this;
    var polyComplexity = this._opts.polyComplexity[settings.now.resolution];
    complex.forEachVisibleComponent(function (component) {
      var atoms = buildAtomsGeometry(SphereBuilderName, component, colorer, self, polyComplexity, mask, material);
      var bonds = buildBondsGeometry(CylinderBuilderName, component, colorer, self, polyComplexity, mask, material);
      var loops = buildAromaticLoops(GeometryWrapper, component, colorer, self, polyComplexity, mask, material);
      if (atoms.children.length === 0 && bonds.children.length === 0 && loops.children.length === 0) {
        return;
      }
      var abGroup = new gfxutils.RCGroup();
      abGroup.add(atoms);
      abGroup.add(bonds);
      abGroup.add(loops);
      self._labelBuilder.buildAtomMarks(component, self, colorer, abGroup, mask);
      abGroup._component = component;
      group.add(abGroup);
    });
    self._labelBuilder.buildSGroupMarkers(complex, group);
    return group;
  };
  return LicoriceMode;
}(three, settings, gfx_gfxutils, gfx_modes_buildSphereAtoms, gfx_modes_buildAtomCollisionGeo, gfx_modes_InstancedSphereBuilder, gfx_modes_buildCylinderBonds, gfx_modes_InstancedCylinderBuilder, gfx_modes_LabelBuilder, gfx_modes_buildALoopsTorus, gfx_modes_BufferGeometryWrapper16);
gfx_modes_BallsAndSticksMode = function (THREE, settings, gfxutils, buildAtomsGeometry, buildAtomCollisionGeo, SphereBuilder, buildBondsGeometry, CylinderBuilder, LabelBuilder, buildAromaticLoops, GeometryWrapper) {
  var SphereBuilderName = SphereBuilder;
  // uncomment for instanced builder
  //var SphereBuilderName = SphereBuilder.getMega(GeometryWrapper);
  var CylinderBuilderName = CylinderBuilder;
  //var CylinderBuilderName = CylinderBuilder.getMega(GeometryWrapper);
  function BallsAndSticksMode(opts) {
    this._labelBuilder = new LabelBuilder();
    this._opts = Object.create(opts);
  }
  BallsAndSticksMode.prototype.id = 'BALLS_AND_STICKS_MODE';
  BallsAndSticksMode.prototype.shortId = 'BS';
  BallsAndSticksMode.prototype.name = 'Balls and Sticks';
  BallsAndSticksMode.prototype.shortName = 'Balls';
  BallsAndSticksMode.prototype.calcAtomRadius = function (atom) {
    return atom.getType().radius * this._opts.atom;
  };
  BallsAndSticksMode.prototype.getUberOptions = function () {
    return {};
  };
  BallsAndSticksMode.prototype.calcStickRadius = function () {
    return this._opts.bond;
  };
  BallsAndSticksMode.prototype.getAromRadius = function () {
    return this._opts.aromrad;
  };
  BallsAndSticksMode.prototype.showAromaticLoops = function () {
    return this._opts.showarom;
  };
  BallsAndSticksMode.prototype.calcSpaceFraction = function () {
    return this._opts.space;
  };
  BallsAndSticksMode.prototype.drawMultiorderBonds = function () {
    return this._opts.multibond;
  };
  BallsAndSticksMode.prototype.buildGeometry = function (complex, colorer, mask, material) {
    var group = new gfxutils.RCGroup();
    var self = this;
    var polyComplexity = this._opts.polyComplexity[settings.now.resolution];
    complex.forEachVisibleComponent(function (component) {
      var atoms = buildAtomsGeometry(SphereBuilderName, component, colorer, self, polyComplexity, mask, material);
      var bonds = buildBondsGeometry(CylinderBuilderName, component, colorer, self, polyComplexity, mask, material);
      var loops = buildAromaticLoops(GeometryWrapper, component, colorer, self, polyComplexity, mask, material);
      if (atoms.children.length === 0 && bonds.children.length === 0 && loops.children.length === 0) {
        return;
      }
      var abGroup = new gfxutils.RCGroup();
      abGroup.add(atoms);
      abGroup.add(bonds);
      abGroup.add(loops);
      self._labelBuilder.buildAtomMarks(component, self, colorer, abGroup, mask);
      abGroup._component = component;
      group.add(abGroup);
    });
    self._labelBuilder.buildSGroupMarkers(complex, group);
    return group;
  };
  return BallsAndSticksMode;
}(three, settings, gfx_gfxutils, gfx_modes_buildSphereAtoms, gfx_modes_buildAtomCollisionGeo, gfx_modes_InstancedSphereBuilder, gfx_modes_buildCylinderBonds, gfx_modes_InstancedCylinderBuilder, gfx_modes_LabelBuilder, gfx_modes_buildALoopsTorus, gfx_modes_BufferGeometryWrapper16);
gfx_modes_VanDerWaalsMode = function (THREE, settings, gfxutils, buildAtomsGeometry, buildAtomCollisionGeo, SphereBuilder) {
  var SphereBuilderName = SphereBuilder;
  // uncomment for instanced builder
  //var SphereBuilderName = SphereBuilder.getMega(GeometryWrapper);
  function VanDerWaalsMode(opts) {
    this._opts = Object.create(opts);
  }
  VanDerWaalsMode.prototype.id = 'VAN_DER_WAALS_MODE';
  VanDerWaalsMode.prototype.shortId = 'VW';
  VanDerWaalsMode.prototype.name = 'Van der Waals';
  VanDerWaalsMode.prototype.shortName = 'VDW';
  VanDerWaalsMode.prototype.calcAtomRadius = function (atom) {
    return atom.getType().radius;
  };
  VanDerWaalsMode.prototype.getUberOptions = function () {
    return {};
  };
  VanDerWaalsMode.prototype.buildGeometry = function (complex, colorer, mask, material) {
    var polyComplexity = this._opts.polyComplexity[settings.now.resolution];
    var self = this;
    var group = new gfxutils.RCGroup();
    complex.forEachVisibleComponent(function (component) {
      var chainGroup = buildAtomsGeometry(SphereBuilderName, component, colorer, self, polyComplexity, mask, material);
      if (chainGroup.children.length === 0) {
        return;
      }
      group.add(chainGroup);
    });
    return group;
  };
  return VanDerWaalsMode;
}(three, settings, gfx_gfxutils, gfx_modes_buildSphereAtoms, gfx_modes_buildAtomCollisionGeo, gfx_modes_InstancedSphereBuilder);
gfx_modes_buildTraceChain = function (THREE, CylinderBufferGeometry) {
  function TraceGroup(CylinderBuilderName, component, colorer, mode, polyComplexity, mask, material) {
    THREE.Group.call(this);
    this._component = component;
    this._chunksToIdc = null;
    this._builder = null;
    var chunksCount = 0;
    var complex = component.getComplex();
    complex.propagateResidues();
    var subs = component.getMaskedSequences(mask);
    var i, n;
    for (i = 0, n = subs.length; i < n; ++i) {
      chunksCount += subs[i].end - subs[i].start;
    }
    if (chunksCount === 0) {
      return;
    }
    this._builder = new CylinderBuilderName(new CylinderBufferGeometry(1, 1, 1, polyComplexity, 2, false, 0), chunksCount, material);
    var builder = this._builder;
    var entityIdx = 0;
    var stickRad = mode.calcStickRadius();
    this._chunksToIdc = new Array(chunksCount);
    var chunksToIdx = this._chunksToIdc;
    var residues = component.getResidues();
    for (i = 0, n = subs.length; i < n; ++i) {
      var startIdx = subs[i].start;
      var endIdx = subs[i].end;
      var prevRes = residues[startIdx];
      for (var idx = startIdx + 1; idx <= endIdx; ++idx) {
        var currRes = residues[idx];
        chunksToIdx[entityIdx] = {
          first: prevRes._index,
          second: currRes._index
        };
        builder.addItem(entityIdx++, prevRes._controlPoint, currRes._controlPoint, stickRad, colorer.getResidueColor(prevRes, complex), colorer.getResidueColor(currRes, complex));
        prevRes = currRes;
      }
    }
    this.add(builder.getObjects());
  }
  TraceGroup.prototype = Object.create(THREE.Group.prototype);
  TraceGroup.prototype.constructor = TraceGroup;
  TraceGroup.prototype.raycast = function (raycaster, intersects) {
    if (this._builder === null) {
      return;
    }
    var inters = [];
    var residues = this._component.getComplex()._residues;
    this._builder.raycast(raycaster, inters);
    var chunksToIdx = this._chunksToIdc;
    // process inters array - arr object references
    for (var i = 0, n = inters.length; i < n; ++i) {
      if (!inters[i].hasOwnProperty('chunkIdx')) {
        continue;
      }
      var chunkIdx = inters[i].chunkIdx;
      var chunk = chunksToIdx[Math.floor(chunkIdx / 2)];
      var resIdx = chunkIdx % 2 === 0 ? chunk.first : chunk.second;
      if (resIdx < residues.length) {
        inters[i].residue = residues[resIdx];
        intersects.push(inters[i]);
      }
    }
  };
  TraceGroup.prototype._calcChunksList = function (mask) {
    if (this._chunksToIdc === null) {
      return [];
    }
    var chunksList = [];
    var chunksToIdx = this._chunksToIdc;
    var residues = this._component.getComplex()._residues;
    for (var i = 0, n = chunksToIdx.length; i < n; ++i) {
      var chunk = chunksToIdx[i];
      if (residues[chunk.first]._mask & mask) {
        chunksList.push(i * 2);
      }
      if (residues[chunk.second]._mask & mask) {
        chunksList.push(i * 2 + 1);
      }
    }
    return chunksList;
  };
  TraceGroup.prototype.getSubset = function (mask) {
    var chunksList = this._calcChunksList(mask);
    if (chunksList.length === 0) {
      return [];
    }
    var selObjects = this._builder.getSubset(chunksList);
    for (var objIdx = 0, objCount = selObjects.length; objIdx < objCount; ++objIdx) {
      selObjects[objIdx]._component = this._component;
    }
    return selObjects;
  };
  TraceGroup.prototype._changeSubsetOpacity = function (mask, value) {
    var chunksList = this._calcChunksList(mask);
    if (chunksList.length === 0) {
      return;
    }
    this._builder.setOpacity(chunksList, value);
  };
  TraceGroup.prototype.enableSubset = function (mask) {
    this._changeSubsetOpacity(mask, 1);
  };
  TraceGroup.prototype.disableSubset = function (mask) {
    this._changeSubsetOpacity(mask, 0);
  };
  function buildTraceChain(CylinderBuilderName, component, colorer, mode, polyComplexity, mask, material) {
    return new TraceGroup(CylinderBuilderName, component, colorer, mode, polyComplexity, mask, material);
  }
  return buildTraceChain;
}(three, gfx_modes_CylinderBufferGeometry);
gfx_modes_TraceMode = function (THREE, settings, gfxutils, buildChainsGeometry, CylinderBuilder, GeometryWrapper) {
  //var CylinderBuilderName = CylinderBuilder;
  var CylinderBuilderName = CylinderBuilder.getMega(GeometryWrapper);
  function TraceMode(opts) {
    this._opts = Object.create(opts);
  }
  TraceMode.prototype.id = 'TRACE_MODE';
  TraceMode.prototype.shortId = 'TR';
  TraceMode.prototype.name = TraceMode.prototype.shortName = 'Trace';
  TraceMode.prototype.getUberOptions = function () {
    return {};
  };
  TraceMode.prototype.calcStickRadius = function () {
    return this._opts.radius;
  };
  TraceMode.prototype.buildGeometry = function (complex, colorer, mask, material) {
    var polyComplexity = this._opts.polyComplexity[settings.now.resolution];
    var group = new gfxutils.RCGroup();
    var self = this;
    complex.forEachVisibleComponent(function (component) {
      var chainGroup = buildChainsGeometry(CylinderBuilderName, component, colorer, self, polyComplexity, mask, material);
      if (chainGroup.children.length === 0) {
        return;
      }
      group.add(chainGroup);
    });
    return group;
  };
  return TraceMode;
}(three, settings, gfx_gfxutils, gfx_modes_buildTraceChain, gfx_modes_SimpleCylinderBuilder, gfx_modes_BufferGeometryWrapper16);
smooth = function () {
  var AbstractInterpolator, CubicInterpolator, Enum, LinearInterpolator, NearestInterpolator, PI, SincFilterInterpolator, Smooth, clipClamp, clipMirror, clipPeriodic, defaultConfig, getColumn, getType, isValidNumber, k, makeLanczosWindow, makeScaledFunction, makeSincKernel, normalizeScaleTo, shallowCopy, sin, sinc, v, validateNumber, validateVector, __hasProp = Object.prototype.hasOwnProperty, __extends = function (child, parent) {
      for (var key in parent) {
        if (__hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
  Enum = {
    /*Interpolation methods
    */
    METHOD_NEAREST: 'nearest',
    METHOD_LINEAR: 'linear',
    METHOD_CUBIC: 'cubic',
    METHOD_LANCZOS: 'lanczos',
    METHOD_SINC: 'sinc',
    /*Input clipping modes
    */
    CLIP_CLAMP: 'clamp',
    CLIP_ZERO: 'zero',
    CLIP_PERIODIC: 'periodic',
    CLIP_MIRROR: 'mirror',
    /* Constants for control over the cubic interpolation tension
    */
    CUBIC_TENSION_DEFAULT: 0,
    CUBIC_TENSION_CATMULL_ROM: 0
  };
  defaultConfig = {
    method: Enum.METHOD_CUBIC,
    cubicTension: Enum.CUBIC_TENSION_DEFAULT,
    clip: Enum.CLIP_CLAMP,
    scaleTo: 0,
    sincFilterSize: 2,
    sincWindow: void 0
  };
  /*Index clipping functions
  */
  clipClamp = function (i, n) {
    return Math.max(0, Math.min(i, n - 1));
  };
  clipPeriodic = function (i, n) {
    i = i % n;
    if (i < 0)
      i += n;
    return i;
  };
  clipMirror = function (i, n) {
    var period;
    period = 2 * (n - 1);
    i = clipPeriodic(i, period);
    if (i > n - 1)
      i = period - i;
    return i;
  };
  /*
  Abstract scalar interpolation class which provides common functionality for all interpolators
  
  Subclasses must override interpolate().
  */
  AbstractInterpolator = function () {
    function AbstractInterpolator(array, config) {
      this.array = array.slice(0);
      this.length = this.array.length;
      if (!(this.clipHelper = {
          clamp: this.clipHelperClamp,
          zero: this.clipHelperZero,
          periodic: this.clipHelperPeriodic,
          mirror: this.clipHelperMirror
        }[config.clip])) {
        throw 'Invalid clip: ' + config.clip;
      }
    }
    AbstractInterpolator.prototype.getClippedInput = function (i) {
      if (0 <= i && i < this.length) {
        return this.array[i];
      } else {
        return this.clipHelper(i);
      }
    };
    AbstractInterpolator.prototype.clipHelperClamp = function (i) {
      return this.array[clipClamp(i, this.length)];
    };
    AbstractInterpolator.prototype.clipHelperZero = function (i) {
      return 0;
    };
    AbstractInterpolator.prototype.clipHelperPeriodic = function (i) {
      return this.array[clipPeriodic(i, this.length)];
    };
    AbstractInterpolator.prototype.clipHelperMirror = function (i) {
      return this.array[clipMirror(i, this.length)];
    };
    AbstractInterpolator.prototype.interpolate = function (t) {
      throw 'Subclasses of AbstractInterpolator must override the interpolate() method.';
    };
    return AbstractInterpolator;
  }();
  NearestInterpolator = function (_super) {
    __extends(NearestInterpolator, _super);
    function NearestInterpolator() {
      NearestInterpolator.__super__.constructor.apply(this, arguments);
    }
    NearestInterpolator.prototype.interpolate = function (t) {
      return this.getClippedInput(Math.round(t));
    };
    return NearestInterpolator;
  }(AbstractInterpolator);
  LinearInterpolator = function (_super) {
    __extends(LinearInterpolator, _super);
    function LinearInterpolator() {
      LinearInterpolator.__super__.constructor.apply(this, arguments);
    }
    LinearInterpolator.prototype.interpolate = function (t) {
      var k;
      k = Math.floor(t);
      t -= k;
      return (1 - t) * this.getClippedInput(k) + t * this.getClippedInput(k + 1);
    };
    return LinearInterpolator;
  }(AbstractInterpolator);
  CubicInterpolator = function (_super) {
    __extends(CubicInterpolator, _super);
    function CubicInterpolator(array, config) {
      this.tangentFactor = 1 - Math.max(-1, Math.min(1, config.cubicTension));
      CubicInterpolator.__super__.constructor.apply(this, arguments);
    }
    CubicInterpolator.prototype.getTangent = function (k) {
      return this.tangentFactor * (this.getClippedInput(k + 1) - this.getClippedInput(k - 1)) / 2;
    };
    CubicInterpolator.prototype.interpolate = function (t) {
      var k, m, p, t2, t3;
      k = Math.floor(t);
      m = [
        this.getTangent(k),
        this.getTangent(k + 1)
      ];
      p = [
        this.getClippedInput(k),
        this.getClippedInput(k + 1)
      ];
      t -= k;
      t2 = t * t;
      t3 = t * t2;
      return (2 * t3 - 3 * t2 + 1) * p[0] + (t3 - 2 * t2 + t) * m[0] + (-2 * t3 + 3 * t2) * p[1] + (t3 - t2) * m[1];
    };
    return CubicInterpolator;
  }(AbstractInterpolator);
  sin = Math.sin, PI = Math.PI;
  sinc = function (x) {
    if (x === 0) {
      return 1;
    } else {
      return sin(PI * x) / (PI * x);
    }
  };
  makeLanczosWindow = function (a) {
    return function (x) {
      return sinc(x / a);
    };
  };
  makeSincKernel = function (window) {
    return function (x) {
      return sinc(x) * window(x);
    };
  };
  SincFilterInterpolator = function (_super) {
    __extends(SincFilterInterpolator, _super);
    function SincFilterInterpolator(array, config) {
      SincFilterInterpolator.__super__.constructor.apply(this, arguments);
      this.a = config.sincFilterSize;
      if (!config.sincWindow)
        throw 'No sincWindow provided';
      this.kernel = makeSincKernel(config.sincWindow);
    }
    SincFilterInterpolator.prototype.interpolate = function (t) {
      var k, n, sum, _ref, _ref2;
      k = Math.floor(t);
      sum = 0;
      for (n = _ref = k - this.a + 1, _ref2 = k + this.a; _ref <= _ref2 ? n <= _ref2 : n >= _ref2; _ref <= _ref2 ? n++ : n--) {
        sum += this.kernel(t - n) * this.getClippedInput(n);
      }
      return sum;
    };
    return SincFilterInterpolator;
  }(AbstractInterpolator);
  getColumn = function (arr, i) {
    var row, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = arr.length; _i < _len; _i++) {
      row = arr[_i];
      _results.push(row[i]);
    }
    return _results;
  };
  makeScaledFunction = function (f, baseScale, scaleRange) {
    var scaleFactor, translation;
    if (scaleRange.join === '0,1') {
      return f;
    } else {
      scaleFactor = baseScale / (scaleRange[1] - scaleRange[0]);
      translation = scaleRange[0];
      return function (t) {
        return f(scaleFactor * (t - translation));
      };
    }
  };
  getType = function (x) {
    return Object.prototype.toString.call(x).slice('[object '.length, -1);
  };
  validateNumber = function (n) {
    if (isNaN(n))
      throw 'NaN in Smooth() input';
    if (getType(n) !== 'Number')
      throw 'Non-number in Smooth() input';
    if (!isFinite(n))
      throw 'Infinity in Smooth() input';
  };
  validateVector = function (v, dimension) {
    var n, _i, _len;
    if (getType(v) !== 'Array')
      throw 'Non-vector in Smooth() input';
    if (v.length !== dimension)
      throw 'Inconsistent dimension in Smooth() input';
    for (_i = 0, _len = v.length; _i < _len; _i++) {
      n = v[_i];
      validateNumber(n);
    }
  };
  isValidNumber = function (n) {
    return getType(n) === 'Number' && isFinite(n) && !isNaN(n);
  };
  normalizeScaleTo = function (s) {
    var invalidErr;
    invalidErr = 'scaleTo param must be number or array of two numbers';
    switch (getType(s)) {
    case 'Number':
      if (!isValidNumber(s))
        throw invalidErr;
      s = [
        0,
        s
      ];
      break;
    case 'Array':
      if (s.length !== 2)
        throw invalidErr;
      if (!(isValidNumber(s[0]) && isValidNumber(s[1])))
        throw invalidErr;
      break;
    default:
      throw invalidErr;
    }
    return s;
  };
  shallowCopy = function (obj) {
    var copy, k, v;
    copy = {};
    for (k in obj) {
      if (!__hasProp.call(obj, k))
        continue;
      v = obj[k];
      copy[k] = v;
    }
    return copy;
  };
  Smooth = function (arr, config) {
    var baseDomainEnd, dimension, i, interpolator, interpolatorClass, interpolators, k, n, properties, smoothFunc, v;
    if (config == null)
      config = {};
    properties = {};
    config = shallowCopy(config);
    properties.config = shallowCopy(config);
    if (config.scaleTo == null)
      config.scaleTo = config.period;
    if (config.sincFilterSize == null) {
      config.sincFilterSize = config.lanczosFilterSize;
    }
    for (k in defaultConfig) {
      if (!__hasProp.call(defaultConfig, k))
        continue;
      v = defaultConfig[k];
      if (config[k] == null)
        config[k] = v;
    }
    if (!(interpolatorClass = {
        nearest: NearestInterpolator,
        linear: LinearInterpolator,
        cubic: CubicInterpolator,
        lanczos: SincFilterInterpolator,
        sinc: SincFilterInterpolator
      }[config.method])) {
      throw 'Invalid method: ' + config.method;
    }
    if (config.method === 'lanczos') {
      config.sincWindow = makeLanczosWindow(config.sincFilterSize);
    }
    if (arr.length < 2)
      throw 'Array must have at least two elements';
    properties.count = arr.length;
    smoothFunc = function () {
      var _i, _j, _len, _len2;
      switch (getType(arr[0])) {
      case 'Number':
        properties.dimension = 'scalar';
        if (Smooth.deepValidation) {
          for (_i = 0, _len = arr.length; _i < _len; _i++) {
            n = arr[_i];
            validateNumber(n);
          }
        }
        interpolator = new interpolatorClass(arr, config);
        return function (t) {
          return interpolator.interpolate(t);
        };
      case 'Array':
        properties.dimension = dimension = arr[0].length;
        if (!dimension)
          throw 'Vectors must be non-empty';
        if (Smooth.deepValidation) {
          for (_j = 0, _len2 = arr.length; _j < _len2; _j++) {
            v = arr[_j];
            validateVector(v, dimension);
          }
        }
        interpolators = function () {
          var _results;
          _results = [];
          for (i = 0; 0 <= dimension ? i < dimension : i > dimension; 0 <= dimension ? i++ : i--) {
            _results.push(new interpolatorClass(getColumn(arr, i), config));
          }
          return _results;
        }();
        return function (t) {
          var interpolator, _k, _len3, _results;
          _results = [];
          for (_k = 0, _len3 = interpolators.length; _k < _len3; _k++) {
            interpolator = interpolators[_k];
            _results.push(interpolator.interpolate(t));
          }
          return _results;
        };
      default:
        throw 'Invalid element type: ' + getType(arr[0]);
      }
    }();
    if (config.clip === 'periodic') {
      baseDomainEnd = arr.length;
    } else {
      baseDomainEnd = arr.length - 1;
    }
    config.scaleTo || (config.scaleTo = baseDomainEnd);
    properties.domain = normalizeScaleTo(config.scaleTo);
    smoothFunc = makeScaledFunction(smoothFunc, baseDomainEnd, properties.domain);
    properties.domain.sort();
    /*copy properties
    */
    for (k in properties) {
      if (!__hasProp.call(properties, k))
        continue;
      v = properties[k];
      smoothFunc[k] = v;
    }
    return smoothFunc;
  };
  for (k in Enum) {
    if (!__hasProp.call(Enum, k))
      continue;
    v = Enum[k];
    Smooth[k] = v;
  }
  Smooth.deepValidation = true;
  return Smooth;
}();
gfx_modes_CartoonHelper = function (THREE, smooth, gfxutils) {
  var calcMatrix = gfxutils.calcChunkMatrix;
  function _buildStructureInterpolator(points, tension) {
    var path = smooth(points, {
      method: smooth.METHOD_CUBIC,
      clip: smooth.CLIP_CLAMP,
      cubicTension: tension,
      scaleTo: 1
    });
    return function (t, argTrans) {
      var transformT = argTrans;
      if (transformT === null) {
        // map our range to the [second .. last but one]
        transformT = function (tt) {
          return (tt * (points.length - 1 - 2) + 1) / (points.length - 1);
        };
      }
      var newt = transformT(t);
      var ans = path(newt);
      return new THREE.Vector3(ans[0], ans[1], ans[2]);
    };
  }
  function _addPoints(centerPoints, topPoints, idx, residue) {
    if (!residue._isValid) {
      centerPoints[idx] = centerPoints[idx - 1];
      topPoints[idx] = topPoints[idx - 1];
      return;
    }
    var cp = residue._controlPoint;
    centerPoints[idx] = [
      cp.x,
      cp.y,
      cp.z
    ];
    var tp = cp.clone().add(residue._wingVector);
    topPoints[idx] = [
      tp.x,
      tp.y,
      tp.z
    ];
  }
  function _calcPoints(component, firstIdx, lastIdx) {
    var residues = component.getResidues();
    function _prevIdx(idx) {
      return idx > 0 && residues[idx - 1]._isValid ? idx - 1 : idx;
    }
    function _nextIdx(idx) {
      return idx < residues.length - 1 && residues[idx + 1]._isValid ? idx + 1 : idx;
    }
    var topPoints = new Array(lastIdx - firstIdx + 5);
    var centerPoints = new Array(lastIdx - firstIdx + 5);
    var arrIdx = 0;
    function _extrapolate2(currIdx, nextFunc) {
      // TODO kill me please
      var theNext = nextFunc(currIdx);
      var cp = residues[currIdx]._controlPoint.clone().lerp(residues[theNext]._controlPoint, -0.25);
      var tp = cp.clone().add(residues[currIdx]._wingVector);
      centerPoints[arrIdx] = [
        cp.x,
        cp.y,
        cp.z
      ];
      topPoints[arrIdx++] = [
        tp.x,
        tp.y,
        tp.z
      ];
      centerPoints[arrIdx] = [
        cp.x,
        cp.y,
        cp.z
      ];
      topPoints[arrIdx++] = [
        tp.x,
        tp.y,
        tp.z
      ];
    }
    // Two points (prev-prev and next-next) are added to support edge conditions for cubic splines, they are ignored
    // Another two (prev and next) were added to support the outside of the sub chain
    // prev and prev-prev
    var prevIdx = _prevIdx(firstIdx);
    if (firstIdx === prevIdx) {
      // do the extrapolation
      _extrapolate2(firstIdx, _nextIdx);
    } else {
      _addPoints(centerPoints, topPoints, arrIdx++, residues[_prevIdx(prevIdx)]);
      _addPoints(centerPoints, topPoints, arrIdx++, residues[prevIdx]);
    }
    // main loop
    for (var idx = firstIdx; idx <= lastIdx; ++idx) {
      _addPoints(centerPoints, topPoints, arrIdx++, residues[idx]);
    }
    // next and next-next
    var nextIdx = _nextIdx(lastIdx);
    if (nextIdx === _nextIdx(nextIdx)) {
      // do the extrapolation
      _extrapolate2(lastIdx, _prevIdx);
    } else {
      _addPoints(centerPoints, topPoints, arrIdx++, residues[nextIdx]);
      _addPoints(centerPoints, topPoints, arrIdx, residues[_nextIdx(nextIdx)]);
    }
    return {
      centerPoints: centerPoints,
      topPoints: topPoints
    };
  }
  function MatrixHelper(component, startIdx, endIdx, segmentsCount, tension) {
    var pointsArrays = _calcPoints(component, startIdx, endIdx);
    this._topInterp = _buildStructureInterpolator(pointsArrays.topPoints, tension);
    this._centerInterp = _buildStructureInterpolator(pointsArrays.centerPoints, tension);
    this._shift = 0.5 / (endIdx - startIdx + 2);
    this._valueStep = (1 - 2 * this._shift) / (2 * (endIdx - startIdx + 1) * (segmentsCount - 1));
    this._segmentsCount = segmentsCount;
  }
  MatrixHelper.prototype.prepareMatrices = function (idx, firstRad, secondRad) {
    var mtcCount = this._segmentsCount;
    var outMtc = new Array(mtcCount);
    var currRad = new THREE.Vector2(0, 0);
    var topInterp = this._topInterp;
    var cenInterp = this._centerInterp;
    var currentValue = this._shift + this._valueStep * (mtcCount - 1) * idx;
    for (var mtxIdx = 0; mtxIdx < mtcCount; ++mtxIdx) {
      var lerpVal = Math.min(1, mtxIdx / (mtcCount - 1));
      currRad.lerpVectors(firstRad, secondRad, lerpVal);
      var currTop = topInterp(currentValue, null);
      var currCenter = cenInterp(currentValue, null);
      currentValue += this._valueStep;
      var nextCenter = cenInterp(currentValue, null);
      outMtc[mtxIdx] = calcMatrix(currCenter.clone(), nextCenter.clone(), currTop.clone().sub(currCenter), currRad);
    }
    return outMtc;
  };
  return MatrixHelper;
}(three, smooth, gfx_gfxutils);
gfx_modes_buildCartoonChains = function (THREE, settings, CartoonHelper, ExtrudedObjectBuilder) {
  function _createShape(rad, parts) {
    var pts = [];
    for (var i = 0; i < parts; ++i) {
      var a = 2 * i / parts * Math.PI;
      pts.push(new THREE.Vector3(Math.cos(a) * rad, Math.sin(a) * rad, 0));
    }
    return pts;
  }
  function ChainsGroup(GeomWrapperName, component, colorer, mode, polyComplexity, mask, material) {
    THREE.Group.call(this);
    this._component = component;
    var complex = component.getComplex();
    this._chunksToIdc = null;
    this._builder = null;
    var chunksCount = 0;
    complex.propagateResidues();
    var subs = component.getMaskedSequences(mask);
    var i, n;
    for (i = 0, n = subs.length; i < n; ++i) {
      chunksCount += subs[i].end - subs[i].start + 1;
    }
    if (chunksCount === 0) {
      return;
    }
    chunksCount *= 2;
    var idc = [
      subs[0].start,
      subs[subs.length - 1].end
    ];
    var COMPLEXITY_MULTIPLIER = mode.getHeightSegmentsRatio();
    var STD_TENSION = mode.getTension();
    var segmentsHeight = polyComplexity * COMPLEXITY_MULTIPLIER | 0;
    this._builder = new ExtrudedObjectBuilder(GeomWrapperName, _createShape(1, polyComplexity), segmentsHeight + 1, chunksCount, material);
    var builder = this._builder;
    this._chunksToIdc = new Array(chunksCount);
    var chunksToIdx = this._chunksToIdc;
    var chunkIdx = 0;
    var matrixHelper = new CartoonHelper(component, idc[0], idc[1], segmentsHeight, STD_TENSION);
    var residues = component.getResidues();
    for (i = 0, n = subs.length; i < n; ++i) {
      var prevLast = null;
      var startIdx = subs[i].start * 2;
      var endIdx = subs[i].end * 2 + 1;
      for (var idx = startIdx; idx <= endIdx; ++idx) {
        var resIdx = idx / 2 | 0;
        var currRes = residues[resIdx];
        var color = colorer.getResidueColor(currRes, complex);
        var firstRad = mode.getResidueRadius(currRes, idx % 2);
        var secondRad = mode.getResidueRadius(currRes, 1 + idx % 2);
        var mtc = matrixHelper.prepareMatrices(idx - idc[0] * 2, firstRad, secondRad);
        mtc.unshift(prevLast === null ? mtc[0] : prevLast);
        prevLast = mtc[segmentsHeight];
        chunksToIdx[chunkIdx] = currRes._index;
        builder.addChunk(chunkIdx++, mtc, color);
      }
    }
    this.add(builder.getObjects());
  }
  ChainsGroup.prototype = Object.create(THREE.Group.prototype);
  ChainsGroup.prototype.constructor = ChainsGroup;
  ChainsGroup.prototype.raycast = function (raycaster, intersects) {
    if (this._builder === null) {
      return;
    }
    var inters = [];
    var residues = this._component.getComplex()._residues;
    this._builder.raycast(raycaster, inters);
    var chunksToIdx = this._chunksToIdc;
    // process inters array - arr object references
    for (var i = 0, n = inters.length; i < n; ++i) {
      if (!inters[i].hasOwnProperty('chunkIdx')) {
        continue;
      }
      var resIdx = chunksToIdx[inters[i].chunkIdx];
      if (resIdx < residues.length) {
        inters[i].residue = residues[resIdx];
        intersects.push(inters[i]);
      }
    }
  };
  ChainsGroup.prototype._calcChunksList = function (mask) {
    if (this._chunksToIdc === null) {
      return [];
    }
    var chunksList = [];
    var residues = this._component.getComplex()._residues;
    var resIdc = this._chunksToIdc;
    for (var i = 0, n = resIdc.length; i < n; ++i) {
      var res = residues[resIdc[i]];
      if (res._mask & mask) {
        chunksList.push(i);
      }
    }
    return chunksList;
  };
  ChainsGroup.prototype.getSubset = function (mask) {
    var chunksList = this._calcChunksList(mask);
    if (chunksList.length === 0) {
      return [];
    }
    var selObjects = this._builder.getSubset(chunksList);
    for (var objIdx = 0, objCount = selObjects.length; objIdx < objCount; ++objIdx) {
      selObjects[objIdx]._component = this._component;
    }
    return selObjects;
  };
  ChainsGroup.prototype._changeSubsetOpacity = function (mask, value) {
    var chunksList = this._calcChunksList(mask);
    if (chunksList.length === 0) {
      return;
    }
    this._builder.setOpacity(chunksList, value);
  };
  ChainsGroup.prototype.enableSubset = function (mask) {
    this._changeSubsetOpacity(mask, 1);
  };
  ChainsGroup.prototype.disableSubset = function (mask) {
    this._changeSubsetOpacity(mask, 0);
  };
  function buildCartoonChain(GeomWrapperName, complex, colorer, mode, polyComplexity, mask, material) {
    return new ChainsGroup(GeomWrapperName, complex, colorer, mode, polyComplexity, mask, material);
  }
  return buildCartoonChain;
}(three, settings, gfx_modes_CartoonHelper, gfx_modes_ExtrudedObjectBuilder);
gfx_modes_TubeMode = function (THREE, settings, gfxutils, buildCartoon, GeomWrapper) {
  function TubeMode(opts) {
    this._opts = Object.create(opts);
  }
  TubeMode.prototype.id = 'TUBE_MODE';
  TubeMode.prototype.shortId = 'TU';
  TubeMode.prototype.name = TubeMode.prototype.shortName = 'Tube';
  TubeMode.prototype.getUberOptions = function () {
    return {};
  };
  TubeMode.prototype.getResidueRadius = function (_residue) {
    return this.TUBE_RADIUS;
  };
  TubeMode.prototype.getHeightSegmentsRatio = function () {
    return this._opts.heightSegmentsRatio;
  };
  TubeMode.prototype.getTension = function () {
    return this._opts.tension;
  };
  TubeMode.prototype.buildGeometry = function (complex, colorer, mask, material) {
    var rad = this._opts.radius;
    this.TUBE_RADIUS = new THREE.Vector2(rad, rad);
    var polyComplexity = this._opts.polyComplexity[settings.now.resolution];
    var self = this;
    var group = new gfxutils.RCGroup();
    complex.forEachVisibleComponent(function (component) {
      var chainGroup = buildCartoon(GeomWrapper, component, colorer, self, polyComplexity, mask, material);
      if (chainGroup.children.length === 0) {
        return;
      }
      group.add(chainGroup);
    });
    return group;
  };
  return TubeMode;
}(three, settings, gfx_gfxutils, gfx_modes_buildCartoonChains, gfx_modes_BufferGeometryWrapper16);
gfx_modes_buildNucleotideCylinders = function (THREE, CylinderBufferGeometry, settings) {
  function NucleotideCylinderGroup(CylinderBuilderName, component, colorer, mode, polyComplexity, mask, material) {
    THREE.Group.call(this);
    this._component = component;
    this._chunksToIdc = null;
    this._builder = null;
    var chunksCount = 0;
    var complex = component.getComplex();
    complex.propagateResidues();
    complex.forEachResidue(function (residue) {
      if (mask & residue._mask && residue._cylinders !== null) {
        ++chunksCount;
      }
    });
    if (chunksCount === 0) {
      return;
    }
    var geo = settings.now.zSprites ? new THREE.PlaneBufferGeometry(2, 2, 1, 1) : new CylinderBufferGeometry(1, 1, 1, Math.max(3, polyComplexity), 2, true);
    this._builder = new CylinderBuilderName(geo, chunksCount, material);
    var builder = this._builder;
    var entityIdx = 0;
    var stickRad = mode.calcStickRadius();
    this._chunksToIdc = new Array(chunksCount);
    var chunksToIdx = this._chunksToIdc;
    complex.forEachResidue(function (residue) {
      if (!(mask & residue._mask) || residue._cylinders === null) {
        return;
      }
      chunksToIdx[entityIdx] = residue._index;
      builder.addItem(entityIdx++, residue._cylinders[0]._position, residue._cylinders[1]._position, stickRad, colorer.getResidueColor(residue, complex), colorer.getResidueColor(residue, complex));
    });
    this.add(builder.getObjects());
  }
  NucleotideCylinderGroup.prototype = Object.create(THREE.Group.prototype);
  NucleotideCylinderGroup.prototype.constructor = NucleotideCylinderGroup;
  NucleotideCylinderGroup.prototype.raycast = function (raycaster, intersects) {
    if (this._builder === null) {
      return;
    }
    var inters = [];
    var residues = this._component.getComplex()._residues;
    this._builder.raycast(raycaster, inters);
    var chunksToIdx = this._chunksToIdc;
    // process inters array - arr object references
    for (var i = 0, n = inters.length; i < n; ++i) {
      if (!inters[i].hasOwnProperty('chunkIdx')) {
        continue;
      }
      var chunkIdx = inters[i].chunkIdx;
      var resIdx = chunksToIdx[Math.floor(chunkIdx / 2)];
      if (resIdx < residues.length) {
        inters[i].residue = residues[resIdx];
        intersects.push(inters[i]);
      }
    }
  };
  NucleotideCylinderGroup.prototype._calcChunksList = function (mask) {
    if (this._chunksToIdc === null) {
      return [];
    }
    var chunksList = [];
    var chunksToIdx = this._chunksToIdc;
    var residues = this._component.getComplex()._residues;
    for (var i = 0, n = chunksToIdx.length; i < n; ++i) {
      var chunk = chunksToIdx[i];
      if (residues[chunk]._mask & mask) {
        chunksList.push(i * 2);
        chunksList.push(i * 2 + 1);
      }
    }
    return chunksList;
  };
  NucleotideCylinderGroup.prototype.getSubset = function (mask) {
    var chunksList = this._calcChunksList(mask);
    if (chunksList.length === 0) {
      return [];
    }
    var selObjects = this._builder.getSubset(chunksList);
    for (var objIdx = 0, objCount = selObjects.length; objIdx < objCount; ++objIdx) {
      selObjects[objIdx]._component = this._component;
    }
    return selObjects;
  };
  NucleotideCylinderGroup.prototype._changeSubsetOpacity = function (mask, value) {
    var chunksList = this._calcChunksList(mask);
    if (chunksList.length === 0) {
      return;
    }
    this._builder.setOpacity(chunksList, value);
  };
  NucleotideCylinderGroup.prototype.enableSubset = function (mask) {
    this._changeSubsetOpacity(mask, 1);
  };
  NucleotideCylinderGroup.prototype.disableSubset = function (mask) {
    this._changeSubsetOpacity(mask, 0);
  };
  function buildTraceChain(CylinderBuilderName, component, colorer, mode, polyComplexity, mask, material) {
    return new NucleotideCylinderGroup(CylinderBuilderName, component, colorer, mode, polyComplexity, mask, material);
  }
  return buildTraceChain;
}(three, gfx_modes_CylinderBufferGeometry, settings);
gfx_modes_buildNucleotideSpheres = function (THREE, settings) {
  function NucleotideSphereGroup(SphereBuilderName, component, colorer, mode, polyComplexity, mask, material) {
    THREE.Group.call(this);
    this._component = component;
    this._chunksToIdc = null;
    this._builder = null;
    var chunksCount = 0;
    var complex = component.getComplex();
    complex.propagateResidues();
    complex.forEachResidue(function (residue) {
      if (mask & residue._mask && residue._cylinders !== null) {
        ++chunksCount;
      }
    });
    if (chunksCount === 0) {
      return;
    }
    var geo = settings.now.zSprites ? new THREE.PlaneBufferGeometry(2, 2, 1, 1) : new THREE.SphereBufferGeometry(1, polyComplexity * 2, polyComplexity, 0, Math.PI * 2, 0, Math.PI);
    var builder = new SphereBuilderName(geo, chunksCount * 2, material);
    this._builder = builder;
    var entityIdx = 0;
    var stickRad = mode.calcStickRadius();
    this._chunksToIdc = new Array(chunksCount);
    var chunksToIdx = this._chunksToIdc;
    complex.forEachResidue(function (residue) {
      if (!(mask & residue._mask) || residue._cylinders === null) {
        return;
      }
      chunksToIdx[Math.floor(entityIdx / 2)] = residue._index;
      var col = colorer.getResidueColor(residue, complex);
      builder.addItem(entityIdx++, residue._cylinders[0]._position, stickRad, col);
      builder.addItem(entityIdx++, residue._cylinders[1]._position, stickRad, col);
    });
    this.add(builder.getObjects());
  }
  NucleotideSphereGroup.prototype = Object.create(THREE.Group.prototype);
  NucleotideSphereGroup.prototype.constructor = NucleotideSphereGroup;
  NucleotideSphereGroup.prototype.raycast = function (raycaster, intersects) {
    if (this._builder === null) {
      return;
    }
    var inters = [];
    var residues = this._component.getComplex()._residues;
    this._builder.raycast(raycaster, inters);
    var chunksToIdx = this._chunksToIdc;
    // process inters array - arr object references
    for (var i = 0, n = inters.length; i < n; ++i) {
      if (!inters[i].hasOwnProperty('chunkIdx')) {
        continue;
      }
      var chunkIdx = inters[i].chunkIdx;
      var resIdx = chunksToIdx[Math.floor(chunkIdx / 2)];
      if (resIdx < residues.length) {
        inters[i].residue = residues[resIdx];
        intersects.push(inters[i]);
      }
    }
  };
  NucleotideSphereGroup.prototype._calcChunksList = function (mask) {
    if (this._chunksToIdc === null) {
      return [];
    }
    var chunksList = [];
    var chunksToIdx = this._chunksToIdc;
    var residues = this._component.getComplex()._residues;
    for (var i = 0, n = chunksToIdx.length; i < n; ++i) {
      var chunk = chunksToIdx[i];
      if (residues[chunk]._mask & mask) {
        chunksList.push(i * 2);
        chunksList.push(i * 2 + 1);
      }
    }
    return chunksList;
  };
  NucleotideSphereGroup.prototype.getSubset = function (mask) {
    var chunksList = this._calcChunksList(mask);
    if (chunksList.length === 0) {
      return [];
    }
    var selObjects = this._builder.getSubset(chunksList);
    for (var objIdx = 0, objCount = selObjects.length; objIdx < objCount; ++objIdx) {
      selObjects[objIdx]._component = this._component;
    }
    return selObjects;
  };
  NucleotideSphereGroup.prototype._changeSubsetOpacity = function (mask, value) {
    var chunksList = this._calcChunksList(mask);
    if (chunksList.length === 0) {
      return;
    }
    this._builder.setOpacity(chunksList, value);
  };
  NucleotideSphereGroup.prototype.enableSubset = function (mask) {
    this._changeSubsetOpacity(mask, 1);
  };
  NucleotideSphereGroup.prototype.disableSubset = function (mask) {
    this._changeSubsetOpacity(mask, 0);
  };
  function buildTraceChain(CylinderBuilderName, component, colorer, mode, polyComplexity, mask, material) {
    return new NucleotideSphereGroup(CylinderBuilderName, component, colorer, mode, polyComplexity, mask, material);
  }
  return buildTraceChain;
}(three, settings);
gfx_modes_CartoonMode = function (THREE, settings, gfxutils, buildCartoon, buildNucCylinders, CylinderBuilder, buildNucSpheres, SpheresBuilder, GeomWrapper) {
  var CylinderBuilderName = CylinderBuilder;
  var SpheresBuilderName = SpheresBuilder;
  function CartoonMode(opts) {
    this._opts = Object.create(opts);
  }
  CartoonMode.prototype.id = 'CARTOON_MODE';
  CartoonMode.prototype.shortId = 'CA';
  CartoonMode.prototype.name = CartoonMode.prototype.shortName = 'Cartoon';
  CartoonMode.prototype.getUberOptions = function () {
    return {};
  };
  CartoonMode.prototype.getResidueStartRadius = function (residue) {
    var second = residue.getSecondary();
    if (second === null) {
      return this.TUBE_RADIUS;
    }
    if (second._end === residue) {
      return this.ARROW_START;
    }
    return this.STRUCTURE_CENTER;
  };
  CartoonMode.prototype.getResidueEndRadius = function (residue) {
    var second = residue.getSecondary();
    if (second === null) {
      return this.TUBE_RADIUS;
    }
    if (second._end === residue) {
      return this.ARROW_END;
    }
    return this.STRUCTURE_CENTER;
  };
  CartoonMode.prototype.getResidueRadius = function (residue, val) {
    var startRad = this.getResidueStartRadius(residue);
    if (val === 0) {
      return startRad;
    }
    var endRad = this.getResidueEndRadius(residue);
    if (val === 2) {
      return endRad;
    }
    return startRad.clone().lerp(endRad, val / 2);
  };
  // TODO: remove when selection is rendered with actual geometry
  CartoonMode.prototype.calcStickRadius = function (_res) {
    return this._opts.radius;
  };
  CartoonMode.prototype.getHeightSegmentsRatio = function () {
    return this._opts.heightSegmentsRatio;
  };
  CartoonMode.prototype.getTension = function () {
    return this._opts.tension;
  };
  CartoonMode.prototype.buildGeometry = function (complex, colorer, mask, material) {
    var tubeRad = this._opts.radius;
    var secHeight = this._opts.depth;
    this.TUBE_RADIUS = new THREE.Vector2(tubeRad, tubeRad);
    this.STRUCTURE_CENTER = new THREE.Vector2(secHeight, this._opts.width);
    this.ARROW_START = new THREE.Vector2(secHeight, this._opts.arrow);
    this.ARROW_END = new THREE.Vector2(secHeight, tubeRad);
    var polyComplexity = this._opts.polyComplexity[settings.now.resolution];
    var self = this;
    var group = new gfxutils.RCGroup();
    complex.forEachVisibleComponent(function (component) {
      var chainGroup = buildCartoon(GeomWrapper, component, colorer, self, polyComplexity, mask, material);
      var cylGroup = buildNucCylinders(CylinderBuilderName, component, colorer, self, polyComplexity, mask, material);
      var sphGroup = buildNucSpheres(SpheresBuilderName, component, colorer, self, polyComplexity, mask, material);
      if (chainGroup.children.length === 0 && cylGroup.children.length === 0 && sphGroup.children.length === 0) {
        return;
      }
      group.add(chainGroup);
      group.add(cylGroup);
      group.add(sphGroup);
    });
    return group;
  };
  return CartoonMode;
}(three, settings, gfx_gfxutils, gfx_modes_buildCartoonChains, gfx_modes_buildNucleotideCylinders, gfx_modes_InstancedCylinderBuilder, gfx_modes_buildNucleotideSpheres, gfx_modes_InstancedSphereBuilder, gfx_modes_BufferGeometryWrapper16);
gfx_modes_IsoSurfaceAtomColored = function (THREE) {
  /**
   * Class for colored atom. Need for atom structure clusterization
   *
   * @param {Vector3} vCenter   Center of atom
   * @param {number}  radiusAt  Radius of atom
   */
  function IsoSurfaceAtomColored(vCenter, radiusAt) {
    this.coord = new THREE.Vector3();
    this.coord.copy(vCenter);
    this.radius = radiusAt;
    this.colorX = 0.99999;
    this.colorY = 0;
    this.colorZ = 0;
    this.atomType = 0;
  }
  return IsoSurfaceAtomColored;
}(three);
gfx_modes_IsoSurfaceNormal = function (THREE, utils) {
  // suppress some JSHint warnings
  /*jshint bitwise: false*/
  /**
   * Build normals for isosurface, using atoms information
   *
   * @param {number} numAtoms     - Number of atoms in molecule
   * @param {AtomType} atoms      - Array of atoms
   * @param {Vector3} vBoxMin     - Bounding box min
   * @param {Vector3} vBoxMax     - Bounding box max
   * @param {number} numVertices  - Number of vertices in final geometry (to render)
   * @param {Vector3} vertices    - Geometry vertices (3d coordinates array)
   * @param {number} probeRadius     - Normals for output
   *
   */
  function IsosurfaceBuildNormals(numAtoms, atoms, vBoxMin, vBoxMax, numVertices, vertices, probeRadius) {
    this._numAtoms = numAtoms;
    this._atoms = atoms;
    this._vBoxMin = new THREE.Vector3();
    this._vBoxMax = new THREE.Vector3();
    this._vBoxMin.copy(vBoxMin);
    this._vBoxMax.copy(vBoxMax);
    this._numVertices = numVertices;
    this._vertices = vertices;
    this._probeRadius = probeRadius;
    this._atomsList = null;
    this._voxelList = null;
  }
  IsosurfaceBuildNormals.prototype.createVoxels = function () {
    var dx = 0, dy = 0, dz = 0, w = 0, maxRad = 0, aveRad = 0;
    var i = 0, j = 0, numCells = 0;
    var numAtoms = 0, atoms = null;
    var side = 0, side2 = 0, side3 = 0, maxAtomsRefs = 0, numAtomsRefs = 0;
    var xScale = 0, yScale = 0, zScale = 0;
    var rad = 0, xIndMin = 0, yIndMin = 0, zIndMin = 0, xIndMax = 0, yIndMax = 0, zIndMax = 0;
    var x = 0, y = 0, z = 0, indVoxel = 0, indexNext = 0;
    var radAffect = 0, diaAffect = 0;
    var xNumVoxMult = 0, yNumVoxMult = 0, zNumVoxMult = 0;
    var numVoxX = 0, numVoxY = 0, numVoxZ = 0;
    var ATOM_VOXEL_REF_SCALE = 4.5;
    numAtoms = this._numAtoms | 0;
    atoms = this._atoms;
    dx = this._vBoxMax.x - this._vBoxMin.x;
    dy = this._vBoxMax.y - this._vBoxMin.y;
    dz = this._vBoxMax.z - this._vBoxMin.z;
    w = dx < dy ? dx : dy;
    w = dz < w ? dz : w;
    maxRad = aveRad = 0;
    i = 0 | 0;
    j = 0 | 0;
    for (i = 0; i < numAtoms; i++) {
      rad = (atoms[i].radius + this._probeRadius) * 2;
      maxRad = rad > maxRad ? rad : maxRad;
      aveRad += rad;
    }
    numCells = Math.floor(w / maxRad);
    if (numCells < 2) {
      numCells = 2;
    }
    aveRad /= numAtoms;
    this._numCells = numCells;
    this._aveRad = aveRad;
    this._maxRad = maxRad;
    side = numCells;
    side2 = numCells * numCells;
    side3 = numCells * numCells * numCells;
    xScale = 1 / (this._vBoxMax.x - this._vBoxMin.x);
    yScale = 1 / (this._vBoxMax.y - this._vBoxMin.y);
    zScale = 1 / (this._vBoxMax.z - this._vBoxMin.z);
    // estimate number of individual atom refs in each voxel list
    maxAtomsRefs = 0;
    xNumVoxMult = xScale * numCells;
    yNumVoxMult = yScale * numCells;
    zNumVoxMult = zScale * numCells;
    for (i = 0; i < numAtoms; i++) {
      radAffect = (atoms[i].radius + this._probeRadius) * ATOM_VOXEL_REF_SCALE;
      diaAffect = radAffect * 2;
      numVoxX = Math.floor(xNumVoxMult * diaAffect + 0.8);
      numVoxY = Math.floor(yNumVoxMult * diaAffect + 0.8);
      numVoxZ = Math.floor(zNumVoxMult * diaAffect + 0.8);
      // avoid case numVox? == 0
      // also use loop i <=
      numVoxX++;
      numVoxY++;
      numVoxZ++;
      maxAtomsRefs += numVoxX * numVoxY * numVoxZ;
    }
    // for (i)
    //maxAtomsRefs = numAtoms * MAX_ATOMS_IN_SINGLE_VOXEL;
    this._voxelList = utils.allocateTyped(Int32Array, side3);
    this._atomsList = utils.allocateTyped(Int32Array, maxAtomsRefs * 2);
    if (this._voxelList === null || this._atomsList === null) {
      return 0 - 1;
    }
    // init voxel list
    for (i = 0; i < side3; i++) {
      this._voxelList[i] = -1;
    }
    // init atom references pairs
    for (i = 0, j = 0; i < maxAtomsRefs; i++) {
      this._atomsList[j++] = -1;
      // atom index
      this._atomsList[j++] = -1;  // next index
    }
    numAtomsRefs = 0;
    // create voxel lists
    for (i = 0; i < numAtoms; i++) {
      // use multiplier 4 to locate this atom in different voxels
      rad = (atoms[i].radius + this._probeRadius) * ATOM_VOXEL_REF_SCALE;
      xIndMin = Math.floor((atoms[i].coord.x - this._vBoxMin.x - rad) * numCells * xScale);
      yIndMin = Math.floor((atoms[i].coord.y - this._vBoxMin.y - rad) * numCells * yScale);
      zIndMin = Math.floor((atoms[i].coord.z - this._vBoxMin.z - rad) * numCells * zScale);
      xIndMax = Math.floor((atoms[i].coord.x - this._vBoxMin.x + rad) * numCells * xScale);
      yIndMax = Math.floor((atoms[i].coord.y - this._vBoxMin.y + rad) * numCells * yScale);
      zIndMax = Math.floor((atoms[i].coord.z - this._vBoxMin.z + rad) * numCells * zScale);
      xIndMin = xIndMin >= 0 ? xIndMin : 0;
      yIndMin = yIndMin >= 0 ? yIndMin : 0;
      zIndMin = zIndMin >= 0 ? zIndMin : 0;
      xIndMax = xIndMax < numCells ? xIndMax : numCells - 1;
      yIndMax = yIndMax < numCells ? yIndMax : numCells - 1;
      zIndMax = zIndMax < numCells ? zIndMax : numCells - 1;
      for (z = zIndMin; z <= zIndMax; z++) {
        for (y = yIndMin; y <= yIndMax; y++) {
          for (x = xIndMin; x <= xIndMax; x++) {
            // add atom with index "i" to this voxel list
            indVoxel = x + y * side + z * side2;
            //assert(indVoxel >= 0);
            //assert(indVoxel < side3);
            // add first
            if (this._voxelList[indVoxel] < 0) {
              this._atomsList[numAtomsRefs * 2 + 0] = i;
              this._atomsList[numAtomsRefs * 2 + 1] = 0 - 1;
              this._voxelList[indVoxel] = numAtomsRefs;
              numAtomsRefs++;
              //assert(numAtomsRefs < maxAtomsRefs - 1);
              continue;
            }
            // insert into head of list
            indexNext = this._voxelList[indVoxel];
            this._voxelList[indVoxel] = numAtomsRefs;
            this._atomsList[numAtomsRefs * 2 + 0] = i;
            this._atomsList[numAtomsRefs * 2 + 1] = indexNext;
            numAtomsRefs++;
            if (numAtomsRefs >= maxAtomsRefs - 1) {
              console.error('Algorithm logic fail');
              return 0 - 1;
            }
          }  // for (x)
        }  // for (y)
      }  // for (z)
    }
    // for (i)
    if (numAtomsRefs !== 0 && numAtomsRefs >= maxAtomsRefs - 1) {
      console.error('Algorithm logic fail');
      return 0 - 1;
    }
    return 0;
  };
  IsosurfaceBuildNormals.prototype.destroyVoxels = function () {
    this._atomsList = null;
    this._voxelList = null;
    this._atoms = null;
    this._vertices = null;
    this._vBoxMin = null;
    this._vBoxMax = null;
  };
  /**
   * Build normals for isosurface, using atoms information
   *
   * @param {Vector3} normals     - Normals for output
   *
   * @returns {number} 0, if success
   */
  IsosurfaceBuildNormals.prototype.buildNormals = function (normals) {
    var i = 0, maxClosedAtoms = 0, numCloseAtoms = 0;
    var numVertices = 0, vertices = null;
    var vx = 0, vy = 0, vz = 0, xInd = 0, yInd = 0, zInd = 0;
    var xScale = 0, yScale = 0, zScale = 0, numCells = 0, side = 0, side2 = 0;
    var indVoxel = 0, vNormalX = 0, vNormalY = 0, vNormalZ = 0, ref = null, indexAtom = 0;
    var dx = 0, dy = 0, dz = 0, dist2 = 0, rad = 0;
    var atoms = null;
    var maxRadAffect = 0, maxRadAffect2 = 0, expScale = 0;
    var koef = 0, w = 0;
    var r25 = 2.5;
    var r01 = 0.1;
    atoms = this._atoms;
    numVertices = this._numVertices | 0;
    vertices = this._vertices;
    numCells = this._numCells;
    side = numCells;
    side2 = numCells * numCells;
    //side3 = numCells * numCells * numCells;
    xScale = 1 / (this._vBoxMax.x - this._vBoxMin.x);
    yScale = 1 / (this._vBoxMax.y - this._vBoxMin.y);
    zScale = 1 / (this._vBoxMax.z - this._vBoxMin.z);
    maxRadAffect = this._aveRad * r25;
    maxRadAffect2 = maxRadAffect * maxRadAffect;
    expScale = -this._aveRad * r01;
    // some stats
    maxClosedAtoms = 0;
    //numSlowAtoms = 0;
    // process all vertices, one by one
    for (i = 0; i < numVertices; i++) {
      vx = vertices[i].x;
      vy = vertices[i].y;
      vz = vertices[i].z;
      xInd = Math.floor((vx - this._vBoxMin.x) * numCells * xScale);
      yInd = Math.floor((vy - this._vBoxMin.y) * numCells * yScale);
      zInd = Math.floor((vz - this._vBoxMin.z) * numCells * zScale);
      indVoxel = xInd + yInd * side + zInd * side2;
      numCloseAtoms = 0;
      vNormalX = vNormalY = vNormalZ = 0;
      for (ref = this._voxelList[indVoxel]; ref >= 0; ref = this._atomsList[ref * 2 + 1]) {
        indexAtom = this._atomsList[ref * 2 + 0];
        dx = vx - atoms[indexAtom].coord.x;
        dy = vy - atoms[indexAtom].coord.y;
        dz = vz - atoms[indexAtom].coord.z;
        dist2 = dx * dx + dy * dy + dz * dz;
        if (dist2 > maxRadAffect2) {
          continue;
        }
        // get weight for gaussian smoothing
        rad = atoms[indexAtom].radius + this._probeRadius;
        koef = dist2 - rad * rad;
        if (koef < 0) {
          koef = -koef;
        }
        w = Math.exp(expScale * koef);
        vNormalX += dx * w;
        vNormalY += dy * w;
        vNormalZ += dz * w;
        numCloseAtoms++;
      }
      // for (indexAtom) all atoms in this voxel
      //assert(numCloseAtoms > 0);
      maxClosedAtoms = numCloseAtoms > maxClosedAtoms ? numCloseAtoms : maxClosedAtoms;
      // normalize vNormal
      dist2 = vNormalX * vNormalX + vNormalY * vNormalY + vNormalZ * vNormalZ;
      if (numCloseAtoms > 0) {
        koef = 1 / Math.sqrt(dist2);
        vNormalX *= koef;
        vNormalY *= koef;
        vNormalZ *= koef;
      }
      normals[i].x = vNormalX;
      normals[i].y = vNormalY;
      normals[i].z = vNormalZ;
    }
    // for (i) all vertices
    return 0;
  };
  /**
   * Build vertex colors for isosurface, using atoms information
   *
   * @param {Vector3} colors                - Colors for output
   * @param {number} radiusColorSmoothness  - Radius of smoothness sphere
   *
   * @returns {number} 0, if success
   */
  IsosurfaceBuildNormals.prototype.buildColors = function (colors, radiusColorSmoothness) {
    var i = 0  /*, numCloseAtoms = 0*/;
    var numVertices = 0, vertices = 0;
    var vx = 0, vy = 0, vz = 0, xInd = 0, yInd = 0, zInd = 0;
    var xScale = 0, yScale = 0, zScale = 0, numCells = 0, side = 0, side2 = 0;
    var indVoxel = 0, ref = null, indexAtom = 0;
    var dx = 0, dy = 0, dz = 0, dist2 = 0;
    var atoms = null;
    var maxRadAffect = 0, maxRadAffect2 = 0, rad = 0;
    var koef = 0, w = 0;
    //var KOEF_ALPHA = 1.0;
    var KOEF_ADD = 0.8;
    atoms = this._atoms;
    numVertices = this._numVertices | 0;
    vertices = this._vertices;
    numCells = this._numCells;
    side = numCells;
    side2 = numCells * numCells;
    //side3 = numCells * numCells * numCells;
    xScale = 1 / (this._vBoxMax.x - this._vBoxMin.x);
    yScale = 1 / (this._vBoxMax.y - this._vBoxMin.y);
    zScale = 1 / (this._vBoxMax.z - this._vBoxMin.z);
    maxRadAffect = radiusColorSmoothness;
    maxRadAffect2 = maxRadAffect * maxRadAffect;
    //koefAlpha = 4.4 / radiusColorSmoothness;
    // process all vertices, one by one
    for (i = 0; i < numVertices; i++) {
      vx = vertices[i].x;
      vy = vertices[i].y;
      vz = vertices[i].z;
      xInd = Math.floor((vx - this._vBoxMin.x) * numCells * xScale);
      yInd = Math.floor((vy - this._vBoxMin.y) * numCells * yScale);
      zInd = Math.floor((vz - this._vBoxMin.z) * numCells * zScale);
      indVoxel = xInd + yInd * side + zInd * side2;
      // numCloseAtoms = 0;
      var colorsClose = [];
      var weights = [];
      var weightsSum = 0;
      for (ref = this._voxelList[indVoxel]; ref >= 0; ref = this._atomsList[ref * 2 + 1]) {
        indexAtom = this._atomsList[ref * 2 + 0];
        dx = vx - atoms[indexAtom].coord.x;
        dy = vy - atoms[indexAtom].coord.y;
        dz = vz - atoms[indexAtom].coord.z;
        dist2 = dx * dx + dy * dy + dz * dz;
        if (dist2 > maxRadAffect2) {
          continue;
        }
        // get weight for gaussian smoothing
        rad = atoms[indexAtom].radius + this._probeRadius;
        koef = dist2 - rad * rad;
        if (koef < 0) {
          koef = -koef;
        }
        //w = Math.exp(expScale * koef);
        //w = 1.0 / (KOEF_ADD + Math.pow(koef, KOEF_ALPHA));
        w = 1 / (KOEF_ADD + koef);
        colorsClose.push([
          atoms[indexAtom].colorX,
          atoms[indexAtom].colorY,
          atoms[indexAtom].colorZ
        ]);
        weights.push(w);
        // save weights for use
        weightsSum += w;  // calc sum of weights fo further normalization
                          // numCloseAtoms++;
      }
      // for (indexAtom) all atoms in this voxel
      // normalized weighted sum of colors
      for (var j = 0; j < colorsClose.length; ++j) {
        var weightNormalized = weights[j] / weightsSum;
        colors[i].x += colorsClose[j][0] * weightNormalized;
        colors[i].y += colorsClose[j][1] * weightNormalized;
        colors[i].z += colorsClose[j][2] * weightNormalized;
      }
    }
    // for (i) all vertices
    return 0;
  };
  return IsosurfaceBuildNormals;
}(three, utils);
gfx_modes_IsoSurfaceCluster = function (THREE, IsoSurfaceAtomColored, utils) {
  function IsoSurfaceCluster(fileIn, pdbAtomsIn, atomsIn, vBoxMinIn, vBoxMaxIn, numVoxelsIn, colorModeIn) {
    this.complex = fileIn;
    this.atoms = atomsIn;
    this.pdbAtoms = pdbAtomsIn;
    this.numVoxels = numVoxelsIn;
    this.colorMode = colorModeIn;
    this.vBoxMin = new THREE.Vector3();
    this.vBoxMax = new THREE.Vector3();
    this.vBoxMin.copy(vBoxMinIn);
    this.vBoxMax.copy(vBoxMaxIn);
    this.voxelsRefs = null;
    this.voxels = null;
  }
  /* eslint-disable no-magic-numbers */
  IsoSurfaceCluster.prototype.atomColors = [
    new THREE.Vector3(0.8, 0.8, 0.8),
    // C
    new THREE.Vector3(0.99, 0.99, 0.99),
    // H
    new THREE.Vector3(0.9, 0.2, 0.2),
    // O
    new THREE.Vector3(0.2, 0.2, 0.9),
    // N
    new THREE.Vector3(0.3, 0.9, 0.2),
    // P
    new THREE.Vector3(0.9, 0.9, 0.2),
    // S
    new THREE.Vector3(0, 0, 0),
    // undefined
    new THREE.Vector3(0.6, 0.6, 0.6)  // undefined
  ];
  IsoSurfaceCluster.prototype.resiudeColors = [
    new THREE.Vector3(0.9, 0.9, 0.2),
    new THREE.Vector3(0, 0.9, 0.9),
    new THREE.Vector3(0.9, 0.1, 0.9),
    new THREE.Vector3(0.9, 0.4, 0.6),
    new THREE.Vector3(0.9, 0.6, 0.4),
    new THREE.Vector3(0.4, 0.6, 0.9),
    new THREE.Vector3(0.9, 0.4, 0.7),
    new THREE.Vector3(0.7, 0.3, 0.6)
  ];
  IsoSurfaceCluster.prototype.chainColors = [
    new THREE.Vector3(0.1, 0.1, 0.1),
    new THREE.Vector3(0.3, 0.3, 0.3),
    new THREE.Vector3(0.7, 0.7, 0.7),
    new THREE.Vector3(0.9, 0.9, 0.9),
    new THREE.Vector3(0.5, 0.2, 0.2),
    new THREE.Vector3(0.3, 0.7, 0.7),
    new THREE.Vector3(0.7, 0.3, 0.7),
    new THREE.Vector3(0.8, 0.2, 0.5)
  ];
  /* eslint-enable no-magic-numbers */
  IsoSurfaceCluster.prototype.destroy = function () {
    this.atoms = null;
    this.vBoxMin = null;
    this.vBoxMax = null;
    this.voxelsRefs = null;
    this.voxels = null;
  };
  /*
    IsoSurfaceCluster.prototype.buildKMeans = function(colorer) {
      var atomsClustered = [];
      var i = 0, j = 0, numAtoms = 0;
      var histTypes = null, vCenter = null, numVoxels = 0, n3 = null;
      var xScale = 0, yScale = 0, zScale = 0, v = null, xVox = null, yVox = null, zVox = null;
      var indVoxel = 0, indAtomRef = 0;
      var vaCenters = null, vaNewCenters = null, numAtomsInCluster = 0, atomClusters = null;
      var vBoxSizeX = 0, vBoxSizeY = 0, vBoxSizeZ = 0, vCellSizeX = 0, vCellSizeY = 0, vCellSizeZ = 0;
      var numClusters = 0, x = 0, y = 0, z = 0;
      var vCellMinX = 0, vCellMaxX = 0, vCellMinY = 0, vCellMaxY = 0, vCellMinZ = 0, vCellMaxZ = 0;
      var vCenterX = 0, vCenterY = 0, vCenterZ = 0;
      var indCluster4 = 0;
      var iterCompleted = 0, numIters = 0, vAtomX = 0, vAtomY = 0, vAtomZ = 0;
      var minDist2 = 0, bestClusterIndex = 0, dist2 = 0, c = 0;
      var vx = 0, vy = 0, vz = 0, indexCluster = 0;
      var maxDif2 = 0, numAtomsInThis = 0, ind = 0;
      var scale = 0, nx = 0, ny = 0, nz = 0, dx = 0, dy = 0, dz = 0, dif2 = 0, maxDif = 0, numSpheresOut = 0;
      var rad = 0, numAtomsMix = 0, dist = 0, indMax = 0, vColorX = 0, vColorY = 0, vColorZ  = 0;
      var interfaceColorer = null;
      var colorExt = null;
      var thertyTwo = 32;
      var n10 = 10;
      var r09 = 0.9, r01 = 0.1;
  
      histTypes = utils.allocateTyped(Int32Array, thertyTwo);
  
      vCenter = new THREE.Vector3();
      atomsClustered = [];
      numVoxels = this.numVoxels;
      numAtoms = this.atoms.length;
  
      n3 = numVoxels * numVoxels * numVoxels;
      this.voxelsRefs = utils.allocateTyped(Int32Array, numAtoms * 2);
      this.voxels = utils.allocateTyped(Int32Array, n3);
  
  
      interfaceColorer = colorer;
  
      vaCenters = utils.allocateTyped(Float32Array, n3 * (2 + 2));
      vaNewCenters = utils.allocateTyped(Float32Array, n3 * (2 + 2));
      numAtomsInCluster = utils.allocateTyped(Int32Array, n3);
      atomClusters = utils.allocateTyped(Int32Array, numAtoms);
      if ((vaCenters === null) || (vaNewCenters === null) || (numAtomsInCluster === null) || (atomClusters === null)) {
        console.error('FATAL: no memory');
        return null;
      }
  
  
      // init atoms list
      for (i = 0, j = 0; i < numAtoms; i++, j += 2) {
        this.voxelsRefs[j + 0] = i;
        this.voxelsRefs[j + 1] = -1;
      }
      // init voxel references (-1 means no atom)
      for (i = 0; i < n3; i++) {
        this.voxels[i] = -1;
      }
  
      // build atom list for each voxel
      xScale = 1.0 / (this.vBoxMax.x - this.vBoxMin.x);
      yScale = 1.0 / (this.vBoxMax.y - this.vBoxMin.y);
      zScale = 1.0 / (this.vBoxMax.z - this.vBoxMin.z);
      for (i = 0; i < numAtoms; i++) {
        v = this.atoms[i].coord;
        xVox = Math.floor((v.x - this.vBoxMin.x) * numVoxels * xScale);
        yVox = Math.floor((v.y - this.vBoxMin.y) * numVoxels * yScale);
        zVox = Math.floor((v.z - this.vBoxMin.z) * numVoxels * zScale);
        indVoxel = xVox + yVox * numVoxels + zVox * numVoxels * numVoxels;
        //assert(indVoxel >= 0);
        //assert(indVoxel < n3);
        indAtomRef = this.voxels[indVoxel];
  
        if (indAtomRef < 0) {
          this.voxels[indVoxel] = i;
          continue;
        }
        while (indAtomRef >= 0) {
          if (this.voxelsRefs[indAtomRef * 2 + 1] < 0) {
            break;
          }
          indAtomRef = this.voxelsRefs[indAtomRef * 2 + 1];
          //assert(indAtomRef < numAtoms);
        }
        // add new atom to list tail
        this.voxelsRefs[indAtomRef * 2 + 1] = i;
      }       // for (i) all source atoms
  
      // KMneans init number of atoms for each cluster
      for (i = 0; i < n3; i++) {
        numAtomsInCluster[i] = 0;
      }
  
      vBoxSizeX = this.vBoxMax.x - this.vBoxMin.x;
      vBoxSizeY = this.vBoxMax.y - this.vBoxMin.y;
      vBoxSizeZ = this.vBoxMax.z - this.vBoxMin.z;
  
      vCellSizeX = vBoxSizeX / numVoxels;
      vCellSizeY = vBoxSizeY / numVoxels;
      vCellSizeZ = vBoxSizeZ / numVoxels;
  
      // setup centers of clusters by non-empty cells
      numClusters = 0;
      for (z = 0; z < numVoxels; z++) {
        vCellMinZ = this.vBoxMin.z + vBoxSizeZ * z / numVoxels;
        vCellMaxZ = vCellMinZ + vCellSizeZ;
        for (y = 0; y < numVoxels; y++) {
          vCellMinY = this.vBoxMin.y + vBoxSizeY * y / numVoxels;
          vCellMaxY = vCellMinY + vCellSizeY;
          for (x = 0; x < numVoxels; x++) {
            vCellMinX = this.vBoxMin.x + vBoxSizeX * x / numVoxels;
            vCellMaxX = vCellMinX + vCellSizeX;
  
            indVoxel = x + y * numVoxels + z * numVoxels * numVoxels;
            indAtomRef = this.voxels[indVoxel];
            // check is at least 1 atom inside this cell
            if (indAtomRef < 0) {
              continue;
            }
            vCenterX = (vCellMinX + vCellMaxX) / 2;
            vCenterY = (vCellMinY + vCellMaxY) / 2;
            vCenterZ = (vCellMinZ + vCellMaxZ) / 2;
  
            // Add new cluster
            indCluster4 = numClusters * (2 + 2);
            vaCenters[indCluster4 + 0] = vCenterX;
            vaCenters[indCluster4 + 1] = vCenterY;
            vaCenters[indCluster4 + 2] = vCenterZ;
  
            numClusters++;
  
          }     // for (x)  all voxels
        }       // for (y)  all voxels
      }         // for (z)  all voxels
      if (numClusters > numAtoms) {
        console.error('Logic error: number of clusters is more then number of atoms');
        return null;
      }
      if (numClusters > n3) {
        console.error('Logic error: number of clusters is more then number of voxels ^ 3');
        return null;
      }
      // make iterations for cluster centers moving
      iterCompleted = false;
      for (numIters = 0; (numIters < n10) && (!iterCompleted); numIters++) {
        // assign for each atom cluster index
        for (i = 0; i < numAtoms; i++) {
          vAtomX = this.atoms[i].coord.x;
          vAtomY = this.atoms[i].coord.y;
          vAtomZ = this.atoms[i].coord.z;
          minDist2 = 1.0e8;
          indCluster4 = 0;
          bestClusterIndex = -1;
          for (c = 0; c < numClusters; c++, indCluster4 += 4) {
            vx = vAtomX - vaCenters[indCluster4 + 0];
            vy = vAtomY - vaCenters[indCluster4 + 1];
            vz = vAtomZ - vaCenters[indCluster4 + 2];
            dist2 = vx * vx + vy * vy + vz * vz;
            if (dist2 < minDist2) {
              minDist2 = dist2;
              bestClusterIndex = c;
            }
          }     // for (c) all clusters
          atomClusters[i] = bestClusterIndex;
        }       // for (i) all atoms
  
        // calc average cluster center
        indCluster4 = 0;
        for (c = 0; c < numClusters; c++, indCluster4 += (2 + 2)) {
          vaNewCenters[indCluster4 + 0] = 0.0;
          vaNewCenters[indCluster4 + 1] = 0.0;
          vaNewCenters[indCluster4 + 2] = 0.0;
          numAtomsInCluster[c] = 0;
        }
        for (i = 0; i < numAtoms; i++) {
          indexCluster = atomClusters[i];
          //assert(indexCluster >= 0);
          //assert(indexCluster < numClusters);
          indCluster4 = indexCluster * (2 + 2);
          vAtomX = this.atoms[i].coord.x;
          vAtomY = this.atoms[i].coord.y;
          vAtomZ = this.atoms[i].coord.z;
          vaNewCenters[indCluster4 + 0] += vAtomX;
          vaNewCenters[indCluster4 + 1] += vAtomY;
          vaNewCenters[indCluster4 + 2] += vAtomZ;
          numAtomsInCluster[indexCluster] ++;
        }   // for (i) all atoms
  
        // get ave pos for each cluster center
        maxDif2 = 0.0;
        indCluster4 = 0;
        for (c = 0; c < numClusters; c++, indCluster4 += (2 + 2)) {
          numAtomsInThis = numAtomsInCluster[c];
          if (numAtomsInThis === 0) {
            continue;
          }
          scale = 1.0 / numAtomsInThis;
          nx = vaNewCenters[indCluster4 + 0] * scale;
          ny = vaNewCenters[indCluster4 + 1] * scale;
          nz = vaNewCenters[indCluster4 + 2] * scale;
  
          dx = nx - vaCenters[indCluster4 + 0];
          dy = ny - vaCenters[indCluster4 + 1];
          dz = nz - vaCenters[indCluster4 + 2];
  
          dif2 = dx * dx + dy * dy + dz * dz;
          if (dif2 > maxDif2) {
            maxDif2 = dif2;
          }
          vaCenters[indCluster4 + 0] = nx;
          vaCenters[indCluster4 + 1] = ny;
          vaCenters[indCluster4 + 2] = nz;
        }
        maxDif = Math.sqrt(maxDif2);
        if (maxDif < (1 / 2)) {
          iterCompleted = 1;
        }
      }           // for (numIters) all iterations
  
      // Produce output atoms, using cluster centers
      numSpheresOut = 0;
  
      indCluster4 = 0;
      for (c = 0; c < numClusters; c++, indCluster4 += (2 + 2)) {
        vCenterX = vaCenters[indCluster4 + 0];
        vCenterY = vaCenters[indCluster4 + 1];
        vCenterZ = vaCenters[indCluster4 + 2];
        rad = 0.0;
        numAtomsMix = 0;
  
        for (i = 0; i < (2 << (2 + 2)); i++) {
          histTypes[i] = 0;
        }
  
        // find radius for this cluster
        for (i = 0; i < numAtoms; i++) {
          // get atom cluster index
          indexCluster = atomClusters[i];
          if (indexCluster !== c) {
            continue;
          }
  
          // get dist to cluster center
          dx = this.atoms[i].coord.x - vCenterX;
          dy = this.atoms[i].coord.y - vCenterY;
          dz = this.atoms[i].coord.z - vCenterZ;
          dist = Math.sqrt(dx * dx + dy * dy + dz * dz) + this.atoms[i].radius;
          if (dist > rad) {
            rad = dist;
          }
  
          ind = interfaceColorer.getEntityIdx(this.complex, i);
          ind &= (2 << (2 + 2)) - 1;  //31
          histTypes[ind] ++;
  
          numAtomsMix++;
        }   // for (i)
  
        // empty cluster is not included into output array
        if (numAtomsMix === 0) {
          continue;
        }
  
        if (numAtomsMix > 0) {
          // find maximum in histogram => this is most prevalent atom type in cluster
          indMax = 0|0;
          for (i = 1; i < (2 << (2 + 2)); i++) { //to 32
            if (histTypes[i] > histTypes[indMax]) {
              indMax = i;
            }
          }
  
          colorExt = interfaceColorer.getEntityColor(this.complex, indMax);
          vColorX = colorExt.r;
          vColorY = colorExt.g;
          vColorZ = colorExt.b;
        } else {
          // TODO: find closes atom instead of
          // no one found: replace with red
          vColorX = r09;
          vColorY = r01;
          vColorZ = r01;
        }
  
        vCenter.set(vCenterX, vCenterY, vCenterZ);
        atomsClustered[numSpheresOut] = new IsoSurfaceAtomColored(vCenter, rad);
        atomsClustered[numSpheresOut].colorX = vColorX;
        atomsClustered[numSpheresOut].colorY = vColorY;
        atomsClustered[numSpheresOut].colorZ = vColorZ;
        numSpheresOut++;
      }     // for (c)
  
      // free memory
      histTypes = null;
      atomClusters = null;
      numAtomsInCluster = null;
      vaNewCenters = null;
      vaCenters = null;
  
      return atomsClustered;
    };
  */
  IsoSurfaceCluster.prototype.buildSimple = function (complex, colorer) {
    var atomsClustered = [];
    var xScale = 0, yScale = 0, zScale = 0;
    var v = null, xVox = 0, yVox = 0, zVox = 0;
    var numVoxels = 0, n3 = 0;
    var numAtoms = 0, i = 0, j = 0, indVoxel = 0, indAtomRef = 0;
    var numSpheres = 0, maxNumAtomsInVoxel = 0, x = 0, y = 0, z = 0;
    var vCenterx = 0, vCentery = 0, vCenterz = 0, numAtomsInVoxel = 0;
    var atom = null;
    var vColorX = 0, vColorY = 0, vColorZ = 0;
    var rad = 0, dist = 0, vx = 0, vy = 0, vz = 0;
    var vCenter = null;
    var indVoxelY = 0, indVoxelZ = 0;
    var histTypes = null, indMax = 0, ind = 0, colRGB = null;
    histTypes = [];
    histTypes.length = 8;
    vCenter = new THREE.Vector3();
    atomsClustered = [];
    numVoxels = this.numVoxels;
    numAtoms = this.atoms.length;
    n3 = numVoxels * numVoxels * numVoxels;
    this.voxelsRefs = utils.allocateTyped(Int32Array, numAtoms * 2);
    this.voxels = utils.allocateTyped(Int32Array, n3);
    // init atoms list
    for (i = 0, j = 0; i < numAtoms; i++, j += 2) {
      this.voxelsRefs[j + 0] = i;
      this.voxelsRefs[j + 1] = 0 - 1;
    }
    // init voxel references (-1 means no atom)
    for (i = 0; i < n3; i++) {
      this.voxels[i] = -1;
    }
    // build atom list for each voxel
    xScale = 1 / (this.vBoxMax.x - this.vBoxMin.x);
    yScale = 1 / (this.vBoxMax.y - this.vBoxMin.y);
    zScale = 1 / (this.vBoxMax.z - this.vBoxMin.z);
    for (i = 0; i < numAtoms; i++) {
      v = this.atoms[i].coord;
      xVox = Math.floor((v.x - this.vBoxMin.x) * numVoxels * xScale);
      yVox = Math.floor((v.y - this.vBoxMin.y) * numVoxels * yScale);
      zVox = Math.floor((v.z - this.vBoxMin.z) * numVoxels * zScale);
      indVoxel = xVox + yVox * numVoxels + zVox * numVoxels * numVoxels;
      //assert(indVoxel >= 0);
      //assert(indVoxel < n3);
      indAtomRef = this.voxels[indVoxel];
      if (indAtomRef < 0) {
        this.voxels[indVoxel] = i;
        continue;
      }
      while (indAtomRef >= 0) {
        if (this.voxelsRefs[indAtomRef * 2 + 1] < 0) {
          break;
        }
        indAtomRef = this.voxelsRefs[indAtomRef * 2 + 1];  //assert(indAtomRef < numAtoms);
      }
      // add new atom to list tail
      this.voxelsRefs[indAtomRef * 2 + 1] = i;
    }
    // for (i) all source atoms
    // build Output atoms (clustered)
    numSpheres = 0;
    maxNumAtomsInVoxel = 0;
    for (z = 0; z < numVoxels; z++) {
      indVoxelZ = z * numVoxels * numVoxels;
      for (y = 0; y < numVoxels; y++) {
        indVoxelY = y * numVoxels;
        for (x = 0; x < numVoxels; x++) {
          indVoxel = x + indVoxelY + indVoxelZ;
          indAtomRef = this.voxels[indVoxel];
          if (indAtomRef < 0) {
            continue;
          }
          // get ave position
          vCenterx = vCentery = vCenterz = 0;
          // get num atoms in voxel
          numAtomsInVoxel = 0;
          while (indAtomRef >= 0) {
            atom = this.atoms[indAtomRef];
            vCenterx += atom.coord.x;
            vCentery += atom.coord.y;
            vCenterz += atom.coord.z;
            numAtomsInVoxel++;
            indAtomRef = this.voxelsRefs[indAtomRef * 2 + 1];
          }
          vCenterx *= 1 / numAtomsInVoxel;
          vCentery *= 1 / numAtomsInVoxel;
          vCenterz *= 1 / numAtomsInVoxel;
          // find best color (most of in histogram)
          for (i = 0; i < 2 << 2; i++) {
            histTypes[i] = 0;
          }
          atom = null;
          rad = 0;
          indAtomRef = this.voxels[indVoxel];
          while (indAtomRef >= 0) {
            atom = this.atoms[indAtomRef];
            vx = atom.coord.x - vCenterx;
            vy = atom.coord.y - vCentery;
            vz = atom.coord.z - vCenterz;
            dist = Math.sqrt(vx * vx + vy * vy + vz * vz) + atom.radius;
            if (dist > rad) {
              rad = dist;
            }
            ind = colorer.getIndex(complex, this.atoms[indAtomRef]);
            ind &= (2 << 2) - 1;
            histTypes[ind]++;
            // next atom in voxel
            indAtomRef = this.voxelsRefs[indAtomRef * 2 + 1];
          }
          // find maximum in histogram => this is most prevalent atom type in cluster
          indMax = 0;
          for (i = 1; i < 2 << 2; i++) {
            if (histTypes[i] > histTypes[indMax]) {
              indMax = i;
            }
          }
          //TODO: Earnol
          vCenter = new THREE.Color(colorer.getAtomColor(complex, this.atoms[indMax]));
          if (this.colorMode === 0) {
            vColorX = this.atomColors[indMax].x;
            vColorY = this.atomColors[indMax].y;
            vColorZ = this.atomColors[indMax].z;
          }
          if (this.colorMode === 1) {
            colRGB = this.complex.monomerTypeArray[ind].color;
            // FIXME: the array is missing
            vColorX = colRGB.r;
            vColorY = colRGB.g;
            vColorZ = colRGB.b;
          }
          if (this.colorMode !== 1 && this.colorMode !== 0) {
            vColorX = this.atomColors[indMax].x;
            vColorY = this.atomColors[indMax].y;
            vColorZ = this.atomColors[indMax].z;
          }
          vCenter.set(vCenterx, vCentery, vCenterz);
          atomsClustered[numSpheres] = new IsoSurfaceAtomColored(vCenter, rad);
          atomsClustered[numSpheres].colorX = vColorX;
          atomsClustered[numSpheres].colorY = vColorY;
          atomsClustered[numSpheres].colorZ = vColorZ;
          numSpheres++;
          maxNumAtomsInVoxel = numAtomsInVoxel > maxNumAtomsInVoxel ? numAtomsInVoxel : maxNumAtomsInVoxel;
        }  // for (x)
      }  // for (y)
    }
    // for (z)
    this.voxelsRefs = null;
    this.voxels = null;
    return atomsClustered;
  };
  return IsoSurfaceCluster;
}(three, gfx_modes_IsoSurfaceAtomColored, utils);
gfx_modes_IsoSurfaceMarchCube = function (utils) {
  /**
   * Class for marching cube
   * Stores 8 points and 8 float values are stored together in linear array
   * Int values for has intersection or not - in integer32 linear array
   * Int values for bits flags - in integer32 linear array
   *
   */
  function IsoSurfaceMarchCube() {
    this.pointsValuesLinear = null;
    this.hasIntersection = null;
    this.bitsInside = null;
  }
  IsoSurfaceMarchCube.prototype.create = function (numCellsPerSide) {
    var vx7000000 = 117440512;
    var n3 = numCellsPerSide * numCellsPerSide * numCellsPerSide;
    if (n3 > vx7000000) {
      console.log('Too large cube dimension: lead to memory huge uasge');
      return 0 - 1;
    }
    this.pointsValuesLinear = utils.allocateTyped(Float32Array, (2 << 2 + 2) * n3);
    this.hasIntersection = utils.allocateTyped(Int32Array, n3);
    this.bitsInside = utils.allocateTyped(Int32Array, n3);
    return 0;
  };
  IsoSurfaceMarchCube.prototype.destroy = function () {
    this.bitsInside = null;
    this.hasIntersection = null;
    this.pointsValuesLinear = null;
  };
  /* eslint-disable no-magic-numbers */
  IsoSurfaceMarchCube.prototype.striIndicesMarchCube = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    8,
    3,
    9,
    8,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    3,
    1,
    2,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    2,
    10,
    0,
    2,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    8,
    3,
    2,
    10,
    8,
    10,
    9,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    11,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    11,
    2,
    8,
    11,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    9,
    0,
    2,
    3,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    11,
    2,
    1,
    9,
    11,
    9,
    8,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    10,
    1,
    11,
    10,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    10,
    1,
    0,
    8,
    10,
    8,
    11,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    9,
    0,
    3,
    11,
    9,
    11,
    10,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    8,
    10,
    10,
    8,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    7,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    3,
    0,
    7,
    3,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    9,
    8,
    4,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    1,
    9,
    4,
    7,
    1,
    7,
    3,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    10,
    8,
    4,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    4,
    7,
    3,
    0,
    4,
    1,
    2,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    2,
    10,
    9,
    0,
    2,
    8,
    4,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    10,
    9,
    2,
    9,
    7,
    2,
    7,
    3,
    7,
    9,
    4,
    -1,
    -1,
    -1,
    -1,
    8,
    4,
    7,
    3,
    11,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    11,
    4,
    7,
    11,
    2,
    4,
    2,
    0,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    0,
    1,
    8,
    4,
    7,
    2,
    3,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    7,
    11,
    9,
    4,
    11,
    9,
    11,
    2,
    9,
    2,
    1,
    -1,
    -1,
    -1,
    -1,
    3,
    10,
    1,
    3,
    11,
    10,
    7,
    8,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    11,
    10,
    1,
    4,
    11,
    1,
    0,
    4,
    7,
    11,
    4,
    -1,
    -1,
    -1,
    -1,
    4,
    7,
    8,
    9,
    0,
    11,
    9,
    11,
    10,
    11,
    0,
    3,
    -1,
    -1,
    -1,
    -1,
    4,
    7,
    11,
    4,
    11,
    9,
    9,
    11,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    4,
    0,
    8,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    5,
    4,
    1,
    5,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    5,
    4,
    8,
    3,
    5,
    3,
    1,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    10,
    9,
    5,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    0,
    8,
    1,
    2,
    10,
    4,
    9,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    2,
    10,
    5,
    4,
    2,
    4,
    0,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    10,
    5,
    3,
    2,
    5,
    3,
    5,
    4,
    3,
    4,
    8,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    4,
    2,
    3,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    11,
    2,
    0,
    8,
    11,
    4,
    9,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    5,
    4,
    0,
    1,
    5,
    2,
    3,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    1,
    5,
    2,
    5,
    8,
    2,
    8,
    11,
    4,
    8,
    5,
    -1,
    -1,
    -1,
    -1,
    10,
    3,
    11,
    10,
    1,
    3,
    9,
    5,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    9,
    5,
    0,
    8,
    1,
    8,
    10,
    1,
    8,
    11,
    10,
    -1,
    -1,
    -1,
    -1,
    5,
    4,
    0,
    5,
    0,
    11,
    5,
    11,
    10,
    11,
    0,
    3,
    -1,
    -1,
    -1,
    -1,
    5,
    4,
    8,
    5,
    8,
    10,
    10,
    8,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    7,
    8,
    5,
    7,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    3,
    0,
    9,
    5,
    3,
    5,
    7,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    7,
    8,
    0,
    1,
    7,
    1,
    5,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    5,
    3,
    3,
    5,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    7,
    8,
    9,
    5,
    7,
    10,
    1,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    1,
    2,
    9,
    5,
    0,
    5,
    3,
    0,
    5,
    7,
    3,
    -1,
    -1,
    -1,
    -1,
    8,
    0,
    2,
    8,
    2,
    5,
    8,
    5,
    7,
    10,
    5,
    2,
    -1,
    -1,
    -1,
    -1,
    2,
    10,
    5,
    2,
    5,
    3,
    3,
    5,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7,
    9,
    5,
    7,
    8,
    9,
    3,
    11,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    7,
    9,
    7,
    2,
    9,
    2,
    0,
    2,
    7,
    11,
    -1,
    -1,
    -1,
    -1,
    2,
    3,
    11,
    0,
    1,
    8,
    1,
    7,
    8,
    1,
    5,
    7,
    -1,
    -1,
    -1,
    -1,
    11,
    2,
    1,
    11,
    1,
    7,
    7,
    1,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    8,
    8,
    5,
    7,
    10,
    1,
    3,
    10,
    3,
    11,
    -1,
    -1,
    -1,
    -1,
    5,
    7,
    0,
    5,
    0,
    9,
    7,
    11,
    0,
    1,
    0,
    10,
    11,
    10,
    0,
    -1,
    11,
    10,
    0,
    11,
    0,
    3,
    10,
    5,
    0,
    8,
    0,
    7,
    5,
    7,
    0,
    -1,
    11,
    10,
    5,
    7,
    11,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    6,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    3,
    5,
    10,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    0,
    1,
    5,
    10,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    8,
    3,
    1,
    9,
    8,
    5,
    10,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    6,
    5,
    2,
    6,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    6,
    5,
    1,
    2,
    6,
    3,
    0,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    6,
    5,
    9,
    0,
    6,
    0,
    2,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    9,
    8,
    5,
    8,
    2,
    5,
    2,
    6,
    3,
    2,
    8,
    -1,
    -1,
    -1,
    -1,
    2,
    3,
    11,
    10,
    6,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    11,
    0,
    8,
    11,
    2,
    0,
    10,
    6,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    9,
    2,
    3,
    11,
    5,
    10,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    10,
    6,
    1,
    9,
    2,
    9,
    11,
    2,
    9,
    8,
    11,
    -1,
    -1,
    -1,
    -1,
    6,
    3,
    11,
    6,
    5,
    3,
    5,
    1,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    11,
    0,
    11,
    5,
    0,
    5,
    1,
    5,
    11,
    6,
    -1,
    -1,
    -1,
    -1,
    3,
    11,
    6,
    0,
    3,
    6,
    0,
    6,
    5,
    0,
    5,
    9,
    -1,
    -1,
    -1,
    -1,
    6,
    5,
    9,
    6,
    9,
    11,
    11,
    9,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    10,
    6,
    4,
    7,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    3,
    0,
    4,
    7,
    3,
    6,
    5,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    9,
    0,
    5,
    10,
    6,
    8,
    4,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    6,
    5,
    1,
    9,
    7,
    1,
    7,
    3,
    7,
    9,
    4,
    -1,
    -1,
    -1,
    -1,
    6,
    1,
    2,
    6,
    5,
    1,
    4,
    7,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    5,
    5,
    2,
    6,
    3,
    0,
    4,
    3,
    4,
    7,
    -1,
    -1,
    -1,
    -1,
    8,
    4,
    7,
    9,
    0,
    5,
    0,
    6,
    5,
    0,
    2,
    6,
    -1,
    -1,
    -1,
    -1,
    7,
    3,
    9,
    7,
    9,
    4,
    3,
    2,
    9,
    5,
    9,
    6,
    2,
    6,
    9,
    -1,
    3,
    11,
    2,
    7,
    8,
    4,
    10,
    6,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    10,
    6,
    4,
    7,
    2,
    4,
    2,
    0,
    2,
    7,
    11,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    9,
    4,
    7,
    8,
    2,
    3,
    11,
    5,
    10,
    6,
    -1,
    -1,
    -1,
    -1,
    9,
    2,
    1,
    9,
    11,
    2,
    9,
    4,
    11,
    7,
    11,
    4,
    5,
    10,
    6,
    -1,
    8,
    4,
    7,
    3,
    11,
    5,
    3,
    5,
    1,
    5,
    11,
    6,
    -1,
    -1,
    -1,
    -1,
    5,
    1,
    11,
    5,
    11,
    6,
    1,
    0,
    11,
    7,
    11,
    4,
    0,
    4,
    11,
    -1,
    0,
    5,
    9,
    0,
    6,
    5,
    0,
    3,
    6,
    11,
    6,
    3,
    8,
    4,
    7,
    -1,
    6,
    5,
    9,
    6,
    9,
    11,
    4,
    7,
    9,
    7,
    11,
    9,
    -1,
    -1,
    -1,
    -1,
    10,
    4,
    9,
    6,
    4,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    10,
    6,
    4,
    9,
    10,
    0,
    8,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    0,
    1,
    10,
    6,
    0,
    6,
    4,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    3,
    1,
    8,
    1,
    6,
    8,
    6,
    4,
    6,
    1,
    10,
    -1,
    -1,
    -1,
    -1,
    1,
    4,
    9,
    1,
    2,
    4,
    2,
    6,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    0,
    8,
    1,
    2,
    9,
    2,
    4,
    9,
    2,
    6,
    4,
    -1,
    -1,
    -1,
    -1,
    0,
    2,
    4,
    4,
    2,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    3,
    2,
    8,
    2,
    4,
    4,
    2,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    4,
    9,
    10,
    6,
    4,
    11,
    2,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    2,
    2,
    8,
    11,
    4,
    9,
    10,
    4,
    10,
    6,
    -1,
    -1,
    -1,
    -1,
    3,
    11,
    2,
    0,
    1,
    6,
    0,
    6,
    4,
    6,
    1,
    10,
    -1,
    -1,
    -1,
    -1,
    6,
    4,
    1,
    6,
    1,
    10,
    4,
    8,
    1,
    2,
    1,
    11,
    8,
    11,
    1,
    -1,
    9,
    6,
    4,
    9,
    3,
    6,
    9,
    1,
    3,
    11,
    6,
    3,
    -1,
    -1,
    -1,
    -1,
    8,
    11,
    1,
    8,
    1,
    0,
    11,
    6,
    1,
    9,
    1,
    4,
    6,
    4,
    1,
    -1,
    3,
    11,
    6,
    3,
    6,
    0,
    0,
    6,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6,
    4,
    8,
    11,
    6,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7,
    10,
    6,
    7,
    8,
    10,
    8,
    9,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    7,
    3,
    0,
    10,
    7,
    0,
    9,
    10,
    6,
    7,
    10,
    -1,
    -1,
    -1,
    -1,
    10,
    6,
    7,
    1,
    10,
    7,
    1,
    7,
    8,
    1,
    8,
    0,
    -1,
    -1,
    -1,
    -1,
    10,
    6,
    7,
    10,
    7,
    1,
    1,
    7,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    6,
    1,
    6,
    8,
    1,
    8,
    9,
    8,
    6,
    7,
    -1,
    -1,
    -1,
    -1,
    2,
    6,
    9,
    2,
    9,
    1,
    6,
    7,
    9,
    0,
    9,
    3,
    7,
    3,
    9,
    -1,
    7,
    8,
    0,
    7,
    0,
    6,
    6,
    0,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7,
    3,
    2,
    6,
    7,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    3,
    11,
    10,
    6,
    8,
    10,
    8,
    9,
    8,
    6,
    7,
    -1,
    -1,
    -1,
    -1,
    2,
    0,
    7,
    2,
    7,
    11,
    0,
    9,
    7,
    6,
    7,
    10,
    9,
    10,
    7,
    -1,
    1,
    8,
    0,
    1,
    7,
    8,
    1,
    10,
    7,
    6,
    7,
    10,
    2,
    3,
    11,
    -1,
    11,
    2,
    1,
    11,
    1,
    7,
    10,
    6,
    1,
    6,
    7,
    1,
    -1,
    -1,
    -1,
    -1,
    8,
    9,
    6,
    8,
    6,
    7,
    9,
    1,
    6,
    11,
    6,
    3,
    1,
    3,
    6,
    -1,
    0,
    9,
    1,
    11,
    6,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7,
    8,
    0,
    7,
    0,
    6,
    3,
    11,
    0,
    11,
    6,
    0,
    -1,
    -1,
    -1,
    -1,
    7,
    11,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7,
    6,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    0,
    8,
    11,
    7,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    9,
    11,
    7,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    1,
    9,
    8,
    3,
    1,
    11,
    7,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    1,
    2,
    6,
    11,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    10,
    3,
    0,
    8,
    6,
    11,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    9,
    0,
    2,
    10,
    9,
    6,
    11,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6,
    11,
    7,
    2,
    10,
    3,
    10,
    8,
    3,
    10,
    9,
    8,
    -1,
    -1,
    -1,
    -1,
    7,
    2,
    3,
    6,
    2,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7,
    0,
    8,
    7,
    6,
    0,
    6,
    2,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    7,
    6,
    2,
    3,
    7,
    0,
    1,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    6,
    2,
    1,
    8,
    6,
    1,
    9,
    8,
    8,
    7,
    6,
    -1,
    -1,
    -1,
    -1,
    10,
    7,
    6,
    10,
    1,
    7,
    1,
    3,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    7,
    6,
    1,
    7,
    10,
    1,
    8,
    7,
    1,
    0,
    8,
    -1,
    -1,
    -1,
    -1,
    0,
    3,
    7,
    0,
    7,
    10,
    0,
    10,
    9,
    6,
    10,
    7,
    -1,
    -1,
    -1,
    -1,
    7,
    6,
    10,
    7,
    10,
    8,
    8,
    10,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6,
    8,
    4,
    11,
    8,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    6,
    11,
    3,
    0,
    6,
    0,
    4,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    6,
    11,
    8,
    4,
    6,
    9,
    0,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    4,
    6,
    9,
    6,
    3,
    9,
    3,
    1,
    11,
    3,
    6,
    -1,
    -1,
    -1,
    -1,
    6,
    8,
    4,
    6,
    11,
    8,
    2,
    10,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    10,
    3,
    0,
    11,
    0,
    6,
    11,
    0,
    4,
    6,
    -1,
    -1,
    -1,
    -1,
    4,
    11,
    8,
    4,
    6,
    11,
    0,
    2,
    9,
    2,
    10,
    9,
    -1,
    -1,
    -1,
    -1,
    10,
    9,
    3,
    10,
    3,
    2,
    9,
    4,
    3,
    11,
    3,
    6,
    4,
    6,
    3,
    -1,
    8,
    2,
    3,
    8,
    4,
    2,
    4,
    6,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    4,
    2,
    4,
    6,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    9,
    0,
    2,
    3,
    4,
    2,
    4,
    6,
    4,
    3,
    8,
    -1,
    -1,
    -1,
    -1,
    1,
    9,
    4,
    1,
    4,
    2,
    2,
    4,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    1,
    3,
    8,
    6,
    1,
    8,
    4,
    6,
    6,
    10,
    1,
    -1,
    -1,
    -1,
    -1,
    10,
    1,
    0,
    10,
    0,
    6,
    6,
    0,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    6,
    3,
    4,
    3,
    8,
    6,
    10,
    3,
    0,
    3,
    9,
    10,
    9,
    3,
    -1,
    10,
    9,
    4,
    6,
    10,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    9,
    5,
    7,
    6,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    3,
    4,
    9,
    5,
    11,
    7,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    0,
    1,
    5,
    4,
    0,
    7,
    6,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    11,
    7,
    6,
    8,
    3,
    4,
    3,
    5,
    4,
    3,
    1,
    5,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    4,
    10,
    1,
    2,
    7,
    6,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6,
    11,
    7,
    1,
    2,
    10,
    0,
    8,
    3,
    4,
    9,
    5,
    -1,
    -1,
    -1,
    -1,
    7,
    6,
    11,
    5,
    4,
    10,
    4,
    2,
    10,
    4,
    0,
    2,
    -1,
    -1,
    -1,
    -1,
    3,
    4,
    8,
    3,
    5,
    4,
    3,
    2,
    5,
    10,
    5,
    2,
    11,
    7,
    6,
    -1,
    7,
    2,
    3,
    7,
    6,
    2,
    5,
    4,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    4,
    0,
    8,
    6,
    0,
    6,
    2,
    6,
    8,
    7,
    -1,
    -1,
    -1,
    -1,
    3,
    6,
    2,
    3,
    7,
    6,
    1,
    5,
    0,
    5,
    4,
    0,
    -1,
    -1,
    -1,
    -1,
    6,
    2,
    8,
    6,
    8,
    7,
    2,
    1,
    8,
    4,
    8,
    5,
    1,
    5,
    8,
    -1,
    9,
    5,
    4,
    10,
    1,
    6,
    1,
    7,
    6,
    1,
    3,
    7,
    -1,
    -1,
    -1,
    -1,
    1,
    6,
    10,
    1,
    7,
    6,
    1,
    0,
    7,
    8,
    7,
    0,
    9,
    5,
    4,
    -1,
    4,
    0,
    10,
    4,
    10,
    5,
    0,
    3,
    10,
    6,
    10,
    7,
    3,
    7,
    10,
    -1,
    7,
    6,
    10,
    7,
    10,
    8,
    5,
    4,
    10,
    4,
    8,
    10,
    -1,
    -1,
    -1,
    -1,
    6,
    9,
    5,
    6,
    11,
    9,
    11,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    6,
    11,
    0,
    6,
    3,
    0,
    5,
    6,
    0,
    9,
    5,
    -1,
    -1,
    -1,
    -1,
    0,
    11,
    8,
    0,
    5,
    11,
    0,
    1,
    5,
    5,
    6,
    11,
    -1,
    -1,
    -1,
    -1,
    6,
    11,
    3,
    6,
    3,
    5,
    5,
    3,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    10,
    9,
    5,
    11,
    9,
    11,
    8,
    11,
    5,
    6,
    -1,
    -1,
    -1,
    -1,
    0,
    11,
    3,
    0,
    6,
    11,
    0,
    9,
    6,
    5,
    6,
    9,
    1,
    2,
    10,
    -1,
    11,
    8,
    5,
    11,
    5,
    6,
    8,
    0,
    5,
    10,
    5,
    2,
    0,
    2,
    5,
    -1,
    6,
    11,
    3,
    6,
    3,
    5,
    2,
    10,
    3,
    10,
    5,
    3,
    -1,
    -1,
    -1,
    -1,
    5,
    8,
    9,
    5,
    2,
    8,
    5,
    6,
    2,
    3,
    8,
    2,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    6,
    9,
    6,
    0,
    0,
    6,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    5,
    8,
    1,
    8,
    0,
    5,
    6,
    8,
    3,
    8,
    2,
    6,
    2,
    8,
    -1,
    1,
    5,
    6,
    2,
    1,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    3,
    6,
    1,
    6,
    10,
    3,
    8,
    6,
    5,
    6,
    9,
    8,
    9,
    6,
    -1,
    10,
    1,
    0,
    10,
    0,
    6,
    9,
    5,
    0,
    5,
    6,
    0,
    -1,
    -1,
    -1,
    -1,
    0,
    3,
    8,
    5,
    6,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    5,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    11,
    5,
    10,
    7,
    5,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    11,
    5,
    10,
    11,
    7,
    5,
    8,
    3,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    11,
    7,
    5,
    10,
    11,
    1,
    9,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    7,
    5,
    10,
    11,
    7,
    9,
    8,
    1,
    8,
    3,
    1,
    -1,
    -1,
    -1,
    -1,
    11,
    1,
    2,
    11,
    7,
    1,
    7,
    5,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    3,
    1,
    2,
    7,
    1,
    7,
    5,
    7,
    2,
    11,
    -1,
    -1,
    -1,
    -1,
    9,
    7,
    5,
    9,
    2,
    7,
    9,
    0,
    2,
    2,
    11,
    7,
    -1,
    -1,
    -1,
    -1,
    7,
    5,
    2,
    7,
    2,
    11,
    5,
    9,
    2,
    3,
    2,
    8,
    9,
    8,
    2,
    -1,
    2,
    5,
    10,
    2,
    3,
    5,
    3,
    7,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    2,
    0,
    8,
    5,
    2,
    8,
    7,
    5,
    10,
    2,
    5,
    -1,
    -1,
    -1,
    -1,
    9,
    0,
    1,
    5,
    10,
    3,
    5,
    3,
    7,
    3,
    10,
    2,
    -1,
    -1,
    -1,
    -1,
    9,
    8,
    2,
    9,
    2,
    1,
    8,
    7,
    2,
    10,
    2,
    5,
    7,
    5,
    2,
    -1,
    1,
    3,
    5,
    3,
    7,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    7,
    0,
    7,
    1,
    1,
    7,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    0,
    3,
    9,
    3,
    5,
    5,
    3,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    8,
    7,
    5,
    9,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    8,
    4,
    5,
    10,
    8,
    10,
    11,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    0,
    4,
    5,
    11,
    0,
    5,
    10,
    11,
    11,
    3,
    0,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    9,
    8,
    4,
    10,
    8,
    10,
    11,
    10,
    4,
    5,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    4,
    10,
    4,
    5,
    11,
    3,
    4,
    9,
    4,
    1,
    3,
    1,
    4,
    -1,
    2,
    5,
    1,
    2,
    8,
    5,
    2,
    11,
    8,
    4,
    5,
    8,
    -1,
    -1,
    -1,
    -1,
    0,
    4,
    11,
    0,
    11,
    3,
    4,
    5,
    11,
    2,
    11,
    1,
    5,
    1,
    11,
    -1,
    0,
    2,
    5,
    0,
    5,
    9,
    2,
    11,
    5,
    4,
    5,
    8,
    11,
    8,
    5,
    -1,
    9,
    4,
    5,
    2,
    11,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    5,
    10,
    3,
    5,
    2,
    3,
    4,
    5,
    3,
    8,
    4,
    -1,
    -1,
    -1,
    -1,
    5,
    10,
    2,
    5,
    2,
    4,
    4,
    2,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    10,
    2,
    3,
    5,
    10,
    3,
    8,
    5,
    4,
    5,
    8,
    0,
    1,
    9,
    -1,
    5,
    10,
    2,
    5,
    2,
    4,
    1,
    9,
    2,
    9,
    4,
    2,
    -1,
    -1,
    -1,
    -1,
    8,
    4,
    5,
    8,
    5,
    3,
    3,
    5,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    4,
    5,
    1,
    0,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    4,
    5,
    8,
    5,
    3,
    9,
    0,
    5,
    0,
    3,
    5,
    -1,
    -1,
    -1,
    -1,
    9,
    4,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    11,
    7,
    4,
    9,
    11,
    9,
    10,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    3,
    4,
    9,
    7,
    9,
    11,
    7,
    9,
    10,
    11,
    -1,
    -1,
    -1,
    -1,
    1,
    10,
    11,
    1,
    11,
    4,
    1,
    4,
    0,
    7,
    4,
    11,
    -1,
    -1,
    -1,
    -1,
    3,
    1,
    4,
    3,
    4,
    8,
    1,
    10,
    4,
    7,
    4,
    11,
    10,
    11,
    4,
    -1,
    4,
    11,
    7,
    9,
    11,
    4,
    9,
    2,
    11,
    9,
    1,
    2,
    -1,
    -1,
    -1,
    -1,
    9,
    7,
    4,
    9,
    11,
    7,
    9,
    1,
    11,
    2,
    11,
    1,
    0,
    8,
    3,
    -1,
    11,
    7,
    4,
    11,
    4,
    2,
    2,
    4,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    11,
    7,
    4,
    11,
    4,
    2,
    8,
    3,
    4,
    3,
    2,
    4,
    -1,
    -1,
    -1,
    -1,
    2,
    9,
    10,
    2,
    7,
    9,
    2,
    3,
    7,
    7,
    4,
    9,
    -1,
    -1,
    -1,
    -1,
    9,
    10,
    7,
    9,
    7,
    4,
    10,
    2,
    7,
    8,
    7,
    0,
    2,
    0,
    7,
    -1,
    3,
    7,
    10,
    3,
    10,
    2,
    7,
    4,
    10,
    1,
    10,
    0,
    4,
    0,
    10,
    -1,
    1,
    10,
    2,
    8,
    7,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    9,
    1,
    4,
    1,
    7,
    7,
    1,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    9,
    1,
    4,
    1,
    7,
    0,
    8,
    1,
    8,
    7,
    1,
    -1,
    -1,
    -1,
    -1,
    4,
    0,
    3,
    7,
    4,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    8,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    10,
    8,
    10,
    11,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    0,
    9,
    3,
    9,
    11,
    11,
    9,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    10,
    0,
    10,
    8,
    8,
    10,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    1,
    10,
    11,
    3,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    11,
    1,
    11,
    9,
    9,
    11,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    0,
    9,
    3,
    9,
    11,
    1,
    2,
    9,
    2,
    11,
    9,
    -1,
    -1,
    -1,
    -1,
    0,
    2,
    11,
    8,
    0,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    2,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    3,
    8,
    2,
    8,
    10,
    10,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    10,
    2,
    0,
    9,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    3,
    8,
    2,
    8,
    10,
    0,
    1,
    8,
    1,
    10,
    8,
    -1,
    -1,
    -1,
    -1,
    1,
    10,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    3,
    8,
    9,
    1,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    9,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    3,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  /* eslint-enable no-magic-numbers */
  return IsoSurfaceMarchCube;
}(utils);
gfx_modes_IsoSurfaceGeo = function (THREE) {
  /**
   * Class for geometry (triangle mesh) representation
   *
   *
   * @param {number} maxNumVertices Maximum possible number of vertices in mesh
   * @param {number} maxNumTriangles Maximum possible number of triangles in mesh
   * @param {boolean} needVertexColors Obvious
   */
  function IsoSurfaceGeo(maxNumVertices, maxNumTriangles, needVertexColors) {
    var i = 0;
    var ten = 10;
    this._maxNumVertices = maxNumVertices;
    this._maxNumTriangles = maxNumTriangles;
    this._vertices = new Array(maxNumVertices);
    this._normals = new Array(maxNumVertices);
    this._colors = null;
    if (needVertexColors) {
      this._colors = new Array(maxNumVertices);
    }
    this._indices = new Array(maxNumTriangles * (1 + 2));
    this._numVertices = 0;
    this._numTriangles = 0;
    for (i = 0; i < maxNumVertices; i++) {
      this._vertices[i] = new THREE.Vector3();
      this._normals[i] = new THREE.Vector3();
    }
    for (i = 0; i < maxNumTriangles * (1 + 2); i++) {
      this._indices[i] = -1;
    }
    if (needVertexColors) {
      for (i = 0; i < maxNumVertices; i++) {
        this._colors[i] = new THREE.Vector3();
        this._colors[i].set(1 / ten, 2 / ten, 2 / ten);
      }
    }
  }
  IsoSurfaceGeo.prototype.destroy = function () {
    this._vertices = null;
    this._normals = null;
    this._indices = null;
  };
  return IsoSurfaceGeo;
}(three);
gfx_modes_IsoSurfaceMode = function (THREE, settings, IsoSurfaceAtomColored, IsoSurfaceNormal, IsoSurfaceCluster, IsoSurfaceMarchCube, IsoSurfaceGeo, UberMaterial, AtomType, utils) {
  function IsoSurfaceMode(excludeProbe, opts) {
    if (excludeProbe !== this._excludeProbe) {
      this._excludeProbe = excludeProbe;
    }
    this._opts = Object.create(opts);
  }
  IsoSurfaceMode.prototype.id = 'ISOSURFACE_MODE';
  IsoSurfaceMode.prototype.shortId = 'SU';
  IsoSurfaceMode.prototype.name = IsoSurfaceMode.prototype.shortName = 'Surface';
  IsoSurfaceMode.prototype._radScale = 1;
  IsoSurfaceMode.prototype._isVertexNormalsRendered = false;
  IsoSurfaceMode.prototype._isSurfaceTransparent = false;
  IsoSurfaceMode.prototype._isGeometrySolid = true;
  // TODO: move to advanced visualization UI next 3 params
  IsoSurfaceMode.prototype._clusterViaKMeans = 0;
  // 0: no cluster, 1: KMeans, 2: SimplestClusterization
  IsoSurfaceMode.prototype._probeRadius = 1.5;
  IsoSurfaceMode.prototype._excludeProbe = false;
  function IsoSurfaceGroup() {
    THREE.Group.call(this);
  }
  IsoSurfaceGroup.prototype = Object.create(THREE.Group.prototype);
  IsoSurfaceGroup.prototype.constructor = IsoSurfaceGroup;
  IsoSurfaceGroup.prototype.getSubset = function (_mask) {
    return [];
  };
  IsoSurfaceGroup.prototype.onBeforeRender = function (camera) {
    var modelView = new THREE.Matrix4().multiplyMatrices(this.matrixWorld, camera.matrixWorldInverse);
    var scale = new THREE.Vector3().setFromMatrixColumn(modelView, 0);
    var s = scale.length();
    for (var i = 0; i < this.children.length; ++i) {
      var m = this.children[i];
      var center = new THREE.Vector3().copy(m.geometry.boundingSphere.center);
      m.localToWorld(center);
      m.material.uberOptions.zClipValue = camera.position.z - center.z - s * (m.material.uberOptions.zClipCoef * m.geometry.boundingSphere.radius);
    }
  };
  IsoSurfaceMode.prototype.getUberOptions = function () {
    return { zClipCoef: this._opts.zClip ? 0.5 : 2 };
  };
  IsoSurfaceMode.prototype.buildGeometry = function (complex, colorer, mask, material) {
    var objects = new IsoSurfaceGroup();
    this._geometryBuilder(function (o) {
      objects.add(o);
    }, complex, colorer, mask, material);
    return objects;
  };
  IsoSurfaceMode.prototype._geometryBuilder = function (adder, complex, colorer, mask, protoMaterial) {
    var i = 0, j = 0;
    var sto = 100;
    var isosurfaceBuilder = new IsoSurfaceMode.prototype.IsosurfaceBuilder(complex, mask, this._opts.polyComplexity[settings.now.resolution], this._radScale, colorer, this._clusterViaKMeans, this._probeRadius, this._excludeProbe);
    // convert geoOut into arrays of positions, indices, normals
    isosurfaceBuilder.build();
    var geoOut = isosurfaceBuilder.getGeo();
    var posCenter = isosurfaceBuilder.getPosCenter();
    isosurfaceBuilder.destroy();
    isosurfaceBuilder = null;
    var colors = null;
    var positions = utils.allocateTyped(Float32Array, (1 + 2) * geoOut._numVertices);
    var normals = utils.allocateTyped(Float32Array, (1 + 2) * geoOut._numVertices);
    if (geoOut._colors !== null) {
      colors = utils.allocateTyped(Float32Array, (1 + 2) * geoOut._numVertices);
    }
    var indices = utils.allocateTyped(Uint32Array, (1 + 2) * geoOut._numTriangles);
    j = 0;
    for (i = 0; i < geoOut._numVertices; i++) {
      positions[j + 0] = geoOut._vertices[i].x - posCenter.x;
      positions[j + 1] = geoOut._vertices[i].y - posCenter.y;
      positions[j + 2] = geoOut._vertices[i].z - posCenter.z;
      normals[j + 0] = geoOut._normals[i].x;
      normals[j + 1] = geoOut._normals[i].y;
      normals[j + 2] = geoOut._normals[i].z;
      j += 3;
    }
    if (colors !== null) {
      for (i = 0, j = 0; i < geoOut._numVertices; i++, j += 3) {
        colors[j + 0] = geoOut._colors[i].x;
        colors[j + 1] = geoOut._colors[i].y;
        colors[j + 2] = geoOut._colors[i].z;
      }
    }
    var numTri3 = geoOut._numTriangles * (1 + 2);
    for (i = 0; i < numTri3; i++) {
      indices[i] = geoOut._indices[i];
    }
    if (this._isVertexNormalsRendered) {
      var geoLines = null, v = null, n = null, xBoxMin = null;
      var xBoxMax = null, yBoxMin = null, yBoxMax = null, zBoxMin = null, zBoxMax = null, dx = null, dy = null;
      var dz = null, diag = null, vecScale = null;
      var vStart = null, vEnd = null;
      // calc normal line length
      xBoxMin = xBoxMax = positions[0];
      yBoxMin = yBoxMax = positions[1];
      zBoxMin = zBoxMax = positions[2];
      for (i = 0, j = 0; i < geoOut._numVertices; i += 1, j += 3) {
        xBoxMin = positions[j + 0] < xBoxMin ? positions[j + 0] : xBoxMin;
        yBoxMin = positions[j + 1] < yBoxMin ? positions[j + 1] : yBoxMin;
        zBoxMin = positions[j + 2] < zBoxMin ? positions[j + 2] : zBoxMin;
        xBoxMax = positions[j + 0] > xBoxMax ? positions[j + 0] : xBoxMax;
        yBoxMax = positions[j + 1] > yBoxMax ? positions[j + 1] : yBoxMax;
        zBoxMax = positions[j + 2] > zBoxMax ? positions[j + 2] : zBoxMax;
      }
      dx = xBoxMax - xBoxMin;
      dy = yBoxMax - yBoxMin;
      dz = zBoxMax - zBoxMin;
      diag = Math.sqrt(dx * dx + dy * dy + dz * dz);
      vecScale = diag / sto;
      // build vertex pairs for line rendering
      v = new THREE.Vector3();
      geoLines = new THREE.Geometry();
      for (i = 0, j = 0; i < geoOut._numVertices; i += 1, j += 3) {
        v.x = positions[j + 0];
        v.y = positions[j + 1];
        v.z = positions[j + 2];
        n = geoOut._normals[i];
        n.multiplyScalar(vecScale);
        vStart = new THREE.Vector3();
        vEnd = new THREE.Vector3();
        vStart.copy(v);
        v.add(n);
        vEnd.copy(v);
        geoLines.vertices.push(vStart);
        geoLines.vertices.push(vEnd);
      }
      geoLines.computeBoundingSphere();
      var matLines = new THREE.LineBasicMaterial({ color: 16711680 });
      var objLines = new THREE.LineSegments(geoLines, matLines);
      objLines.position.copy(posCenter);
      adder(objLines);
    }
    // if (need not render vertex normals)
    geoOut.destroy();
    geoOut = null;
    var materialParams = {
      side: THREE.DoubleSide,
      attrColor: true,
      zClip: true,
      fakeOpacity: settings.now.isoSurfaceFakeOpacity
    };
    if (!this._isGeometrySolid) {
      materialParams.wireframe = true;
    }
    var material = protoMaterial.createInstance();
    material.setValues(materialParams);
    if (this._isSurfaceTransparent) {
      material.uberOptions.opacity = 0.5;
    }
    var geo = new THREE.BufferGeometry();
    geo.setIndex(new THREE.BufferAttribute(indices, 1));
    geo.addAttribute('position', new THREE.BufferAttribute(positions, 1 + 2));
    geo.addAttribute('normal', new THREE.BufferAttribute(normals, 1 + 2));
    if (colors !== null) {
      geo.addAttribute('color', new THREE.BufferAttribute(colors, 1 + 2));
    }
    geo.computeBoundingSphere();
    var object = new THREE.Mesh(geo, material);
    object.position.copy(posCenter);
    //object.scale.multiplyScalar(25);
    adder(object);
  };
  // suppress some JSHint warnings
  /*jshint bitwise: false*/
  IsoSurfaceMode.prototype.getTriangleArea = function (v1, v2, v3) {
    var v12 = null, v23 = null, v31 = null;
    var a = null, b = null, c = null, s = null;
    v12 = new THREE.Vector3();
    v23 = new THREE.Vector3();
    v31 = new THREE.Vector3();
    v12.subVectors(v2, v1);
    v23.subVectors(v3, v2);
    v31.subVectors(v1, v3);
    a = v12.length();
    b = v23.length();
    c = v31.length();
    s = (a + b + c) / 2;
    return Math.sqrt(s * (s - a) * (s - b) * (s - c));
  };
  /**
   * Build vertex normals for traingle mesh
   *
   * @param {number}  numVertices  num vertices in mesh
   * @param {Vector3} vertices     Array of vertices
   * @param {number}  fnormals     float32 array
   * @param {number}  numTriangles num of triangles in mesh
   * @param {array}   indices     int array of triangle indices
   */
  IsoSurfaceMode.prototype.buildVertexNormals = function (numVertices, vertices, fnormals, numTriangles, indices) {
    var i = 0, ind = 0;
    var i0 = 0, i1 = 0, i2 = 0;
    var s = 0;
    //var area;
    var faceNormals = new Array(numTriangles);
    var v0 = new THREE.Vector3();
    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    var v01 = new THREE.Vector3();
    var v02 = new THREE.Vector3();
    var vNormal = new THREE.Vector3();
    for (i = 0, ind = 0; i < numTriangles; i++, ind += 1 + 2) {
      faceNormals[i] = new THREE.Vector3();
      i0 = indices[ind + 0];
      i1 = indices[ind + 1];
      i2 = indices[ind + 2];
      v0.x = vertices[i0 * (1 + 2) + 0];
      v0.y = vertices[i0 * (1 + 2) + 1];
      v0.z = vertices[i0 * (1 + 2) + 2];
      v1.x = vertices[i1 * (1 + 2) + 0];
      v1.y = vertices[i1 * (1 + 2) + 1];
      v1.z = vertices[i1 * (1 + 2) + 2];
      v2.x = vertices[i2 * (1 + 2) + 0];
      v2.y = vertices[i2 * (1 + 2) + 1];
      v2.z = vertices[i2 * (1 + 2) + 2];
      v01.subVectors(v1, v0);
      v02.subVectors(v2, v0);
      vNormal.crossVectors(v01, v02);
      vNormal.normalize();
      //area = getTriangleArea(v0, v1, v2);
      //vNormal.multiplyScalar(area);
      faceNormals[i].copy(vNormal);
    }
    // zero vertex normals
    var vertShared = [];
    var normals = [];
    for (i = 0; i < numVertices; i++) {
      vertShared[i] = 0;
      normals[i] = new THREE.Vector3();
      normals[i].x = normals[i].y = normals[i].z = 0;
    }
    // visit each face and add face normal to vertex normal (for 3 face vertices)
    for (i = 0, ind = 0; i < numTriangles; i++, ind += 1 + 2) {
      vNormal = faceNormals[i];
      i0 = indices[ind + 0];
      i1 = indices[ind + 1];
      i2 = indices[ind + 2];
      normals[i0].add(vNormal);
      normals[i1].add(vNormal);
      normals[i2].add(vNormal);
      vertShared[i0]++;
      vertShared[i1]++;
      vertShared[i2]++;
    }
    // average normals
    for (i = 0; i < numVertices; i++) {
      vNormal = normals[i];
      if (vertShared[i] > 0) {
        s = 1 / vertShared[i];
        vNormal.multiplyScalar(s);
        vNormal.normalize();
        normals[i].copy(vNormal);
      }
    }
    // convert Vector3 normals into float normals
    for (i = 0, ind = 0; i < numVertices; i++, ind += 3) {
      fnormals[ind + 0] = normals[i].x;
      fnormals[ind + 1] = normals[i].y;
      fnormals[ind + 2] = normals[i].z;
    }
    // remove objects
    vertShared = null;
    faceNormals = null;
    normals = null;
    v0 = v1 = v2 = v01 = v02 = vNormal = null;
  };
  /**
   * Class to build isosurface for  (atoms) array taken from PDB file
   *
   * Use methods
   *   build: to build isosurface
   *   getGeo: return builded geometry
   *   getPosCenter: return (Vector3) position of scene center
   *
   * @param {Complex} complex Source pdb file structure
   * @param {number} mask - bit mask for atom selection
   * @param {number} meshResolution Number of divisions of marching cube
   * @param {number} atomRadiusScale scale factor
   * @param {number} colorMode in [0..5]
   * @param {number} clusterizationType 0: no clusterization, 1: KMeans cluster, 2: SimplestVoxelClusterization
   * @param {number} probeRadius probe sphere radius (typically, this is 1.5a)
   * @param {bool} excludeProbe: true or false
   */
  IsoSurfaceMode.prototype.IsosurfaceBuilder = function (complex, mask, meshResolution, atomRadiusScale, colorMode, clusterizationType, probeRadius, excludeProbe) {
    var HASH_SIZE = 32768;
    this.complex = complex;
    this.atoms = [];
    this.meshResolution = meshResolution;
    this.atomRadiusScale = atomRadiusScale;
    this.colorMode = colorMode;
    this.probeRadius = probeRadius;
    this.useVertexColors = true;
    this.excludeProbe = excludeProbe;
    this.colorMode = colorMode;
    this.clusterizationType = clusterizationType;
    this.posCenter = null;
    this.geoOut = null;
    this.hashLines = null;
    this.hashEntries = null;
    this.numHashEtriesAllocated = 0;
    this.numHashEntryIndex = 0;
    this.maxNumVertices = 0;
    this.maxNumTriangles = 0;
    var atomList = this.atoms;
    var atomCount = 0;
    complex.forEachAtom(function (atom) {
      // FIXME: probably slow, inline
      if (atom._mask & mask) {
        atomList[atomCount++] = atom;
      }
    });
    // pointValuesLinear layout. Each array element is float32
    //
    // [ 0] xPoint 0
    // [ 1] yPoint 0
    // [ 2] zPoint 0
    // [ 3] xPoint 1
    // [ 4] yPoint 1
    // [ 5] zPoint 1
    // [ 6] xPoint 2
    // [ 7] yPoint 2
    // [ 8] zPoint 2
    // [ 9] xPoint 3
    // [10] yPoint 3
    // [11] zPoint 3
    // [12] xPoint 4
    // [13] yPoint 4
    // [14] zPoint 4
    // [15] xPoint 5
    // [16] yPoint 5
    // [17] zPoint 5
    // [18] xPoint 6
    // [19] yPoint 6
    // [20] zPoint 6
    // [21] xPoint 7
    // [22] yPoint 7
    // [23] zPoint 7
    // [24] value 0
    // [25] value 1
    // [26] value 2
    // [27] value 3
    // [28] value 4
    // [29] value 5
    // [30] value 6
    // [31] value 7
    this.getGeo = function () {
      return this.geoOut;
    };
    this.getPosCenter = function () {
      return this.posCenter;
    };
    this.destroy = function () {
      this.atoms = null;
      this.posCenter = null;
      this.hashLines = null;
      this.hashEntries = null;
    };
    /**
     * Calculates bounding box for array with spheres (atoms)
     *
     * @param {Object}  atoms      Atoms array
     * @param {Vector3} vBoxMin    Bounding box min point
     * @param {Vector3} vBoxMax    Bounding box max point
     */
    this.getBoundingBox = function (atoms, vBoxMin, vBoxMax) {
      var i = 0, num = 0;
      var vCenter = null, rad = 0, radMax = 0;
      var probeRadius2 = 0;
      var bigNum = 10000000;
      vBoxMin.x = vBoxMin.y = vBoxMin.z = bigNum;
      vBoxMax.x = vBoxMax.y = vBoxMax.z = 0 - bigNum;
      probeRadius2 = this.probeRadius * this.atomRadiusScale;
      radMax = 0;
      num = atoms.length;
      for (i = 0; i < num; i++) {
        vCenter = atoms[i].coord;
        rad = atoms[i].radius + probeRadius2;
        radMax = rad > radMax ? rad : radMax;
        if (vCenter.x - rad < vBoxMin.x) {
          vBoxMin.x = vCenter.x - rad;
        }
        if (vCenter.y - rad < vBoxMin.y) {
          vBoxMin.y = vCenter.y - rad;
        }
        if (vCenter.z - rad < vBoxMin.z) {
          vBoxMin.z = vCenter.z - rad;
        }
        if (vCenter.x + rad > vBoxMax.x) {
          vBoxMax.x = vCenter.x + rad;
        }
        if (vCenter.y + rad > vBoxMax.y) {
          vBoxMax.y = vCenter.y + rad;
        }
        if (vCenter.z + rad > vBoxMax.z) {
          vBoxMax.z = vCenter.z + rad;
        }
      }
      vBoxMin.x -= radMax;
      vBoxMin.y -= radMax;
      vBoxMin.z -= radMax;
      vBoxMax.x += radMax;
      vBoxMax.y += radMax;
      vBoxMax.z += radMax;
    };
    /**
     * Calculate (x,y,z) cordinate of the cell corner point
     *
     * @param {Vector3} vBoxMin Bounding box min point
     * @param {Vector3} vBoxMax Bounding box max point
     * @param {number} x Cell integer x coordinate
     * @param {number} y Cell integer y coordinate
     * @param {number} z Cell integer z coordinate
     * @param {number} numPoints NUm points in cell on side
     * @param {Vector3} vOut Output vector
     */
    this.getCornerCoord = function (vBoxMin, vBoxMax, x, y, z, numPoints, vOut) {
      var invNP = 0, tx = 0, ty = 0, tz = 0;
      invNP = 1 / (numPoints - 1);
      tx = x * invNP;
      ty = y * invNP;
      tz = z * invNP;
      vOut.x = vBoxMin.x * (1 - tx) + vBoxMax.x * tx;
      vOut.y = vBoxMin.y * (1 - ty) + vBoxMax.y * ty;
      vOut.z = vBoxMin.z * (1 - tz) + vBoxMax.z * tz;
    };
    /**
     * Calculate point of intersection of sphere surface
     * and cell edge, given by [indexA, indexB] line
     *
     * @param {number} indexA Cell vertex index in [0..11]
     * @param {number} indexB Cell vertex index in [0..11]
     * @param {array}  sign   Sign array for all 8 vertices
     * @param {object} cube   Cube
     * @param {number} indexPointValue for value placement
     * @param {Vector3} vOut  Point of intersection
     */
    this.buildEdgePoint = function (indexA, indexB, sign, cube, indexPointValue, vOut) {
      var t = 0, xa = 0, ya = 0, za = 0, xb = 0, yb = 0, zb = 0;
      if (sign[indexA] ^ sign[indexB]) {
        t = (0 - cube.pointsValuesLinear[indexPointValue + (2 + 1 << 2 + 1) + indexA]) / (cube.pointsValuesLinear[indexPointValue + (2 + 1 << 2 + 1) + indexB] - cube.pointsValuesLinear[indexPointValue + (2 + 1 << 2 + 1) + indexA]);
        xa = cube.pointsValuesLinear[indexPointValue + indexA * (2 + 1) + 0];
        ya = cube.pointsValuesLinear[indexPointValue + indexA * (2 + 1) + 1];
        za = cube.pointsValuesLinear[indexPointValue + indexA * (2 + 1) + 2];
        xb = cube.pointsValuesLinear[indexPointValue + indexB * (2 + 1) + 0];
        yb = cube.pointsValuesLinear[indexPointValue + indexB * (2 + 1) + 1];
        zb = cube.pointsValuesLinear[indexPointValue + indexB * (2 + 1) + 2];
        vOut.x = xa * (1 - t) + xb * t;
        vOut.y = ya * (1 - t) + yb * t;
        vOut.z = za * (1 - t) + zb * t;
      }
    };
    /**
     * Build result geometry (triangle mesh) from marching cube cells
     *
     * @param {number} meshRes Marchnig cube vertex count on each side
     * @param {Vector3} vBoxMin Bounding box point min
     * @param {Vector3} vBoxMax Bounding box point max
     * @param {number} corners float values array for each cube point
     * @param {Vector3} vCellStep vector to next cube cell diagonal point
     * @param {object} cube IsoSurfaceMarchCube object
     * @param {object} geoOut Output geometry with triangle mesh arrays inside
     * @returns {number} 0, if success (<0) is error
     */
    this.buildGeoFromCorners = function (meshRes, vBoxMin, vBoxMax, corners, vCellStep, cube, geoOut) {
      var i = 0, j = 0, indCell = 0, indY = 0, indZ = 0, bitsInside = 0;
      var vCorner = null;
      var vaEdges = null;
      var v0 = null, v1 = null, v2 = null;
      var indInGeo0 = 0, indInGeo1 = 0, indInGeo2 = 0;
      var x = 0, y = 0, z = 0;
      var side = 0, side2 = 0;
      var numCells = 0;
      var offs = 0, i0 = 0, i1 = 0, i2 = 0, numTri = 0, indTri = 0, itr = 0;
      var indPointValues = 0, indValues = 0;
      var arrSize = 12;
      numCells = meshRes - 1;
      side = meshRes;
      side2 = meshRes * meshRes;
      //side3 = meshRes * meshRes * meshRes;
      vaEdges = new Array(arrSize);
      for (i = 0; i < arrSize; i++) {
        vaEdges[i] = new THREE.Vector3();
      }
      var sign = new Array(2 << 2);
      for (i = 0; i < 2 << 2; i++) {
        sign[i] = 1;
      }
      // var numCellsIntersected   = 0;
      // var numTrianglesGenerated = 0;
      v0 = new THREE.Vector3();
      v1 = new THREE.Vector3();
      v2 = new THREE.Vector3();
      vCorner = new THREE.Vector3();
      indCell = 0;
      indY = 0;
      for (y = 0; y < numCells; y++, indY += side2) {
        indZ = 0;
        for (z = 0; z < numCells; z++, indZ += side) {
          for (x = 0; x < numCells; x++) {
            if (!cube.hasIntersection[indCell]) {
              // next cell
              indCell++;
              continue;
            }
            bitsInside = cube.bitsInside[indCell];
            this.getCornerCoord(vBoxMin, vBoxMax, x, y, z, meshRes, vCorner);
            indPointValues = indCell * (2 << 2 + 2);
            for (i = 0, j = 0; i < 2 << 2; i++) {
              cube.pointsValuesLinear[indPointValues + j] = vCorner.x;
              j++;
              cube.pointsValuesLinear[indPointValues + j] = vCorner.y;
              j++;
              cube.pointsValuesLinear[indPointValues + j] = vCorner.z;
              j++;
            }
            //cell._points[1].x += vCellStep.x;
            //cell._points[2].x += vCellStep.x;
            //cell._points[5].x += vCellStep.x;
            //cell._points[6].x += vCellStep.x;
            cube.pointsValuesLinear[indPointValues + 1 * (1 + 2) + 0] += vCellStep.x;
            cube.pointsValuesLinear[indPointValues + 2 * (1 + 2) + 0] += vCellStep.x;
            cube.pointsValuesLinear[indPointValues + (1 + 2 + 2) * (1 + 2) + 0] += vCellStep.x;
            cube.pointsValuesLinear[indPointValues + (1 + 2 + (1 + 2)) * (1 + 2) + 0] += vCellStep.x;
            //cell._points[2].z += vCellStep.z;
            //cell._points[3].z += vCellStep.z;
            //cell._points[6].z += vCellStep.z;
            //cell._points[7].z += vCellStep.z;
            cube.pointsValuesLinear[indPointValues + 2 * (1 + 2) + 2] += vCellStep.z;
            cube.pointsValuesLinear[indPointValues + (1 + 2) * (1 + 2) + 2] += vCellStep.z;
            cube.pointsValuesLinear[indPointValues + (2 + 2 + 2) * (1 + 2) + 2] += vCellStep.z;
            cube.pointsValuesLinear[indPointValues + ((2 << 2) - 1) * (1 + 2) + 2] += vCellStep.z;
            //cell._points[4].y += vCellStep.y;
            //cell._points[5].y += vCellStep.y;
            //cell._points[6].y += vCellStep.y;
            //cell._points[7].y += vCellStep.y;
            cube.pointsValuesLinear[indPointValues + (2 + 2) * (1 + 2) + 1] += vCellStep.y;
            cube.pointsValuesLinear[indPointValues + (2 + 2 + 1) * (1 + 2) + 1] += vCellStep.y;
            cube.pointsValuesLinear[indPointValues + (2 + 2 + 2) * (1 + 2) + 1] += vCellStep.y;
            cube.pointsValuesLinear[indPointValues + ((2 << 2) - 1) * (1 + 2) + 1] += vCellStep.y;
            // now current cell has intersections (from -x to +x) on some cube edges
            indValues = indPointValues + (1 + 2 << 1 + 2);
            sign[0] = cube.pointsValuesLinear[indValues + 0] < 0 ? 1 : 0;
            sign[1] = cube.pointsValuesLinear[indValues + 1] < 0 ? 1 : 0;
            sign[2] = cube.pointsValuesLinear[indValues + 2] < 0 ? 1 : 0;
            sign[1 + 2] = cube.pointsValuesLinear[indValues + (1 + 2)] < 0 ? 1 : 0;
            sign[2 + 2] = cube.pointsValuesLinear[indValues + (2 + 2)] < 0 ? 1 : 0;
            sign[2 + 2 + 1] = cube.pointsValuesLinear[indValues + (1 + 2 + 2)] < 0 ? 1 : 0;
            sign[2 + 2 + 2] = cube.pointsValuesLinear[indValues + (2 + 2 + 2)] < 0 ? 1 : 0;
            sign[(2 << 2) - 1] = cube.pointsValuesLinear[indValues + (2 << 2) - 1] < 0 ? 1 : 0;
            this.buildEdgePoint(0, 1, sign, cube, indPointValues, vaEdges[0]);
            this.buildEdgePoint(1, 2, sign, cube, indPointValues, vaEdges[1]);
            this.buildEdgePoint(2, 1 + 2, sign, cube, indPointValues, vaEdges[2]);
            this.buildEdgePoint(1 + 2, 0, sign, cube, indPointValues, vaEdges[1 + 2]);
            this.buildEdgePoint(2 + 2, 1 + 2 + 2, sign, cube, indPointValues, vaEdges[2 + 2]);
            this.buildEdgePoint(1 + 2 + 2, 2 + 2 + 2, sign, cube, indPointValues, vaEdges[1 + 2 + 2]);
            this.buildEdgePoint(2 + 2 + 2, (2 << 2) - 1, sign, cube, indPointValues, vaEdges[2 + 2 + 2]);
            this.buildEdgePoint((2 << 2) - 1, 2 + 2, sign, cube, indPointValues, vaEdges[(2 << 2) - 1]);
            this.buildEdgePoint(0, 2 + 2, sign, cube, indPointValues, vaEdges[2 << 2]);
            this.buildEdgePoint(1, 1 + 2 + 2, sign, cube, indPointValues, vaEdges[(2 << 2) + 1]);
            this.buildEdgePoint(2, 2 + 2 + 2, sign, cube, indPointValues, vaEdges[(2 << 2) + 2]);
            this.buildEdgePoint(1 + 2, (2 << 2) - 1, sign, cube, indPointValues, vaEdges[(2 << 2) + 1 + 2]);
            offs = bitsInside * (2 << 1 + 2);
            for (numTri = 0, indTri = 0; numTri < 2 + 2 + 2; numTri++, indTri += 1 + 2) {
              // s_triIndicesMarchCube is external array, defined in mold_ind.js
              i0 = cube.striIndicesMarchCube[offs + indTri + 0];
              if (i0 < 0) {
                break;
              }
              i1 = cube.striIndicesMarchCube[offs + indTri + 1];
              i2 = cube.striIndicesMarchCube[offs + indTri + 2];
              v0.copy(vaEdges[i0]);
              v1.copy(vaEdges[i1]);
              v2.copy(vaEdges[i2]);
              // Add vertex with optimize
              indInGeo0 = this.addVertexToGeo(geoOut, v0, vBoxMin, vBoxMax, meshRes);
              indInGeo1 = this.addVertexToGeo(geoOut, v1, vBoxMin, vBoxMax, meshRes);
              indInGeo2 = this.addVertexToGeo(geoOut, v2, vBoxMin, vBoxMax, meshRes);
              if ((indInGeo0 | indInGeo1 | indInGeo2) < 0) {
                return 0 - 2;
              }
              itr = geoOut._numTriangles + geoOut._numTriangles + geoOut._numTriangles;
              geoOut._indices[itr + 0] = indInGeo0;
              geoOut._indices[itr + 1] = indInGeo1;
              geoOut._indices[itr + 2] = indInGeo2;
              geoOut._numTriangles++;
              if (geoOut._numTriangles >= this.maxNumTriangles) {
                return 0 - 1 - 2;
              }
            }
            // for numTri
            // numCellsIntersected++;
            // numTrianglesGenerated += numTri;
            // next cell (cube)
            indCell++;
          }  // for (x)
        }  // for (z)
      }
      // for (y)
      vaEdges = null;
      sign = null;
      return 0;
    };
    /**
     * Returns number of cell with intersection with at least one sphere.
     * Using this number, we can estimate required number of vertices
     * and triangles to build result mesh.
     *
     * @param {number} side Number of points in cube voxels
     * @param {number} numCells Number of cells in cube voxels (per direction)
     * @param {array} corners Array of float values for cube corner points
     * @param {object} cube IsoSurfaceMarchCube object
     * @returns {number} numIntersectedCells
     */
    this.getNumIntersectedCells = function (side, numCells, corners, cube) {
      var side2 = side * side;
      var numIntersectedCells = 0;
      var indCell = 0, indY = 0, indZ = 0, indCorner = 0, x = 0, y = 0, z = 0, bitsInside = 0;
      var cubeValuesIndex = 0;
      indCell = 0;
      indY = 0;
      for (y = 0; y < numCells; y++, indY += side2) {
        indZ = 0;
        for (z = 0; z < numCells; z++, indZ += side) {
          for (x = 0; x < numCells; x++) {
            cubeValuesIndex = indCell * (2 << 2 + 2) + (1 + 2 << 1 + 2);
            indCorner = x + indZ + indY;
            cube.pointsValuesLinear[cubeValuesIndex + 0] = corners[indCorner];
            cube.pointsValuesLinear[cubeValuesIndex + 1] = corners[indCorner + 1];
            cube.pointsValuesLinear[cubeValuesIndex + 2] = corners[indCorner + side + 1];
            cube.pointsValuesLinear[cubeValuesIndex + 1 + 2] = corners[indCorner + side];
            cube.pointsValuesLinear[cubeValuesIndex + 2 + 2] = corners[side2 + indCorner];
            cube.pointsValuesLinear[cubeValuesIndex + 2 + 2 + 1] = corners[side2 + indCorner + 1];
            cube.pointsValuesLinear[cubeValuesIndex + 2 + 2 + 2] = corners[side2 + indCorner + side + 1];
            cube.pointsValuesLinear[cubeValuesIndex + (2 << 2) - 1] = corners[side2 + indCorner + side];
            // check read exception
            //assert(side2 + indCorner + side + 1 < side3);
            // get bit flags inside
            bitsInside = 0;
            if (cube.pointsValuesLinear[cubeValuesIndex + 0] < 0) {
              bitsInside |= 1;
            }
            if (cube.pointsValuesLinear[cubeValuesIndex + 1] < 0) {
              bitsInside |= 2;
            }
            if (cube.pointsValuesLinear[cubeValuesIndex + 2] < 0) {
              bitsInside |= 2 << 1;
            }
            if (cube.pointsValuesLinear[cubeValuesIndex + 2 + 1] < 0) {
              bitsInside |= 2 << 2;
            }
            if (cube.pointsValuesLinear[cubeValuesIndex + 2 + 2] < 0) {
              bitsInside |= 2 << 2 + 1;
            }
            if (cube.pointsValuesLinear[cubeValuesIndex + 2 + 2 + 1] < 0) {
              bitsInside |= 2 << 2 + 2;
            }
            if (cube.pointsValuesLinear[cubeValuesIndex + 2 + 2 + 2] < 0) {
              bitsInside |= 2 << 2 + 2 + 1;
            }
            if (cube.pointsValuesLinear[cubeValuesIndex + (2 << 2) - 1] < 0) {
              bitsInside |= 2 << 2 + 2 + 2;
            }
            if (bitsInside === 0 || bitsInside === (1 << (2 << 2)) - 1) {
              cube.hasIntersection[indCell] = false;
            } else {
              cube.hasIntersection[indCell] = true;
              numIntersectedCells++;
            }
            cube.bitsInside[indCell] = bitsInside;
            // next cell
            indCell++;
          }  // for (x)
        }  // for (z)
      }
      // for (y)
      return numIntersectedCells;
    };
    this.getType = function (letter) {
      /* eslint-disable no-magic-numbers */
      var atomT = [
        1,
        1,
        2,
        6,
        3,
        6,
        4,
        6,
        5,
        6,
        6,
        0,
        7,
        3,
        8,
        2,
        9,
        6,
        10,
        6,
        11,
        6,
        12,
        6,
        13,
        6,
        14,
        6,
        15,
        4,
        16,
        5,
        17,
        6,
        18,
        6,
        19,
        6,
        20,
        6,
        21,
        6,
        22,
        6,
        23,
        6,
        24,
        6,
        25,
        6,
        26,
        6,
        27,
        6,
        28,
        6,
        29,
        6,
        30,
        6,
        31,
        6,
        32,
        6,
        33,
        6,
        34,
        6,
        35,
        6,
        36,
        6,
        37,
        6,
        38,
        6,
        39,
        6,
        40,
        6,
        41,
        6,
        42,
        6,
        43,
        6,
        44,
        6,
        45,
        6,
        46,
        6,
        47,
        6,
        48,
        6,
        49,
        6,
        50,
        6,
        51,
        6,
        52,
        6,
        53,
        6,
        54,
        6,
        55,
        6,
        56,
        6,
        57,
        6,
        58,
        6,
        59,
        6,
        60,
        6,
        61,
        6,
        62,
        6,
        63,
        6,
        64,
        6,
        65,
        6,
        66,
        6,
        67,
        6,
        68,
        6,
        69,
        6,
        70,
        6,
        71,
        6,
        72,
        6,
        73,
        6,
        74,
        6,
        75,
        6,
        76,
        6,
        77,
        6,
        78,
        6,
        79,
        6,
        80,
        6,
        81,
        6,
        82,
        6,
        83,
        6,
        84,
        6,
        85,
        6,
        86,
        6,
        87,
        6,
        88,
        6,
        89,
        6,
        90,
        6,
        91,
        6,
        92,
        6,
        93,
        6,
        94,
        6,
        95,
        6,
        96,
        6,
        97,
        6,
        98,
        6,
        99,
        6,
        100,
        6,
        101,
        6,
        102,
        6,
        103,
        6,
        104,
        6,
        105,
        6,
        106,
        6,
        107,
        6,
        108,
        6,
        109,
        6
      ];
      /* eslint-enable no-magic-numbers */
      if (letter < 1 || letter > atomT.length / 2 || Object.keys(AtomType.PeriodicTable).length * 2 !== atomT.length) {
        console.error('atomT.length  should be equal AtomType.PeriodicTable.length * 2');
      }
      return atomT[letter * 2 - 1];
    };
    /**
     * Convert PDB file atoms into colored atoms
     *
     * @param {Atom[]} atomsSrc      atom array
     * @param {IsoSurfaceAtomColored[]} atomsColored  array of AtomColored
     * @param {object} colorer     color mode in [0..4]
     */
    this.convertToAtomsColored = function (atomsSrc, atomsColored, colorer) {
      var i = 0, numAtoms = 0;
      var vCenter = null, radius = 0, nm = 0;
      var interfaceColorer = null, colorExt = null;
      interfaceColorer = colorer;
      numAtoms = atomsSrc.length;
      for (i = 0; i < numAtoms; i++) {
        vCenter = atomsSrc[i].getPosition();
        radius = atomsSrc[i].getType().radius;
        atomsColored[i] = new IsoSurfaceAtomColored(vCenter, radius);
        nm = atomsSrc[i].getType().number;
        atomsColored[i].atomType = this.getType(nm);
        colorExt = new THREE.Color(interfaceColorer.getAtomColor(atomsSrc[i], this.complex));
        atomsColored[i].colorX = colorExt.r;
        atomsColored[i].colorY = colorExt.g;
        atomsColored[i].colorZ = colorExt.b;
      }
    };
    /**
     * Calculate values for marching cube grid points
     * positive values are outside sphere, negative - is inside
     *
     * @param {array} corners array of float values
     * @param {number} side Number of point in cube in 1 dimennsion
     * @param {Vector3} vBoxMin Bounding box min point
     * @param {Vector3} vBoxMax Bounding box max point
     * @param {array} atoms Array of input atoms
     * @param {number} probeRad radius for atom probing
     */
    this.calculateGridCorners = function (corners, side, vBoxMin, vBoxMax, atoms, probeRad) {
      var side2 = side * side;
      var side3 = side2 * side;
      var i = 0, atom = null;
      var fx = 0, fy = 0, fz = 0, indXMin = 0, indYMin = 0, indZMin = 0, indXMax = 0, indYMax = 0, indZMax = 0;
      var radius = 0;
      var ind = 0, indY = 0, indZ = 0, x = 0, y = 0, z = 0;
      var vCorner = new THREE.Vector3();
      var vDif = new THREE.Vector3();
      var distToSphere = 0, val = 0;
      /* eslint-disable no-magic-numbers */
      var aLot = +1000000000000;
      /* eslint-enable no-magic-numbers */
      for (i = 0; i < side3; i++) {
        corners[i] = aLot;  // to large value
      }
      var xScale = (side - 1) / (vBoxMax.x - vBoxMin.x);
      var yScale = (side - 1) / (vBoxMax.y - vBoxMin.y);
      var zScale = (side - 1) / (vBoxMax.z - vBoxMin.z);
      var s = 0, numAtoms = atoms.length;
      for (s = 0; s < numAtoms; s++) {
        atom = atoms[s];
        radius = atom.radius + probeRad;
        fx = (atom.coord.x - radius - vBoxMin.x) * xScale;
        fy = (atom.coord.y - radius - vBoxMin.y) * yScale;
        fz = (atom.coord.z - radius - vBoxMin.z) * zScale;
        indXMin = Math.floor(fx);
        indYMin = Math.floor(fy);
        indZMin = Math.floor(fz);
        indXMax = Math.floor((atom.coord.x + radius - vBoxMin.x) * xScale);
        indYMax = Math.floor((atom.coord.y + radius - vBoxMin.y) * yScale);
        indZMax = Math.floor((atom.coord.z + radius - vBoxMin.z) * zScale);
        indXMax++;
        indYMax++;
        indZMax++;
        indXMax = indXMax <= side - 1 ? indXMax : side - 1;
        indYMax = indYMax <= side - 1 ? indYMax : side - 1;
        indZMax = indZMax <= side - 1 ? indZMax : side - 1;
        for (y = indYMin; y <= indYMax; y++) {
          indY = y * side2;
          for (z = indZMin; z <= indZMax; z++) {
            indZ = z * side;
            for (x = indXMin; x <= indXMax; x++) {
              ind = indY + indZ + x;
              this.getCornerCoord(vBoxMin, vBoxMax, x, y, z, side, vCorner);
              vDif.x = vCorner.x - atom.coord.x;
              vDif.y = vCorner.y - atom.coord.y;
              vDif.z = vCorner.z - atom.coord.z;
              distToSphere = Math.sqrt(vDif.x * vDif.x + vDif.y * vDif.y + vDif.z * vDif.z);
              // val: < 0, if inside sphere
              // val: > 0, if outside sphere
              val = distToSphere - radius;
              if (val < corners[ind]) {
                corners[ind] = val;
              }
            }  // for (x)
          }  // for (z)
        }  // for (y)
      }  // for (s)
    };
    /**
     * Create memory pool for vertex hash management
     *
     * @param {number} maxNumVertices Maximum possible number of vertices (that will be build)
     * @param {number} maxNumTriangles Maximum possible number of triangles (that will be build)
     * @returns {number} 0, if success. (<0) is non memory
     */
    this.createVertexHash = function (maxNumVertices, maxNumTriangles) {
      var i = 0, j = 0;
      this.hashLines = utils.allocateTyped(Int32Array, HASH_SIZE * 2);
      if (this.hashLines === null) {
        return 0 - 1;
      }
      for (i = 0, j = 0; i < HASH_SIZE; i++) {
        this.hashLines[j++] = 0;
        // num vertices in this hash line
        this.hashLines[j++] = 0 - 1;  // index of the first entry
      }
      this.maxNumVertices = maxNumVertices;
      this.maxNumTriangles = maxNumTriangles;
      this.numHashEtriesAllocated = maxNumVertices;
      this.hashEntries = utils.allocateTyped(Int32Array, 2 * this.numHashEtriesAllocated);
      if (this.hashEntries === null) {
        return 0 - 1;
      }
      for (i = 0, j = 0; i < this.numHashEtriesAllocated; i++) {
        this.hashEntries[j++] = 0 - 1;
        // index of vertex
        this.hashEntries[j++] = 0 - 1;  // next hash entry index
      }
      this.numHashEntryIndex = 0;
      return 0;
    };
    /**
     * Allocate and return new hash entry. Just check possible amount.
     *
     * @returns {number} index of hash entry, that can be used for geometry add vertex functionality
     */
    this.getNewHashEntry = function () {
      var i = 0;
      if (this.numHashEntryIndex < this.numHashEtriesAllocated) {
        i = this.numHashEntryIndex;
        this.numHashEntryIndex++;
        return i;
      }
      return 0 - 1;
    };
    /**
     * Add vertex to geometry structure
     * using vertex hash table to quickly check, is this vertex already exist in geometry
     *
     * @param {object} geoOut Geometry to build
     * @param {Vector3} vAdd Vertex to add
     * @param {Vector3} vBoxMin Bounding box point min
     * @param {Vector3} vBoxMax Bounding box point max
     * @param {number} meshRes Mesh resolution
     * @returns {number} index of added (or existing) vertex in geometry.
     */
    this.addVertexToGeo = function (geoOut, vAdd, vBoxMin, vBoxMax, meshRes) {
      var ix = 0, iy = 0, iz = 0, iHash = 0;
      var iVertAdd = 0;
      var ind = 0;
      var entry = 0, entryFirst = 0;
      var hashResolution = 0, hLineIndex = 0;
      var oneHynberes = 0.01;
      var n815851 = 815851;
      var n37633 = 37633;
      var n2453543 = 2453543;
      var r106 = 0.000001;
      var v = null;
      hashResolution = meshRes << 2;
      v = new THREE.Vector3();
      ix = Math.floor(hashResolution * (vAdd.x - vBoxMin.x) / (vBoxMax.x + oneHynberes - vBoxMin.x));
      iy = Math.floor(hashResolution * (vAdd.y - vBoxMin.y) / (vBoxMax.y + oneHynberes - vBoxMin.y));
      iz = Math.floor(hashResolution * (vAdd.z - vBoxMin.z) / (vBoxMax.z + oneHynberes - vBoxMin.z));
      iHash = ix * n815851 + iz * n37633 + iy * n2453543;
      iHash &= HASH_SIZE - 1;
      hLineIndex = iHash + iHash;
      // search vertex via hash
      // search in hash list
      if (vBoxMin !== null && vBoxMax !== null) {
        for (entry = this.hashLines[hLineIndex + 1]; entry >= 0; entry = this.hashEntries[entry * 2 + 1]) {
          ind = this.hashEntries[entry * 2 + 0];
          // vertex index
          v.copy(geoOut._vertices[ind]);
          v.x -= vAdd.x;
          v.y -= vAdd.y;
          v.z -= vAdd.z;
          var dot2 = v.x * v.x + v.y * v.y + v.z * v.z;
          if (dot2 < r106) {
            return ind;
          }  // if (found)
        }  // for (entry)
      }
      // search
      // add new vertex to geometry
      if (geoOut._numVertices >= this.maxNumVertices) {
        return 0 - 1;
      }
      iVertAdd = geoOut._numVertices;
      geoOut._vertices[iVertAdd].copy(vAdd);
      // add to hash
      if (vBoxMin !== null && vBoxMax !== null) {
        entry = this.getNewHashEntry();
        if (entry < 0) {
          return 0 - 1;
        }
        entryFirst = this.hashLines[hLineIndex + 1];
        this.hashLines[hLineIndex + 1] = entry;
        this.hashEntries[entry * 2 + 0] = iVertAdd;
        this.hashEntries[entry * 2 + 1] = entryFirst;
        this.hashLines[hLineIndex + 0]++;  // num vertices in line ++
      }
      geoOut._numVertices++;
      return iVertAdd;
    };
    /**
     *
     * @param {number} side some placeholder description
     * @param {number} probeSphereRadius some placeholder description
     * @param {object} vBoxMin some placeholder description
     * @param {object} vBoxMax some placeholder description
     * @param {object} geoOut some placeholder description
     * @param {object} corners some placeholder description
     * @returns {number} always 0
     */
    this.modifyExcludedFromGeo = function (side, probeSphereRadius, vBoxMin, vBoxMax, geoOut, corners) {
      var side2 = 0, xScale = 0, yScale = 0, zScale = 0;
      var probeSpRad2 = 0, sideInv = 0;
      var i = 0, vCenter = 0, radEst = 0;
      var indXMin = 0, indYMin = 0, indZMin = 0, indXMax = 0, indYMax = 0, indZMax = 0, ix = 0;
      var iy = 0, iz = 0, indY = 0, indZ = 0, ind = 0;
      var t = 0, dx = 0, dy = 0, dz = 0, dist2 = 0, distToSphere = 0, distToBorder = 0;
      var xCorner = 0, yCorner = 0, zCorner = 0;
      var r11 = 1.1;
      function innerBlockWorkAround() {
        if (distToBorder > 0) {
          // point is inside probe sphere
          if (corners[ind] < 0) {
            corners[ind] = distToBorder;  // was inside surface, now is oustide ( > 0)
          }
          if (distToBorder > corners[ind]) {
            corners[ind] = distToBorder;  // find positive maximum
          }
        } else if (distToBorder > corners[ind]) {
          // point is outside sphere
          corners[ind] = distToBorder;  // find negative maximum
        }
      }
      side2 = side * side;
      xScale = (side - 1) / (vBoxMax.x - vBoxMin.x);
      yScale = (side - 1) / (vBoxMax.y - vBoxMin.y);
      zScale = (side - 1) / (vBoxMax.z - vBoxMin.z);
      probeSpRad2 = probeSphereRadius * 2 * (probeSphereRadius * 2);
      sideInv = 1 / (side - 1);
      for (i = 0; i < geoOut._numVertices; i++) {
        vCenter = geoOut._vertices[i];
        radEst = probeSphereRadius * r11;
        indXMin = Math.floor((vCenter.x - radEst - vBoxMin.x) * xScale);
        indYMin = Math.floor((vCenter.y - radEst - vBoxMin.y) * yScale);
        indZMin = Math.floor((vCenter.z - radEst - vBoxMin.z) * zScale);
        indXMax = Math.floor((vCenter.x + radEst - vBoxMin.x) * xScale);
        indYMax = Math.floor((vCenter.y + radEst - vBoxMin.y) * yScale);
        indZMax = Math.floor((vCenter.z + radEst - vBoxMin.z) * zScale);
        indXMin = indXMin >= 0 ? indXMin : 0;
        indYMin = indYMin >= 0 ? indYMin : 0;
        indZMin = indZMin >= 0 ? indZMin : 0;
        indXMax = indXMax <= side - 1 ? indXMax : side - 1;
        indYMax = indYMax <= side - 1 ? indYMax : side - 1;
        indZMax = indZMax <= side - 1 ? indZMax : side - 1;
        for (iy = indYMin; iy <= indYMax; iy++) {
          indY = iy * side2;
          for (iz = indZMin; iz <= indZMax; iz++) {
            indZ = iz * side;
            for (ix = indXMin; ix <= indXMax; ix++) {
              ind = indY + indZ + ix;
              //getCornerCoord(vBoxMin, vBoxMax, ix, iy, iz, side, &vCorner);
              t = ix * sideInv;
              xCorner = vBoxMin.x * (1 - t) + vBoxMax.x * t;
              t = iy * sideInv;
              yCorner = vBoxMin.y * (1 - t) + vBoxMax.y * t;
              t = iz * sideInv;
              zCorner = vBoxMin.z * (1 - t) + vBoxMax.z * t;
              dx = xCorner - vCenter.x;
              dy = yCorner - vCenter.y;
              dz = zCorner - vCenter.z;
              dist2 = dx * dx + dy * dy + dz * dz;
              if (dist2 < probeSpRad2) {
                distToSphere = Math.sqrt(dist2);
                distToBorder = -(distToSphere - probeSphereRadius);
                innerBlockWorkAround();
              }  // if (dist from corner point to sphere center more 2 radiuses)
            }  // for (ix)
          }  // for (iz)
        }  // for (iy)
      }
      // for (i) all geo vertices
      return 0;
    };
    this.performanceTest = function () {
      var NUM_VERTICES_TEST = 33000;
      var NUM_TEST_ITERATIONS = 128;
      var sto = 100;
      var dvesti = 200;
      var vertices3d = null, verticesFloat = null;
      var i = 0, x = 0, y = 0, z = 0, vertex3d = null, ind = 0;
      var xMin = 0, yMin = 0, zMin = 0, xMax = 0, yMax = 0, zMax = 0;
      var dateCur = 0, timeStart = 0, timeEndV3d = 0, timeEndLinear = 0;
      var iter = 0;
      var aLot = 1000000000000;
      // Create Vector3 vertices array with some random coordinates
      vertices3d = [];
      for (i = 0; i < NUM_VERTICES_TEST; i++) {
        vertices3d[i] = new THREE.Vector3();
        x = Math.random() * dvesti + -sto;
        y = Math.random() * dvesti + -sto;
        z = Math.random() * dvesti + -sto;
        vertices3d[i].set(x, y, z);
      }
      // Create the same array, but as linear float array
      verticesFloat = utils.allocateTyped(Float32Array, NUM_VERTICES_TEST * (2 + 2));
      for (i = 0, ind = 0; i < NUM_VERTICES_TEST; i++, ind += 2 + 2) {
        vertex3d = vertices3d[i];
        verticesFloat[ind + 0] = vertex3d.x;
        verticesFloat[ind + 1] = vertex3d.y;
        verticesFloat[ind + 2] = vertex3d.z;
      }
      // Get time
      dateCur = new Date();
      timeStart = dateCur.getTime();
      if (verticesFloat !== null) {
        for (iter = 0; iter < NUM_TEST_ITERATIONS; iter++) {
          // get bounding box for vertices
          xMin = yMin = zMin = aLot;
          xMax = yMax = zMax = -aLot;
          for (i = 0; i < NUM_VERTICES_TEST; i++) {
            vertex3d = vertices3d[i];
            xMin = vertex3d.x < xMin ? vertex3d.x : xMin;
            yMin = vertex3d.y < yMin ? vertex3d.y : yMin;
            zMin = vertex3d.z < zMin ? vertex3d.z : zMin;
            xMax = vertex3d.x > xMax ? vertex3d.x : xMax;
            yMax = vertex3d.y > yMax ? vertex3d.y : yMax;
            zMax = vertex3d.z > zMax ? vertex3d.z : zMax;
          }  // for (i)
        }  // for (iter) all iterations
      }
      dateCur = new Date();
      timeEndV3d = dateCur.getTime() - timeStart;
      timeStart = dateCur.getTime();
      if (verticesFloat !== null) {
        for (iter = 0; iter < NUM_TEST_ITERATIONS; iter++) {
          // get bounding box for vertices
          xMin = yMin = zMin = aLot;
          xMax = yMax = zMax = -aLot;
          for (i = 0, ind = 0; i < NUM_VERTICES_TEST; i++, ind += 2 + 2) {
            x = verticesFloat[ind + 0];
            y = verticesFloat[ind + 1];
            z = verticesFloat[ind + 2];
            xMin = x < xMin ? x : xMin;
            yMin = y < yMin ? y : yMin;
            zMin = z < zMin ? z : zMin;
            xMax = x > xMax ? x : xMax;
            yMax = y > yMax ? y : yMax;
            zMax = z > zMax ? z : zMax;
          }  // for (i)
        }  // for (iter) all iterations
      }
      dateCur = new Date();
      timeEndLinear = dateCur.getTime() - timeStart;
      verticesFloat = null;
      vertices3d = null;
      console.log('Performance test for array of Vector3     = ' + timeEndV3d);
      console.log('Performance test for linear float32 array = ' + timeEndLinear);
    };
    this.build = function () {
      var ok = 0;
      var oneHundered = 100;
      var r35 = 3.5;
      var r12 = 1.2;
      // performance test
      //this.performanceTest();
      // Create temporary atoms (but colored)
      var atomsColored = new Array(this.atoms.length);
      this.convertToAtomsColored(this.atoms, atomsColored, this.colorMode);
      // find bbox for spheres scene
      var vBoxMin = new THREE.Vector3();
      var vBoxMax = new THREE.Vector3();
      this.getBoundingBox(atomsColored, vBoxMin, vBoxMax);
      var cx = (vBoxMin.x + vBoxMax.x) / 2;
      var cy = (vBoxMin.y + vBoxMax.y) / 2;
      var cz = (vBoxMin.z + vBoxMax.z) / 2;
      this.posCenter = new THREE.Vector3(cx, cy, cz);
      var marCubeResoultion = this.meshResolution * (2 + 2);
      // build grid corners for Marching cube algorithm
      var side = marCubeResoultion;
      var side2 = side * side;
      var side3 = side2 * side;
      var corners = utils.allocateTyped(Float32Array, side3);
      // settings for Clusterization
      var numVoxels = this.meshResolution;
      // Fix number of voxels (for clusterization) if too much
      var numIdealVoxels = 0;
      var numAtomsSrc = this.atoms.length;
      if (numAtomsSrc < oneHundered) {
        numIdealVoxels = 4;
      } else {
        numIdealVoxels = Math.floor(Math.pow(numAtomsSrc * 2, 1 / (1 + 2)));
      }
      if (numVoxels > numIdealVoxels) {
        numVoxels = numIdealVoxels;
      }
      var rProbeRadius = this.probeRadius * this.atomRadiusScale;
      // build clustered atoms
      var clusterBuilder = null;
      var atomsClustered = null;
      if (this.clusterizationType > 0) {
        clusterBuilder = new IsoSurfaceCluster(this.complex, this.atoms, atomsColored, vBoxMin, vBoxMax, numVoxels, this.colorMode);
        if (this.clusterizationType === 1) {
          atomsClustered = clusterBuilder.buildKMeans();
        } else {
          atomsClustered = clusterBuilder.buildSimple();
        }
        // redbuild bbox again due to increase of radius
        //this.getBoundingBox(atomsClustered, vBoxMin, vBoxMax);
        vBoxMin.x -= r35;
        vBoxMin.y -= r35;
        vBoxMin.z -= r35;
        vBoxMax.x += r35;
        vBoxMax.y += r35;
        vBoxMax.z += r35;
        this.calculateGridCorners(corners, side, vBoxMin, vBoxMax, atomsClustered, rProbeRadius);
      } else {
        this.calculateGridCorners(corners, side, vBoxMin, vBoxMax, atomsColored, rProbeRadius);
      }
      var numCells = marCubeResoultion - 1;
      var cube = new IsoSurfaceMarchCube();
      ok = cube.create(numCells);
      if (ok < 0) {
        return ok;
      }
      // copy corners to cells
      var vCellStep = new THREE.Vector3();
      vCellStep.x = (vBoxMax.x - vBoxMin.x) / numCells;
      vCellStep.y = (vBoxMax.y - vBoxMin.y) / numCells;
      vCellStep.z = (vBoxMax.z - vBoxMin.z) / numCells;
      var numIntersectedCellsEstim = this.getNumIntersectedCells(side, numCells, corners, cube);
      var maxNumVertices = Math.floor(numIntersectedCellsEstim * r12);
      var maxNumTriangles = Math.floor(numIntersectedCellsEstim * r12 * 2);
      this.geoOut = new IsoSurfaceGeo(maxNumVertices, maxNumTriangles, this.useVertexColors);
      ok = this.createVertexHash(maxNumVertices, maxNumTriangles);
      if (ok < 0) {
        return ok;
      }
      ok = this.buildGeoFromCorners(marCubeResoultion, vBoxMin, vBoxMax, corners, vCellStep, cube, this.geoOut);
      if (this.excludeProbe) {
        // using 3d mesh (geoOut) as a surface points
        // move probe sphere and try to minimuze corners values
        this.modifyExcludedFromGeo(side, rProbeRadius, vBoxMin, vBoxMax, this.geoOut, corners);
        // delete old builded geo
        this.geoOut._vertices = null;
        this.geoOut._colors = null;
        this.geoOut._indices = null;
        this.geoOut._normals = null;
        this.geoOut._numVertices = 0;
        this.geoOut._numTriangles = 0;
        this.geoOut = null;
        // estimage geo vertices budget again
        numIntersectedCellsEstim = this.getNumIntersectedCells(side, numCells, corners, cube);
        maxNumVertices = Math.floor(numIntersectedCellsEstim * r12);
        maxNumTriangles = Math.floor(numIntersectedCellsEstim * r12 * 2);
        // creates empty new geometry
        this.geoOut = new IsoSurfaceGeo(maxNumVertices, maxNumTriangles, this.useVertexColors);
        ok = this.createVertexHash(maxNumVertices, maxNumTriangles);
        if (ok < 0) {
          return ok;
        }
        // build vertices and triangles from corners values
        ok = this.buildGeoFromCorners(side, vBoxMin, vBoxMax, corners, vCellStep, cube, this.geoOut);
      }
      var probeRadForNormalsColors = rProbeRadius;
      if (this.excludeProbe) {
        probeRadForNormalsColors = 0.01;
      }
      // build vertex normals
      var isosurfaceNormalColorBuilder = null;
      if (this.clusterizationType > 0) {
        isosurfaceNormalColorBuilder = new IsoSurfaceNormal(atomsClustered.length, atomsClustered, vBoxMin, vBoxMax, this.geoOut._vertices.length, this.geoOut._vertices, probeRadForNormalsColors);
      } else {
        isosurfaceNormalColorBuilder = new IsoSurfaceNormal(atomsColored.length, atomsColored, vBoxMin, vBoxMax, this.geoOut._vertices.length, this.geoOut._vertices, probeRadForNormalsColors);
      }
      isosurfaceNormalColorBuilder.createVoxels();
      if (isosurfaceNormalColorBuilder !== null) {
        isosurfaceNormalColorBuilder.buildNormals(this.geoOut._normals);
        // More value : more smooth color mixing
        // value about 0.7: very rough colors borders
        var radiusColorSmoothness = 6.5;
        if (this.excludeProbe) {
          radiusColorSmoothness -= 1.5;
        }
        if (this.useVertexColors) {
          isosurfaceNormalColorBuilder.buildColors(this.geoOut._colors, radiusColorSmoothness);
        }
      }
      isosurfaceNormalColorBuilder.destroyVoxels();
      isosurfaceNormalColorBuilder = null;
      // remove objects
      if (clusterBuilder !== null) {
        clusterBuilder.destroy();
        clusterBuilder = null;
      }
      atomsClustered = null;
      atomsColored = null;
      cube.destroy();
      cube = null;
      corners = null;
      return ok;
    };
  };
  return IsoSurfaceMode;
}(three, settings, gfx_modes_IsoSurfaceAtomColored, gfx_modes_IsoSurfaceNormal, gfx_modes_IsoSurfaceCluster, gfx_modes_IsoSurfaceMarchCube, gfx_modes_IsoSurfaceGeo, gfx_shaders_UberMaterial, chem_AtomType, utils);
gfx_modes_IsoSurfaceSASMode = function (IsoSurfaceMode) {
  function IsoSurfaceSASMode(opts) {
    IsoSurfaceMode.call(this, false, opts);
  }
  IsoSurfaceSASMode.prototype = Object.create(IsoSurfaceMode.prototype);
  IsoSurfaceSASMode.prototype.constructor = IsoSurfaceSASMode;
  IsoSurfaceSASMode.prototype.id = 'ISOSURFACE_SAS_MODE';
  IsoSurfaceSASMode.prototype.shortId = 'SA';
  IsoSurfaceSASMode.prototype.name = 'Solvent Accessible Surface';
  IsoSurfaceSASMode.prototype.shortName = 'SAS';
  return IsoSurfaceSASMode;
}(gfx_modes_IsoSurfaceMode);
gfx_modes_IsoSurfaceWMD = function (THREE, IsoSurfaceMarchCube, utils) {
  var edgeTable = [
    0,
    265,
    515,
    778,
    1030,
    1295,
    1541,
    1804,
    2060,
    2309,
    2575,
    2822,
    3082,
    3331,
    3593,
    3840,
    400,
    153,
    915,
    666,
    1430,
    1183,
    1941,
    1692,
    2460,
    2197,
    2975,
    2710,
    3482,
    3219,
    3993,
    3728,
    560,
    825,
    51,
    314,
    1590,
    1855,
    1077,
    1340,
    2620,
    2869,
    2111,
    2358,
    3642,
    3891,
    3129,
    3376,
    928,
    681,
    419,
    170,
    1958,
    1711,
    1445,
    1196,
    2988,
    2725,
    2479,
    2214,
    4010,
    3747,
    3497,
    3232,
    1120,
    1385,
    1635,
    1898,
    102,
    367,
    613,
    876,
    3180,
    3429,
    3695,
    3942,
    2154,
    2403,
    2665,
    2912,
    1520,
    1273,
    2035,
    1786,
    502,
    255,
    1013,
    764,
    3580,
    3317,
    4095,
    3830,
    2554,
    2291,
    3065,
    2800,
    1616,
    1881,
    1107,
    1370,
    598,
    863,
    85,
    348,
    3676,
    3925,
    3167,
    3414,
    2650,
    2899,
    2137,
    2384,
    1984,
    1737,
    1475,
    1226,
    966,
    719,
    453,
    204,
    4044,
    3781,
    3535,
    3270,
    3018,
    2755,
    2505,
    2240,
    2240,
    2505,
    2755,
    3018,
    3270,
    3535,
    3781,
    4044,
    204,
    453,
    719,
    966,
    1226,
    1475,
    1737,
    1984,
    2384,
    2137,
    2899,
    2650,
    3414,
    3167,
    3925,
    3676,
    348,
    85,
    863,
    598,
    1370,
    1107,
    1881,
    1616,
    2800,
    3065,
    2291,
    2554,
    3830,
    4095,
    3317,
    3580,
    764,
    1013,
    255,
    502,
    1786,
    2035,
    1273,
    1520,
    2912,
    2665,
    2403,
    2154,
    3942,
    3695,
    3429,
    3180,
    876,
    613,
    367,
    102,
    1898,
    1635,
    1385,
    1120,
    3232,
    3497,
    3747,
    4010,
    2214,
    2479,
    2725,
    2988,
    1196,
    1445,
    1711,
    1958,
    170,
    419,
    681,
    928,
    3376,
    3129,
    3891,
    3642,
    2358,
    2111,
    2869,
    2620,
    1340,
    1077,
    1855,
    1590,
    314,
    51,
    825,
    560,
    3728,
    3993,
    3219,
    3482,
    2710,
    2975,
    2197,
    2460,
    1692,
    1941,
    1183,
    1430,
    666,
    915,
    153,
    400,
    3840,
    3593,
    3331,
    3082,
    2822,
    2575,
    2309,
    2060,
    1804,
    1541,
    1295,
    1030,
    778,
    515,
    265,
    0
  ];
  function _voxelGradientFast(v, point, grad) {
    var index = (point.z * v.xSize * v.ySize + point.y * v.xSize + point.x) * 3;
    grad.set(v.gradient[index], v.gradient[index + 1], v.gradient[index + 2]);
  }
  // Helper class GridCell
  function GridCell() {
    this._arrSize = 8;
    this.p = new Array(this._arrSize);
    this.g = new Array(this._arrSize);
    this.val = new Array(this._arrSize);
    for (var i = 0; i < this._arrSize; ++i) {
      this.p[i] = new THREE.Vector3();
      this.g[i] = new THREE.Vector3();
    }
    this.cubeIndex = 0;
  }
  GridCell.prototype.constructor = GridCell;
  // Helper class Triangle
  function Triangle() {
    this.a = {
      p: new THREE.Vector3(),
      n: new THREE.Vector3()
    };
    this.b = {
      p: new THREE.Vector3(),
      n: new THREE.Vector3()
    };
    this.c = {
      p: new THREE.Vector3(),
      n: new THREE.Vector3()
    };
  }
  Triangle.prototype.constructor = Triangle;
  function IsoSurface() {
    this._numTriangles = 0;
    this._numVertices = 0;
    this._position = [];
    this._normals = [];
    this._colors = null;
    this._indices = [];
    this._volumetricData = null;
    this._xAxis = new THREE.Vector3();
    this._yAxis = new THREE.Vector3();
    this._zAxis = new THREE.Vector3();
    this._xDir = new THREE.Vector3();
    this._yDir = new THREE.Vector3();
    this._zDir = new THREE.Vector3();
  }
  IsoSurface.prototype.constructor = IsoSurface;
  IsoSurface.prototype._prepareAxesAndDirs = function () {
    var volData = this._volumetricData;
    // calculate cell axes
    var xAxis = this._xAxis;
    var yAxis = this._yAxis;
    var zAxis = this._zAxis;
    var xDir = this._xDir;
    var yDir = this._yDir;
    var zDir = this._zDir;
    volData.cellAxes(xAxis, yAxis, zAxis);
    volData.cellDirs(xDir, yDir, zDir);
    // flip normals if coordinate system is in the wrong handedness
    var tmp = new THREE.Vector3();
    tmp.crossVectors(xDir, yDir);
    if (tmp.dot(zDir) < 0) {
      xDir.negate();
      yDir.negate();
      zDir.negate();
    }
    // check that the grid is in the all-positive octant of the coordinate system
    if (xDir.x < 0 || xDir.y < 0 || xDir.z < 0 || yDir.x < 0 || yDir.y < 0 || yDir.z < 0 || zDir.x < 0 || zDir.y < 0 || zDir.z < 0) {
      return false;
    }
    // check that the grid is axis-aligned
    // TODO This is a VMD way. Is it correct in our case to compare with floating zero?
    return !(xAxis.y !== 0 || xAxis.z !== 0 || yAxis.x !== 0 || yAxis.z !== 0 || zAxis.x !== 0 || zAxis.y !== 0);
  };
  IsoSurface.prototype._vertexInterp = function (isoLevel, grid, ind1, ind2, vertex, normal) {
    var p1 = grid.p[ind1];
    var p2 = grid.p[ind2];
    var n1 = grid.g[ind1];
    var n2 = grid.g[ind2];
    var valP1 = grid.val[ind1];
    var valP2 = grid.val[ind2];
    var isoDiffP1 = isoLevel - valP1;
    var diffValP2P1 = valP2 - valP1;
    var mu = 0;
    if (Math.abs(diffValP2P1) > 0) {
      mu = isoDiffP1 / diffValP2P1;
    }
    mu = mu > 1 ? 1 : mu;
    vertex.lerpVectors(p1, p2, mu);
    normal.lerpVectors(n1, n2, mu);
  };
  IsoSurface.prototype._polygonize = function () {
    var triTable = IsoSurfaceMarchCube.prototype.striIndicesMarchCube;
    var arrSize = 12;
    var firstIndices = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      0,
      1,
      2,
      3
    ];
    var secondIndices = [
      1,
      2,
      3,
      0,
      5,
      6,
      7,
      4,
      4,
      5,
      6,
      7
    ];
    var vertexList = new Array(arrSize);
    var normalList = new Array(arrSize);
    var i = 0;
    for (; i < arrSize; ++i) {
      vertexList[i] = new THREE.Vector3();
      normalList[i] = new THREE.Vector3();
    }
    return function (grid, isoLevel, triangles) {
      var cubeIndex = grid.cubeIndex;
      for (i = 0; i < arrSize; ++i) {
        if (edgeTable[cubeIndex] & 1 << i) {
          this._vertexInterp(isoLevel, grid, firstIndices[i], secondIndices[i], vertexList[i], normalList[i]);
        }
      }
      var triCount = 0;
      var triTblIdx = cubeIndex * 16;
      for (i = 0; triTable[triTblIdx + i] !== -1; i += 3) {
        triangles[triCount].a.p.copy(vertexList[triTable[triTblIdx + i]]);
        triangles[triCount].a.n.copy(normalList[triTable[triTblIdx + i]]);
        triangles[triCount].b.p.copy(vertexList[triTable[triTblIdx + i + 1]]);
        triangles[triCount].b.n.copy(normalList[triTable[triTblIdx + i + 1]]);
        triangles[triCount].c.p.copy(vertexList[triTable[triTblIdx + i + 2]]);
        triangles[triCount].c.n.copy(normalList[triTable[triTblIdx + i + 2]]);
        ++triCount;
      }
      return triCount;
    };
  }();
  IsoSurface.prototype._doGridPosNorms = function (isoValue, step, appendSimple) {
    var vol = this._volumetricData;
    var xSize = vol.xSize;
    var ySize = vol.ySize;
    var zSize = vol.zSize;
    var row = xSize;
    var plane = row * ySize;
    var rowStep = row * step;
    var planeStep = plane * step;
    var volData = vol.volData;
    var gc = new GridCell();
    var gcVal = gc.val;
    var gcValSize = gc.val.length;
    var additions = [
      new THREE.Vector3(0, 0, 0),
      // 0
      new THREE.Vector3(step, 0, 0),
      // 1
      new THREE.Vector3(step, step, 0),
      // 2
      new THREE.Vector3(0, step, 0),
      // 3
      new THREE.Vector3(0, 0, step),
      // 4
      new THREE.Vector3(step, 0, step),
      // 5
      new THREE.Vector3(step, step, step),
      // 6
      new THREE.Vector3(0, step, step)  // 7
    ];
    var tmpTriCount = 5;
    var triangles = new Array(tmpTriCount);
    for (var j = 0; j < tmpTriCount; ++j) {
      triangles[j] = new Triangle();
    }
    var appendVertex;
    var self = this;
    var positions = this._position;
    var normals = this._normals;
    if (appendSimple) {
      // Special case for axis-aligned grid with positive unit vector normals
      appendVertex = function () {
        var axis = new THREE.Vector3(self._xAxis.x, self._yAxis.y, self._zAxis.z);
        var origin = vol.origin;
        return function (triVertex) {
          var vertex = triVertex.p.clone();
          vertex.multiply(axis);
          positions.push(vertex.add(origin));
          normals.push(triVertex.n.clone());
        };
      }();
    } else {
      appendVertex = function () {
        var posMtx = new THREE.Matrix3();
        posMtx.set(self._xAxis.x, self._yAxis.x, self._zAxis.x, self._xAxis.y, self._yAxis.y, self._zAxis.y, self._xAxis.z, self._yAxis.z, self._zAxis.z);
        var normMtx = new THREE.Matrix3();
        normMtx.set(self._xDir.x, self._yDir.x, self._zDir.x, self._xDir.y, self._yDir.y, self._zDir.y, self._xDir.z, self._yDir.z, self._zDir.z);
        var origin = vol.origin;
        return function (triVertex) {
          positions.push(triVertex.p.clone().applyMatrix3(posMtx).add(origin));
          normals.push(triVertex.n.clone().applyMatrix3(normMtx));
        };
      }();
    }
    var indices = this._indices;
    var globTriCount = 0;
    for (var z = 0; z < zSize - step; z += step) {
      for (var y = 0; y < ySize - step; y += step) {
        for (var x = 0; x < xSize - step; x += step) {
          var addr = z * plane + y * row + x;
          /* eslint-disable no-multi-spaces */
          /* eslint-disable computed-property-spacing */
          gcVal[0] = volData[addr];
          gcVal[1] = volData[addr + step];
          gcVal[3] = volData[addr + rowStep];
          gcVal[2] = volData[addr + step + rowStep];
          gcVal[4] = volData[addr + planeStep];
          gcVal[5] = volData[addr + step + planeStep];
          gcVal[7] = volData[addr + rowStep + planeStep];
          gcVal[6] = volData[addr + step + rowStep + planeStep];
          /* eslint-enable no-multi-spaces */
          /* eslint-enable computed-property-spacing */
          // Determine the index into the edge table which
          // tells us which vertices are inside of the surface
          var cubeIndex = 0;
          var i = 0;
          for (; i < gcValSize; ++i) {
            if (gcVal[i] < isoValue) {
              cubeIndex |= 1 << i;
            }
          }
          if (edgeTable[cubeIndex] === 0) {
            continue;
          }
          gc.cubeIndex = cubeIndex;
          for (i = 0; i < gcValSize; ++i) {
            gc.p[i].set(x + additions[i].x, y + additions[i].y, z + additions[i].z);
            _voxelGradientFast(vol, gc.p[i], gc.g[i]);
          }
          // calculate vertices and facets for this cube,
          // calculate normals by interpolating between the negated
          // normalized volume gradients for the 8 reference voxels
          var triCount = this._polygonize(gc, isoValue, triangles);
          globTriCount += triCount;
          //append triangles using different techniques
          for (i = 0; i < triCount; ++i) {
            indices.push(this._numTriangles * 3);
            indices.push(this._numTriangles * 3 + 1);
            indices.push(this._numTriangles * 3 + 2);
            ++this._numTriangles;
            appendVertex(triangles[i].a);
            appendVertex(triangles[i].b);
            appendVertex(triangles[i].c);
          }
        }
      }
    }
    return globTriCount;
  };
  IsoSurface.prototype.compute = function (volData, isoValue, step) {
    this._volumetricData = volData;
    this._doGridPosNorms(isoValue, step, this._prepareAxesAndDirs());
  };
  IsoSurface.prototype.vertexFusion = function (volData, offset, len) {
    var faceVer = this._indices.length;
    var vertices = this._position;
    var normals = this._normals;
    var oldVerCount = vertices.length | 0;
    if (faceVer === 0 || oldVerCount === 0) {
      return;
    }
    var vMap = utils.allocateTyped(Uint32Array, oldVerCount);
    vMap[0] = 0;
    var newVer = 1;
    var i = 1;
    for (; i < oldVerCount; ++i) {
      var start = newVer - offset < 0 ? 0 : newVer - offset;
      var end = start + len > newVer ? newVer : start + len;
      var matchedIndex = -1;
      for (var j = start; j < end; ++j) {
        // TODO we are comparing floating number for exact match. What is wrong with us?
        if (vertices[i].equals(vertices[j])) {
          matchedIndex = j;
          break;
        }
      }
      if (matchedIndex !== -1) {
        vMap[i] = matchedIndex;
      } else {
        vertices[newVer].copy(vertices[i]);
        normals[newVer].copy(normals[i]);
        vMap[i] = newVer;
        ++newVer;
      }
    }
    // remap indices
    var indices = this._indices;
    var newIndices = utils.allocateTyped(Uint32Array, faceVer);
    for (i = 0; i < faceVer; ++i) {
      indices[i] = vMap[indices[i]];
      newIndices[i] = indices[i];
    }
    indices = null;
    this._indices = newIndices;
    // create new vectors for positions and normals
    var newPositions = utils.allocateTyped(Float32Array, newVer * 3);
    var newNormals = utils.allocateTyped(Float32Array, newVer * 3);
    for (i = 0; i < newVer; ++i) {
      var pos = vertices[i];
      newPositions[i * 3] = pos.x;
      newPositions[i * 3 + 1] = pos.y;
      newPositions[i * 3 + 2] = pos.z;
      var norm = normals[i].normalize();
      newNormals[i * 3] = norm.x;
      newNormals[i * 3 + 1] = norm.y;
      newNormals[i * 3 + 2] = norm.z;
    }
    vertices = null;
    normals = null;
    this._position = newPositions;
    this._normals = newNormals;
  };
  /// assign per-vertex colors from a volumetric texture map with the
  /// same dimensions as the original volumetric data
  /// XXX only handles orthogonal volumes currently
  IsoSurface.prototype.setColorVolTex = function (volTex) {
    var numVerts = this._position.length / 3;
    var vertices = this._position;
    var vol = this._volumetricData;
    var row = vol.xSize;
    var plane = vol.xSize * vol.ySize;
    var xInv = 1 / this._xAxis.x;
    var yInv = 1 / this._yAxis.y;
    var zInv = 1 / this._zAxis.z;
    var xs = vol.xSize - 1;
    var ys = vol.ySize - 1;
    var zs = vol.zSize - 1;
    var colors = utils.allocateTyped(Float32Array, numVerts * 3);
    function interp(mu, idx1, idx2, c) {
      c[0] = (1 - mu) * volTex[idx1] + mu * volTex[idx2];
      c[1] = (1 - mu) * volTex[idx1 + 1] + mu * volTex[idx2 + 1];
      c[2] = (1 - mu) * volTex[idx1 + 2] + mu * volTex[idx2 + 2];
    }
    for (var i = 0; i < numVerts; i++) {
      var ind = i * 3;
      var vx = (vertices[ind] - vol.origin.x) * xInv;
      var vy = (vertices[ind + 1] - vol.origin.y) * yInv;
      var vz = (vertices[ind + 2] - vol.origin.z) * zInv;
      var x = Math.min(Math.max(vx, 0), xs) | 0;
      var y = Math.min(Math.max(vy, 0), ys) | 0;
      var z = Math.min(Math.max(vz, 0), zs) | 0;
      var cAddr = (z * plane + y * row + x) * 3;
      var mux = vx - x;
      var muy = vy - y;
      var muz = vz - z;
      var caddrp1 = x < xs ? cAddr + 3 : cAddr;
      var c0 = [
        0,
        0,
        0
      ];
      interp(mux, cAddr, caddrp1, c0);
      var c1 = [
        0,
        0,
        0
      ];
      var yinc = y < ys ? row * 3 : 0;
      cAddr += yinc;
      caddrp1 += yinc;
      interp(mux, cAddr, caddrp1, c1);
      var zinc = z < zs ? plane * 3 : 0;
      var c3 = [
        0,
        0,
        0
      ];
      cAddr += zinc;
      caddrp1 += zinc;
      interp(mux, cAddr, caddrp1, c3);
      var c2 = [
        0,
        0,
        0
      ];
      cAddr -= yinc;
      caddrp1 -= yinc;
      interp(mux, cAddr, caddrp1, c2);
      var cz0 = [
        0,
        0,
        0
      ];
      cz0[0] = (1 - muy) * c0[0] + muy * c1[0];
      cz0[1] = (1 - muy) * c0[1] + muy * c1[1];
      cz0[2] = (1 - muy) * c0[2] + muy * c1[2];
      var cz1 = [
        0,
        0,
        0
      ];
      cz1[0] = (1 - muy) * c2[0] + muy * c3[0];
      cz1[1] = (1 - muy) * c2[1] + muy * c3[1];
      cz1[2] = (1 - muy) * c2[2] + muy * c3[2];
      colors[ind] = (1 - muz) * cz0[0] + muz * cz1[0];
      colors[ind + 1] = (1 - muz) * cz0[1] + muz * cz1[1];
      colors[ind + 2] = (1 - muz) * cz0[2] + muz * cz1[2];
    }
    this._colors = colors;
  };
  IsoSurface.prototype.toMesh = function () {
    var geo = new THREE.BufferGeometry();
    geo.setIndex(new THREE.BufferAttribute(this._indices, 1));
    geo.addAttribute('position', new THREE.BufferAttribute(this._position, 3));
    geo.addAttribute('normal', new THREE.BufferAttribute(this._normals, 3));
    geo.addAttribute('color', new THREE.BufferAttribute(this._colors, 3));
    geo.computeBoundingSphere();
    return geo;
  };
  return IsoSurface;
}(three, gfx_modes_IsoSurfaceMarchCube, utils);
gfx_modes_VolumetricDataVMD = function (THREE, utils) {
  function VolumetricData(origin, xAxis, yAxis, zAxis, numVoxels, volMap) {
    this.xSize = numVoxels[0];
    this.ySize = numVoxels[1];
    this.zSize = numVoxels[2];
    this.gradient = null;
    this.origin = origin.clone();
    this._xAxis = xAxis.clone();
    this._yAxis = yAxis.clone();
    this._zAxis = zAxis.clone();
    this.volData = volMap;  /*
                            var nData = numVoxels[0] * numVoxels[1] * numVoxels[2];
                            var min = volMap[0];
                            var max = volMap[1];
                            for (var i = 1; i < nData; ++i) {
                              if (min < volMap[i]) {
                                min = volMap[i];
                              }
                              if (max > volMap[i]) {
                                max = volMap[i];
                              }
                            }
                            this.dataMin = min;
                            this.dataMax = max; */
  }
  VolumetricData.prototype.constructor = VolumetricData;
  VolumetricData.prototype.cellLength = function () {
    var xSize = this.xSize;
    var ySize = this.ySize;
    var zSize = this.zSize;
    // set scaling factors correctly
    var xSinv = xSize > 1 ? 1 / (xSize - 1) : 1;
    var ySinv = ySize > 1 ? 1 / (ySize - 1) : 1;
    var zSinv = zSize > 1 ? 1 / (zSize - 1) : 1;
    return new THREE.Vector3(Math.sqrt(this._xAxis.dot(this._xAxis)) * xSinv, Math.sqrt(this._yAxis.dot(this._yAxis)) * ySinv, Math.sqrt(this._zAxis.dot(this._zAxis)) * zSinv);
  };
  VolumetricData.prototype.cellAxes = function (xAx, yAx, zAx) {
    var xSize = this.xSize;
    var ySize = this.ySize;
    var zSize = this.zSize;
    // set scaling factors correctly
    var xSinv = xSize > 1 ? 1 / (xSize - 1) : 1;
    var ySinv = ySize > 1 ? 1 / (ySize - 1) : 1;
    var zSinv = zSize > 1 ? 1 / (zSize - 1) : 1;
    xAx.copy(this._xAxis).multiplyScalar(xSinv);
    yAx.copy(this._yAxis).multiplyScalar(ySinv);
    zAx.copy(this._zAxis).multiplyScalar(zSinv);
  };
  VolumetricData.prototype.cellDirs = function (xAd, yAd, zAd) {
    var v1 = this.cellLength();
    this.cellAxes(xAd, yAd, zAd);
    xAd.multiplyScalar(1 / v1.x);
    yAd.multiplyScalar(1 / v1.y);
    zAd.multiplyScalar(1 / v1.z);
  };
  VolumetricData.prototype.computeVolumeGradient = function () {
    var xSize = this.xSize;
    var ySize = this.ySize;
    var zSize = this.zSize;
    if (this.gradient === null) {
      this.gradient = utils.allocateTyped(Float32Array, xSize * ySize * zSize * 3);
    }
    var gradient = this.gradient;
    // calculate cell side lengths
    var vl = this.cellLength();
    // gradient axis scaling values and averaging factors, to correctly
    // calculate the gradient for volumes with irregular cell spacing
    var vs = new THREE.Vector3(-0.5 / vl.x, -0.5 / vl.y, -0.5 / vl.z);
    // TODO Check for intended bug in VMD (min is zero)
    function clamp(val, min, max) {
      return Math.min(max, Math.max(min, val));
    }
    var volMap = this.volData;
    function _voxelValue(x, y, z) {
      return volMap[z * xSize * ySize + y * xSize + x];
    }
    for (var zi = 0; zi < zSize; ++zi) {
      var zm = clamp(zi - 1, 0, zSize - 1);
      var zp = clamp(zi + 1, 0, zSize - 1);
      for (var yi = 0; yi < ySize; ++yi) {
        var ym = clamp(yi - 1, 0, ySize - 1);
        var yp = clamp(yi + 1, 0, ySize - 1);
        var row = zi * xSize * ySize + yi * xSize;
        for (var xi = 0; xi < xSize; ++xi) {
          var xm = clamp(xi - 1, 0, xSize - 1);
          var xp = clamp(xi + 1, 0, xSize - 1);
          var index = (row + xi) * 3;
          // Calculate the volume gradient at each grid cell.
          // Gradients are now stored unnormalized, since we need them in pure
          // form in order to draw field lines etc.  Shading code will now have
          // to do renormalization for itself on-the-fly.
          // XXX this gradient is only correct for orthogonal grids, since
          // we're using the array index offsets rather to calculate the gradient
          // rather than voxel coordinate offsets.  This will have to be
          // re-worked for non-orthogonal datasets.
          gradient[index] = (_voxelValue(xp, yi, zi) - _voxelValue(xm, yi, zi)) * vs.x;
          gradient[index + 1] = (_voxelValue(xi, yp, zi) - _voxelValue(xi, ym, zi)) * vs.y;
          gradient[index + 2] = (_voxelValue(xi, yi, zp) - _voxelValue(xi, yi, zm)) * vs.z;
        }
      }
    }
  };
  return VolumetricData;
}(three, utils);
gfx_modes_buildQuickSurf = function (THREE, settings, IsoSurface, VolumetricData, utils) {
  function QuickSurfGroup(complex, colorer, mode, polyComplexity, mask, material) {
    THREE.Group.call(this);
    var params = mode.getQuickSurfParams();
    this.numVoxels = [
      128,
      128,
      128
    ];
    this.xAxis = new THREE.Vector3(1, 0, 0);
    this.yAxis = new THREE.Vector3(0, 1, 0);
    this.zAxis = new THREE.Vector3(0, 0, 1);
    this.origin = new THREE.Vector3(0, 0, 0);
    this._material = material.createInstance();
    this._material.setValues({
      vertexColors: THREE.VertexColors,
      wireframe: mode.getWireframe(),
      zClip: true,
      fakeOpacity: settings.now.isoSurfaceFakeOpacity
    });
    var mesh = this._calcSurface(complex, colorer, mode, mask, params);
    if (mesh !== null) {
      this.add(mesh);
    }
  }
  QuickSurfGroup.prototype = Object.create(THREE.Group.prototype);
  QuickSurfGroup.prototype.constructor = QuickSurfGroup;
  QuickSurfGroup.prototype._packBeads = function (complex, colorer, mode, _mask) {
  };
  QuickSurfGroup.prototype._packAtoms = function (complex, colorer, mode, mask) {
    var atoms = complex._atoms;
    var numAtoms = atoms.length;
    var visibleCount = 0;
    var i = 0;
    for (; i < numAtoms; ++i) {
      if (atoms[i]._mask & mask) {
        ++visibleCount;
      }
    }
    var posRad = utils.allocateTyped(Float32Array, visibleCount * 4);
    var colors = utils.allocateTyped(Float32Array, visibleCount * 3);
    var atomIdx = 0;
    for (i = 0; i < numAtoms; ++i) {
      var atom = atoms[i];
      if (!(atom._mask & mask)) {
        continue;
      }
      atom._position.toArray(posRad, atomIdx * 4);
      posRad[atomIdx * 4 + 3] = mode.calcAtomRadius(atom);
      new THREE.Color(colorer.getAtomColor(atom, complex)).toArray(colors, atomIdx * 3);
      ++atomIdx;
    }
    return {
      posRad: posRad,
      colors: colors
    };
  };
  QuickSurfGroup.prototype.gaussdensity = function (packedArrays, atomicNum, densityMap, volTexMap, params) {
    var numAtoms = packedArrays.posRad.length / 4;
    var posRad = packedArrays.posRad;
    var colors = packedArrays.colors;
    var numVoxels = this.numVoxels;
    var radScale = params.radScale;
    var gaussLim = params.gaussLim;
    var gridSpacing = params.gridSpacing;
    var invIsoValue = 1 / params.isoValue;
    var invGridSpacing = 1 / gridSpacing;
    var maxVoxelX = numVoxels[0] - 1;
    var maxVoxelY = numVoxels[1] - 1;
    var maxVoxelZ = numVoxels[2] - 1;
    //TODO is densityMap and volTexMap initialized?
    for (var i = 0; i < numAtoms; ++i) {
      var ind = i * 4;
      var scaledRad = posRad[ind + 3] * radScale;
      var atomicNumFactor = atomicNum === null ? 1 : atomicNum[i];
      var radInv = 1 / (2 * scaledRad * scaledRad);
      var radLim = gaussLim * scaledRad;
      var radLim2 = radLim * radLim;
      radLim *= invGridSpacing;
      var tmp = posRad[ind] * invGridSpacing;
      var xMin = Math.max(tmp - radLim | 0, 0);
      var xMax = Math.min(tmp + radLim | 0, maxVoxelX);
      tmp = posRad[ind + 1] * invGridSpacing;
      var yMin = Math.max(tmp - radLim | 0, 0);
      var yMax = Math.min(tmp + radLim | 0, maxVoxelY);
      tmp = posRad[ind + 2] * invGridSpacing;
      var zMin = Math.max(tmp - radLim | 0, 0);
      var zMax = Math.min(tmp + radLim | 0, maxVoxelZ);
      var dz = zMin * gridSpacing - posRad[ind + 2];
      for (var z = zMin; z <= zMax; ++z, dz += gridSpacing) {
        var dy = yMin * gridSpacing - posRad[ind + 1];
        for (var y = yMin; y <= yMax; ++y, dy += gridSpacing) {
          var dy2dz2 = dy * dy + dz * dz;
          if (dy2dz2 >= radLim2) {
            continue;
          }
          var addr = z * numVoxels[0] * numVoxels[1] + y * numVoxels[0];
          var dx = xMin * gridSpacing - posRad[ind];
          for (var x = xMin; x <= xMax; ++x, dx += gridSpacing) {
            var r2 = dx * dx + dy2dz2;
            var expVal = -r2 * radInv;
            // TODO use faster exp?
            var density = Math.exp(expVal) * atomicNumFactor;
            densityMap[addr + x] += density;
            // TODO check for volTexMap routine?
            density *= invIsoValue;
            var cAddr = (addr + x) * 3;
            var colInd = i * 3;
            volTexMap[cAddr] += density * colors[colInd];
            volTexMap[cAddr + 1] += density * colors[colInd + 1];
            volTexMap[cAddr + 2] += density * colors[colInd + 2];
          }
        }
      }
    }
  };
  QuickSurfGroup.prototype._findMinMax = function (posRadArray) {
    var itemSize = 4;
    var itemsCount = posRadArray.length / itemSize;
    var maxPosRad = [
      posRadArray[0],
      posRadArray[1],
      posRadArray[2],
      posRadArray[3]
    ];
    var minPosRad = [
      posRadArray[0],
      posRadArray[1],
      posRadArray[2],
      posRadArray[3]
    ];
    for (var i = 1; i < itemsCount; ++i) {
      var ind = i * itemSize;
      for (var itemIdx = 0; itemIdx < itemSize; ++itemIdx) {
        var tmpVal = posRadArray[ind + itemIdx];
        maxPosRad[itemIdx] = Math.max(tmpVal, maxPosRad[itemIdx]);
        minPosRad[itemIdx] = Math.min(tmpVal, minPosRad[itemIdx]);
      }
    }
    return {
      maxPosRad: maxPosRad,
      minPosRad: minPosRad
    };
  };
  QuickSurfGroup.prototype._findNumVoxels = function (posRadArray, params) {
    var numVoxels = this.numVoxels;
    var minMaxValues = this._findMinMax(posRadArray);
    var minCoordRad = minMaxValues.minPosRad;
    var maxCoordRad = minMaxValues.maxPosRad;
    // minrad
    if (minCoordRad[3] > 4) {
      params.gridSpacing *= minCoordRad[3];
    }
    var gridPadding = params.radScale * maxCoordRad[3] * 1.7;
    var padRad = gridPadding;
    padRad = 0.65 * Math.sqrt(4 / 3 * Math.PI * padRad * padRad * padRad);
    gridPadding = Math.max(gridPadding, padRad);
    var i = 0;
    for (; i < 3; ++i) {
      minCoordRad[i] -= gridPadding;
      maxCoordRad[i] += gridPadding;
    }
    for (i = 0; i < 3; ++i) {
      numVoxels[i] = Math.ceil((maxCoordRad[i] - minCoordRad[i]) / params.gridSpacing);
    }
    this.xAxis.x = (numVoxels[0] - 1) * params.gridSpacing;
    this.yAxis.y = (numVoxels[1] - 1) * params.gridSpacing;
    this.zAxis.z = (numVoxels[2] - 1) * params.gridSpacing;
    this.origin.x = minCoordRad[0];
    this.origin.y = minCoordRad[1];
    this.origin.z = minCoordRad[2];
  };
  QuickSurfGroup.prototype._shiftByOrigin = function (posRadArray) {
    var originX = this.origin.x;
    var originY = this.origin.y;
    var originZ = this.origin.z;
    var itemSize = 4;
    var itemsCount = posRadArray.length / itemSize;
    for (var i = 0; i < itemsCount; ++i) {
      var ind = i * itemSize;
      posRadArray[ind] -= originX;
      posRadArray[ind + 1] -= originY;
      posRadArray[ind + 2] -= originZ;
    }
  };
  QuickSurfGroup.prototype._getTrimesh = function (volMap, volTexMap, params) {
    var surfVol = new VolumetricData(this.origin, this.xAxis, this.yAxis, this.zAxis, this.numVoxels, volMap);
    surfVol.computeVolumeGradient();
    var isoSurf = new IsoSurface();
    isoSurf.compute(surfVol, params.isoValue, 1);
    isoSurf.vertexFusion(surfVol, 9, 9);
    //normalization is included
    if (isoSurf._numTriangles > 0) {
      isoSurf.setColorVolTex(volTexMap);
      var mesh = new THREE.Mesh(isoSurf.toMesh(), this._material);
      return mesh;
    }
    return null;
  };
  QuickSurfGroup.prototype._calcSurface = function (complex, colorer, mode, mask, params) {
    var packedArrays;
    if (params.useBeads) {
      packedArrays = this._packBeads(complex, colorer, mode, mask);
    } else {
      packedArrays = this._packAtoms(complex, colorer, mode, mask);
    }
    if (packedArrays.posRad.length === 0) {
      return new THREE.Group();
    }
    this._findNumVoxels(packedArrays.posRad, params);
    this._shiftByOrigin(packedArrays.posRad);
    var volSize = this.numVoxels[0] * this.numVoxels[1] * this.numVoxels[2];
    // TODO multiply by 3?!
    var volMap = utils.allocateTyped(Float32Array, volSize);
    var volTexMap = utils.allocateTyped(Float32Array, volSize * 3);
    // TODO fill volTexMap and volMap with zeros !!
    /*for (var i = 0; i < volSize; ++i) {
      volMap[i * 3] = volTexMap[i * 3] = 0;
      volMap[i * 3 + 1] = volTexMap[i * 3 + 1] = 0;
      volMap[i * 3 + 2] = volTexMap[i * 3 + 2] = 0;
    }*/
    this.gaussdensity(packedArrays, null, volMap, volTexMap, params);
    packedArrays.posRad = null;
    packedArrays.colors = null;
    return this._getTrimesh(volMap, volTexMap, params);
  };
  QuickSurfGroup.prototype.onBeforeRender = function (camera) {
    var modelView = new THREE.Matrix4().multiplyMatrices(this.matrixWorld, camera.matrixWorldInverse);
    var scale = new THREE.Vector3().setFromMatrixColumn(modelView, 0);
    var s = scale.length();
    for (var i = 0; i < this.children.length; ++i) {
      var m = this.children[i];
      var center = new THREE.Vector3().copy(m.geometry.boundingSphere.center);
      m.localToWorld(center);
      m.material.uberOptions.zClipValue = camera.position.z - center.z - s * (m.material.uberOptions.zClipCoef * m.geometry.boundingSphere.radius);
    }
  };
  QuickSurfGroup.prototype.raycast = function (_raycaster, _intersects) {
  };
  QuickSurfGroup.prototype.getSubset = function (_mask) {
    // TODO implement
    return [];
  };
  function buildQuickSurf(SphereBuilderName, complex, colorer, mode, polyComplexity, mask, material) {
    return new QuickSurfGroup(SphereBuilderName, complex, colorer, mode, polyComplexity, mask, material);
  }
  return buildQuickSurf;
}(three, settings, gfx_modes_IsoSurfaceWMD, gfx_modes_VolumetricDataVMD, utils);
gfx_modes_QuickSufrMode = function (THREE, settings, buildQuickSurf) {
  function QuickSurfMode(opts) {
    this._opts = Object.create(opts);
  }
  QuickSurfMode.prototype.id = 'QUICK_SURF_MODE';
  QuickSurfMode.prototype.shortId = 'QS';
  QuickSurfMode.prototype.name = QuickSurfMode.prototype.shortName = 'Quick surf';
  QuickSurfMode.prototype.getUberOptions = function () {
    return { zClipCoef: this._opts.zClip ? 0.5 : 2 };
  };
  QuickSurfMode.prototype.getQuickSurfParams = function () {
    return this._quickSurfParams;
  };
  QuickSurfMode.prototype.calcAtomRadius = function (atom) {
    return atom.getType().radius;
  };
  QuickSurfMode.prototype.getResidueRadius = function (_residue) {
    return this.TUBE_RADIUS;
  };
  QuickSurfMode.prototype.getWireframe = function (_residue) {
    return this._opts.wireframe;
  };
  QuickSurfMode.prototype.buildGeometry = function (complex, colorer, mask, material) {
    this._quickSurfParams = {
      useBeads: false,
      isoValue: this._opts.isoValue,
      gaussLim: this._opts.gaussLim[settings.now.resolution],
      radScale: this._opts.scale,
      gridSpacing: this._opts.gridSpacing[settings.now.resolution]
    };
    return buildQuickSurf(complex, colorer, this, 1, mask, material);
  };
  return QuickSurfMode;
}(three, settings, gfx_modes_buildQuickSurf);
gfx_modes_IsoSurfaceSESMode = function (IsoSurfaceMode) {
  function IsoSurfaceSESMode(opts) {
    IsoSurfaceMode.call(this, true, opts);
  }
  IsoSurfaceSESMode.prototype = Object.create(IsoSurfaceMode.prototype);
  IsoSurfaceSESMode.prototype.constructor = IsoSurfaceSESMode;
  IsoSurfaceSESMode.prototype.id = 'ISOSURFACE_SES_MODE';
  IsoSurfaceSESMode.prototype.shortId = 'SE';
  IsoSurfaceSESMode.prototype.name = 'Solvent Excluded Surface';
  IsoSurfaceSESMode.prototype.shortName = 'SES';
  return IsoSurfaceSESMode;
}(gfx_modes_IsoSurfaceMode);
gfx_modes = function (settings, _LN, _LM, _BS, _VW, _TR, _TU, _CA, _SA, _QS, _SE) {
  // FIXME: deps for amdclean
  var modeList = [];
  var modeDict = {};
  (function (plugins) {
    for (var i = 0, n = plugins.length; i < n; ++i) {
      var Mode = plugins[i];
      modeList.push(Mode);
      if (Mode.prototype.id) {
        modeDict[Mode.prototype.id] = Mode;
      }
      if (Mode.prototype.shortId) {
        modeDict[Mode.prototype.shortId] = Mode;
      }
    }
  }(Array.prototype.slice.call(arguments, 1)));
  return {
    list: modeList,
    any: modeDict[settings.now.presets.default[0].mode] || modeList[0],
    get: function (name) {
      return modeDict[name];
    },
    create: function (name, opts) {
      if (!opts && name instanceof Array) {
        opts = name[1];
        name = name[0];
      }
      var Mode = this.get(name) || this.any;
      return new Mode(opts || settings.now.modes[Mode.prototype.shortId] || {});
    },
    normalize: function (name) {
      var Mode = this.get(name) || this.any;
      return Mode.prototype.id;
    }
  };
}(settings, gfx_modes_LinesMode, gfx_modes_LicoriceMode, gfx_modes_BallsAndSticksMode, gfx_modes_VanDerWaalsMode, gfx_modes_TraceMode, gfx_modes_TubeMode, gfx_modes_CartoonMode, gfx_modes_IsoSurfaceSASMode, gfx_modes_QuickSufrMode, gfx_modes_IsoSurfaceSESMode);
gfx_palettes_Palette = function () {
  function Palette(name, id, shortId) {
    this.name = name || 'Custom';
    this.id = id || 'CUSTOM_PALETTE';
    this.shortId = shortId || 'CP';
  }
  Palette.prototype = {
    constructor: Palette,
    /* eslint-disable no-magic-numbers */
    colors: [
      16777215,
      16711680,
      65280,
      255,
      8421504
    ],
    minRangeColor: 0,
    midRangeColor: 8355711,
    maxRangeColor: 16777215,
    defaultElementColor: 16777215,
    elementColors: {},
    defaultResidueColor: 16777215,
    residueColors: {},
    chainColors: [16777215],
    defaultSecondaryColor: 16777215,
    secondaryColors: {},
    /* eslint-enable no-magic-numbers */
    getElementColor: function (name) {
      var color = this.elementColors[name];
      return color === undefined ? this.defaultElementColor : color;
    },
    getResidueColor: function (name) {
      var color = this.residueColors[name];
      return color === undefined ? this.defaultResidueColor : color;
    },
    getChainColor: function (name) {
      var chain = name.charCodeAt(0);
      chain = ((chain < 0 ? 0 : chain >= 256 ? chain - 256 : chain) & 31) % this.chainColors.length;
      return this.chainColors[chain];
    },
    getSecondaryColor: function (name) {
      var color = this.secondaryColors[name];
      return color === undefined ? this.defaultSecondaryColor : color;
    },
    getSequentialColor: function (index) {
      var colors = this.colors;
      var len = colors.length;
      return index < 0 ? colors[index % len + len] : colors[index % len];
    },
    getRangedColor: function (_value, _min, _max) {
      return this.colors[0];  // TODO: interpolate between three colors
    }
  };
  return Palette;
}();
gfx_palettes_JmolPalette = function (Palette) {
  var palette = new Palette('Jmol', 'JMOL_PALETTE', 'JM');
  palette.colors = [
    /* eslint-disable no-magic-numbers */
    255,
    // blue
    22015,
    //
    44031,
    //
    65535,
    // cyan
    65451,
    //
    65365,
    //
    65280,
    // green
    5635840,
    //
    11271936,
    //
    16776960,
    // yellow
    16755456,
    //
    16733440,
    //
    16711680,
    // red
    16711765,
    //
    16711851,
    //
    16711935,
    // magenta
    11206911,
    //
    5570815
  ];
  // DO NOT EDIT MANUALLY! Autogenerated from atom_types.csv by atom_types.py.
  palette.elementColors = {
    /* eslint-disable no-magic-numbers */
    H: 16777215,
    HE: 14286847,
    LI: 13402367,
    BE: 12779264,
    B: 16758197,
    C: 9474192,
    N: 3166456,
    O: 16715021,
    F: 9494608,
    NE: 11789301,
    NA: 11230450,
    MG: 9109248,
    AL: 12560038,
    SI: 15780000,
    P: 16744448,
    S: 16777008,
    CL: 2093087,
    AR: 8442339,
    K: 9388244,
    CA: 4062976,
    SC: 15132390,
    TI: 12567239,
    V: 10921643,
    CR: 9083335,
    MN: 10255047,
    FE: 14706227,
    CO: 15765664,
    NI: 5296208,
    CU: 13140019,
    ZN: 8224944,
    GA: 12750735,
    GE: 6721423,
    AS: 12419299,
    SE: 16752896,
    BR: 10889513,
    KR: 6076625,
    RB: 7351984,
    SR: 65280,
    Y: 9764863,
    ZR: 9756896,
    NB: 7586505,
    MO: 5551541,
    TC: 3907230,
    RU: 2396047,
    RH: 687500,
    PD: 27013,
    AG: 12632256,
    CD: 16767375,
    IN: 10909043,
    SN: 6717568,
    SB: 10380213,
    TE: 13924864,
    I: 9699476,
    XE: 4366000,
    CS: 5707663,
    BA: 51456,
    LA: 7394559,
    CE: 16777159,
    PR: 14286791,
    ND: 13107143,
    PM: 10747847,
    SM: 9437127,
    EU: 6422471,
    GD: 4587463,
    TB: 3211207,
    DY: 2097095,
    HO: 65436,
    ER: 58997,
    TM: 54354,
    YB: 48952,
    LU: 43812,
    HF: 5096191,
    TA: 5089023,
    W: 2200790,
    RE: 2522539,
    OS: 2516630,
    IR: 1528967,
    PT: 13684960,
    AU: 16765219,
    HG: 12105936,
    TL: 10900557,
    PB: 5724513,
    BI: 10375093,
    PO: 11230208,
    AT: 7688005,
    RN: 4358806,
    FR: 4325478,
    RA: 32000,
    AC: 7384058,
    TH: 47871,
    PA: 41471,
    U: 36863,
    NP: 33023,
    PU: 27647,
    AM: 5528818,
    CM: 7888099,
    BK: 9064419,
    CF: 10565332,
    ES: 11739092,
    FM: 11739066,
    MD: 11734438,
    NO: 12389767,
    LR: 13041766,
    RF: 13369433,
    DB: 13697103,
    SG: 14221381,
    BH: 14680120,
    HS: 15073326,
    MT: 15400998  /* eslint-enable no-magic-numbers */
  };
  palette.defaultResidueColor = 12492910;
  // DO NOT EDIT MANUALLY! Autogenerated from residue_types.csv by residue_types.py.
  palette.residueColors = {
    /* eslint-disable no-magic-numbers */
    'ALA': 13158600,
    'ARG': 1334015,
    'ASN': 56540,
    'ASP': 15075850,
    'CYS': 15132160,
    'GLY': 56540,
    'GLU': 15075850,
    'GLN': 15461355,
    'HIS': 8553170,
    'ILE': 1016335,
    'LEU': 1016335,
    'LYS': 1334015,
    'MET': 15132160,
    'PHE': 3289770,
    'PRO': 14456450,
    'SER': 16422400,
    'THR': 16422400,
    'TRP': 11819700,
    'TYR': 3289770,
    'VAL': 1016335,
    'A': 10526975,
    'C': 16747595,
    'G': 16740464,
    'I': 8454143,
    'T': 10551200,
    'U': 16744576,
    'DA': 10526975,
    'DC': 16747595,
    'DG': 16740464,
    'DI': 8454143,
    'DT': 10551200,
    'DU': 16744576,
    '+A': 10526975,
    '+C': 16747595,
    '+G': 16740464,
    '+I': 8454143,
    '+T': 10551200,
    '+U': 16744576  /* eslint-enable no-magic-numbers */
  };
  palette.chainColors = [
    // ' '->0 'A'->1, 'B'->2
    4294967295,
    // ' ' & '0' white
    //
    4290826495,
    // skyblue
    4289789872,
    // pastel green
    4294951112,
    // pink
    4294967168,
    // pastel yellow
    4294951167,
    // pastel magenta
    4289786096,
    // pastel cyan
    4294955120,
    // pastel gold
    4293951616,
    // lightcoral
    4294303411,
    // wheat
    4278239231,
    // deepskyblue
    4291648604,
    // indianred
    4284927402,
    // mediumaquamarine
    4288335154,
    // yellowgreen
    4293821166,
    // violet
    4278243025,
    // darkturquoise
    4278255487,
    // springgreen
    4282168177,
    // mediumseagreen
    4278190219,
    // darkblue
    4290623339,
    // darkkhaki
    4278215680,
    // darkgreen
    4286578688,
    // maroon
    4286611456,
    // olive
    4286578816,
    // purple
    4278222976,
    // teal
    4290283019,
    // darkgoldenrod
    4289864226
  ];
  palette.secondaryColors = {
    'helix': 16711808,
    'strand': 16762880
  };
  return palette;
}(gfx_palettes_Palette);
gfx_palettes_VmdPalette = function (Palette) {
  var palette = new Palette('VMD', 'VMD_PALETTE', 'VM');
  palette.colors = [
    /* eslint-disable no-magic-numbers */
    255,
    // blue
    16711680,
    // red
    6316128,
    // gray
    16744448,
    // orange
    16776960,
    // yellow
    8421427,
    // tan
    10066329,
    // silver
    65280,
    // green
    16777215,
    // white
    16751001,
    // pink
    4243648,
    // cyan
    10879142,
    // purple
    8447590,
    // lime
    15099571,
    // mauve
    8408320,
    // ochre
    8421568  // ice blue
             /* eslint-enable no-magic-numbers */
  ];
  palette.defaultElementColor = 8408320;
  // DO NOT EDIT MANUALLY! Autogenerated from atom_types.csv by atom_types.py.
  palette.elementColors = {
    /* eslint-disable no-magic-numbers */
    H: 16777215,
    C: 4243391,
    N: 255,
    O: 16711680,
    P: 8421427,
    S: 16776960  /* eslint-enable no-magic-numbers */
  };
  palette.defaultResidueColor = 4243648;
  // DO NOT EDIT MANUALLY! Autogenerated from residue_types.csv by residue_types.py.
  palette.residueColors = {
    /* eslint-disable no-magic-numbers */
    'ALA': 255,
    'ARG': 16777215,
    'ASN': 8421427,
    'ASP': 16711680,
    'CYS': 16776960,
    'GLY': 16777215,
    'GLU': 16751001,
    'GLN': 16744448,
    'HIS': 4243648,
    'ILE': 65280,
    'LEU': 16751001,
    'LYS': 4243648,
    'MET': 16776960,
    'PHE': 10879142,
    'PRO': 8408064,
    'SER': 16776960,
    'THR': 15099571,
    'TRP': 10066329,
    'TYR': 65280,
    'VAL': 8421427,
    'A': 255,
    'C': 16744448,
    'G': 16776960,
    'T': 10879142,
    'U': 65280,
    'DA': 255,
    'DC': 16744448,
    'DG': 16776960,
    'DT': 10879142,
    'DU': 65280,
    '+A': 255,
    '+C': 16744448,
    '+G': 16776960,
    '+T': 10879142,
    '+U': 65280,
    'WAT': 4243648,
    'H2O': 4243648,
    'HOH': 4243648  /* eslint-enable no-magic-numbers */
  };
  palette.chainColors = [16777215].concat(palette.colors);
  palette.secondaryColors = {
    'helix': 10879142,
    'strand': 16776960
  };
  return palette;
}(gfx_palettes_Palette);
gfx_palettes = function (_JM, _VM) {
  // FIXME: deps for amdclean
  var paletteList = [];
  var paletteDict = {};
  for (var i = 0, n = arguments.length; i < n; ++i) {
    var palette = arguments[i];
    paletteList.push(palette);
    if (palette.id) {
      paletteDict[palette.id] = palette;
    }
  }
  return {
    list: paletteList,
    any: paletteList[0],
    get: function (name) {
      return paletteDict[name];
    }
  };
}(gfx_palettes_JmolPalette, gfx_palettes_VmdPalette);
gfx_colorers_AtomTypeColorer = function (palettes) {
  /**
   * Coloring algorithm based on chemical element.
   *
   * @see AtomType
   *
   * @exports AtomTypeColorer
   * @constructor
   */
  function AtomTypeColorer() {
    this.palette = palettes.any;
  }
  AtomTypeColorer.prototype.id = 'ATOM_TYPE_COLORER';
  AtomTypeColorer.prototype.shortId = 'AT';
  AtomTypeColorer.prototype.name = 'Atom Type';
  AtomTypeColorer.prototype.shortName = 'Atom';
  AtomTypeColorer.prototype.getAtomColor = function (atom, _complex) {
    return this.palette.getElementColor(atom._type.name);
  };
  AtomTypeColorer.prototype.getResidueColor = function (_residue, _complex) {
    return this.palette.defaultResidueColor;
  };
  return AtomTypeColorer;
}(gfx_palettes);
gfx_colorers_ResidueTypeColorer = function (palettes) {
  /**
   * Coloring algorithm based on residue type.
   *
   * @see ResidueType
   *
   * @exports ResidueTypeColorer
   * @constructor
   */
  function ResidueTypeColorer() {
    this.palette = palettes.any;
  }
  ResidueTypeColorer.prototype.id = 'RESIDUE_TYPE_COLORER';
  ResidueTypeColorer.prototype.shortId = 'RT';
  ResidueTypeColorer.prototype.name = 'Residue Type';
  ResidueTypeColorer.prototype.shortName = 'Residue';
  ResidueTypeColorer.prototype.getAtomColor = function (atom, complex) {
    return this.getResidueColor(atom._residue, complex);
  };
  ResidueTypeColorer.prototype.getResidueColor = function (residue, _complex) {
    return this.palette.getResidueColor(residue._type._name);
  };
  return ResidueTypeColorer;
}(gfx_palettes);
gfx_colorers_ResidueIdColorer = function (palettes) {
  function ResidueIdColorer(_opts) {
    this.palette = palettes.any;
  }
  ResidueIdColorer.prototype.id = 'RESIDUE_ID_COLORER';
  ResidueIdColorer.prototype.shortId = 'RI';
  ResidueIdColorer.prototype.name = ResidueIdColorer.prototype.shortName = 'Residue ID';
  ResidueIdColorer.prototype.getAtomColor = function (atom, complex) {
    return this.getResidueColor(atom._residue, complex);
  };
  ResidueIdColorer.prototype.getResidueColor = function (residue, _complex) {
    // TODO: provide coloring algorithm
    return this.palette.getSequentialColor(residue._sequence);
  };
  return ResidueIdColorer;
}(gfx_palettes);
gfx_colorers_ChainColorer = function (palettes) {
  function ChainColorer(_opts) {
    this.palette = palettes.any;
  }
  ChainColorer.prototype.id = 'CHAIN_COLORER';
  ChainColorer.prototype.shortId = 'CH';
  ChainColorer.prototype.name = ChainColorer.prototype.shortName = 'Chain';
  ChainColorer.prototype.getAtomColor = function (atom, complex) {
    return this.getResidueColor(atom._residue, complex);
  };
  ChainColorer.prototype.getResidueColor = function (residue, _complex) {
    return this.palette.getChainColor(residue.getChain()._name);
  };
  return ChainColorer;
}(gfx_palettes);
gfx_colorers_SecondaryStructureColorer = function (palettes) {
  function SecondaryStructureColorer(_opts) {
    this.palette = palettes.any;
  }
  SecondaryStructureColorer.prototype.id = 'SECONDARY_STRUCTURE_COLORER';
  SecondaryStructureColorer.prototype.shortId = 'SS';
  SecondaryStructureColorer.prototype.name = 'Secondary Structure';
  SecondaryStructureColorer.prototype.shortName = 'Structure';
  SecondaryStructureColorer.prototype.getAtomColor = function (atom, complex) {
    return this.getResidueColor(atom._residue, complex);
  };
  SecondaryStructureColorer.prototype.getResidueColor = function (residue, _complex) {
    var secondary = residue.getSecondary();
    return this.palette.getSecondaryColor(secondary === null ? '' : secondary.type);
  };
  return SecondaryStructureColorer;
}(gfx_palettes);
gfx_colorers_UniformColorer = function (palettes) {
  function UniformColorer(opts) {
    this.palette = palettes.any;
    this.opts = Object.create(opts);
  }
  UniformColorer.prototype.id = 'UNIFORM_COLORER';
  UniformColorer.prototype.shortId = 'UN';
  UniformColorer.prototype.name = UniformColorer.prototype.shortName = 'Uniform';
  UniformColorer.prototype.getAtomColor = function (_atom, _complex) {
    return this.opts.color;
  };
  UniformColorer.prototype.getResidueColor = function (_residue, _complex) {
    return this.opts.color;
  };
  return UniformColorer;
}(gfx_palettes);
gfx_colorers = function (settings, _AT, _RT, _RI, _CH, _SS, _UN) {
  // FIXME: deps for amdclean
  var colorerList = [];
  var colorerDict = {};
  (function (plugins) {
    for (var i = 0, n = plugins.length; i < n; ++i) {
      var Colorer = plugins[i];
      colorerList.push(Colorer);
      if (Colorer.prototype.id) {
        colorerDict[Colorer.prototype.id] = Colorer;
      }
      if (Colorer.prototype.shortId) {
        colorerDict[Colorer.prototype.shortId] = Colorer;
      }
    }
  }(Array.prototype.slice.call(arguments, 1)));
  return {
    list: colorerList,
    any: colorerDict[settings.now.presets.default[0].colorer] || colorerList[0],
    get: function (name) {
      return colorerDict[name];
    },
    create: function (name, opts) {
      if (!opts && name instanceof Array) {
        opts = name[1];
        name = name[0];
      }
      var Colorer = this.get(name) || this.any;
      return new Colorer(opts || settings.now.colorers[Colorer.prototype.shortId] || {});
    },
    normalize: function (name) {
      var Colorer = this.get(name) || this.any;
      return Colorer.prototype.id;
    }
  };
}(settings, gfx_colorers_AtomTypeColorer, gfx_colorers_ResidueTypeColorer, gfx_colorers_ResidueIdColorer, gfx_colorers_ChainColorer, gfx_colorers_SecondaryStructureColorer, gfx_colorers_UniformColorer);
gfx_materials = function (THREE, settings) {
  function neutralColor(intensity) {
    return new THREE.Color(intensity, intensity, intensity);
  }
  var materialList = [
    {
      id: 'MATERIAL_DIFFUSE',
      shortId: 'DF',
      name: 'Diffuse',
      shortName: 'Diffuse',
      uberOptions: {
        diffuse: neutralColor(1),
        specular: neutralColor(0),
        shininess: 1,
        opacity: 1
      }
    },
    {
      id: 'MATERIAL_TRANSPARENT',
      shortId: 'TR',
      name: 'Transparent',
      shortName: 'Transparent',
      uberOptions: {
        diffuse: neutralColor(1),
        specular: neutralColor(0),
        shininess: 1,
        opacity: 0.3
      }
    },
    {
      id: 'MATERIAL_SOFT',
      shortId: 'SF',
      name: 'Soft Plastic',
      shortName: 'Soft',
      uberOptions: {
        diffuse: neutralColor(1),
        specular: neutralColor(0.1),
        shininess: 30,
        opacity: 1
      }
    },
    {
      id: 'MATERIAL_PLASTIC',
      shortId: 'PL',
      name: 'Glossy Plastic',
      shortName: 'Glossy',
      uberOptions: {
        diffuse: neutralColor(0.56),
        specular: neutralColor(0.28),
        shininess: 100,
        opacity: 1
      }
    },
    {
      id: 'MATERIAL_METAL',
      shortId: 'ME',
      name: 'Metal',
      shortName: 'Metal',
      uberOptions: {
        diffuse: neutralColor(0.56),
        specular: neutralColor(0.55),
        shininess: 30,
        opacity: 1
      }
    },
    {
      id: 'MATERIAL_GLASS',
      shortId: 'GL',
      name: 'Glass',
      shortName: 'Glass',
      uberOptions: {
        diffuse: neutralColor(0.5),
        specular: neutralColor(0.65),
        shininess: 100,
        opacity: 0.3
      }
    }
  ];
  var materialDict = {};
  for (var i = 0, n = materialList.length; i < n; ++i) {
    if (materialList[i].id) {
      materialDict[materialList[i].id] = materialList[i];
    }
    if (materialList[i].shortId) {
      materialDict[materialList[i].shortId] = materialList[i];
    }
  }
  return {
    list: materialList,
    any: materialDict[settings.now.presets.default.material] || materialList[0],
    get: function (id) {
      return materialDict[id];
    },
    normalize: function (name) {
      var material = this.get(name) || this.any;
      return material.id;
    }
  };
}(three, settings);
gfx_Representation = function (THREE, materials, UberMaterial) {
  function Representation(index, mode, colorer, selector) {
    this.index = index;
    this.mode = mode;
    this.colorer = colorer;
    this.selector = selector;
    this.selectorString = '';
    // FIXME
    this.count = 0;
    this.material = new UberMaterial();
    this.materialPreset = materials.any;
    this.needsRebuild = true;
    this.visible = true;
    // apply mode params & preset
    this.setMode(mode);
  }
  Representation.prototype.markAtoms = function (complex) {
    this.count = complex.markAtoms(this.selector, 1 << this.index);
    this.needsRebuild = true;
    return this.count;
  };
  Representation.prototype.unmarkAtoms = function (complex) {
    complex.clearAtomBits(1 << this.index);
  };
  Representation.prototype.setMode = function (mode) {
    this.mode = mode;
    this.material.setUberOptions(this.mode.getUberOptions());
  };
  Representation.prototype.setMaterialPreset = function (preset) {
    this.materialPreset = preset;
    this.material.setUberOptions(preset.uberOptions);
  };
  Representation.prototype.reset = function () {
    this.geo = null;
    this.selectionGeo = null;
  };
  Representation.prototype.buildGeometry = function (complex) {
    this.reset();
    this.needsRebuild = false;
    this.geo = this.mode.buildGeometry(complex, this.colorer, 1 << this.index, this.material);
    this.geo.visible = this.visible;
    return this.geo;
  };
  Representation.prototype.buildSelectionGeometry = function (mask) {
    var sg = null;
    if (this.geo && 'getSubset' in this.geo) {
      var meshes = this.geo.getSubset(mask);
      if (meshes && meshes.length > 0) {
        sg = new THREE.Group();
        sg.matrixAutoUpdate = false;
        sg.matrix = this.geo.matrix;
        for (var j = 0; j < meshes.length; j++) {
          var m = meshes[j];
          sg.add(m);
        }
      }
    }
    if (sg) {
      sg.visible = this.visible;
    }
    this.selectionGeo = sg;
    return this.selectionGeo;
  };
  Representation.prototype.show = function (visible) {
    this.visible = visible;
    if (this.geo) {
      this.geo.visible = visible;
    }
    if (this.selectionGeo) {
      this.selectionGeo.visible = visible;
    }
  };
  return Representation;
}(three, gfx_materials, gfx_shaders_UberMaterial);
gfx_CSS2DRenderer = function (CSS2DObject, jQuery, THREE) {
  function CSS2DRenderer() {
    console.log('THREE.CSS2DRenderer', THREE.REVISION);
    this._width = 0;
    this._height = 0;
    this._widthHalf = 0;
    this._heightHalf = 0;
    this._vector = new THREE.Vector3();
    this._viewMatrix = new THREE.Matrix4();
    this._viewProjectionMatrix = new THREE.Matrix4();
    this._domElement = document.createElement('div');
    this._domElement.style.overflow = 'hidden';
    this._domElement.style.position = 'absolute';
    this._domElement.style.top = '0';
    this._domElement.style.pointerEvents = 'none';
  }
  CSS2DRenderer.prototype.getElement = function () {
    return this._domElement;
  };
  CSS2DRenderer.prototype.reset = function () {
    var myNode = this.getElement();
    while (myNode.firstChild) {
      myNode.removeChild(myNode.firstChild);
    }
  };
  CSS2DRenderer.prototype.setSize = function (width, height) {
    this._width = width;
    this._height = height;
    this._widthHalf = this._width / 2;
    this._heightHalf = this._height / 2;
    this._domElement.style.width = width + 'px';
    this._domElement.style.height = height + 'px';
  };
  CSS2DRenderer.prototype._renderObject = function (object, camera) {
    var i = 0;
    var l = 0;
    if (object instanceof CSS2DObject) {
      this._vector.setFromMatrixPosition(object.matrixWorld);
      this._vector.applyProjection(this._viewProjectionMatrix);
      var element = object.getElement();
      var style = 'translate(-50%, -50%) translate(' + (this._vector.x * this._widthHalf + this._widthHalf) + 'px,' + (-this._vector.y * this._heightHalf + this._heightHalf) + 'px)';
      element.style.visibility = 'visible';
      element.style.WebkitTransform = style;
      element.style.MozTransform = style;
      element.style.oTransform = style;
      element.style.transform = style;
      if (element.parentNode !== this._domElement) {
        this._domElement.appendChild(element);
      }
    }
    for (i = 0, l = object.children.length; i < l; i++) {
      this._renderObject(object.children[i], camera);
    }
  };
  CSS2DRenderer.prototype._hideObject = function (object) {
    var i = 0;
    var l = 0;
    if (object instanceof CSS2DObject) {
      var element = object.element;
      element.style.visibility = 'hidden';
    }
    for (i = 0, l = object.children.length; i < l; i++) {
      this._hideObject(object.children[i]);
    }
  };
  CSS2DRenderer.prototype.render = function (scene, camera) {
    scene.updateMatrixWorld();
    if (camera.parent === null) {
      camera.updateMatrixWorld();
    }
    camera.matrixWorldInverse.getInverse(camera.matrixWorld);
    this._viewMatrix.copy(camera.matrixWorldInverse.getInverse(camera.matrixWorld));
    this._viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, this._viewMatrix);
    this._renderObject(scene, camera);
  };
  return CSS2DRenderer;
}(gfx_CSS2DObject, jquery, three);
text = {
  load: function (id) {
    throw new Error('Dynamic load not allowed: ' + id);
  }
};
ui_ObjectControls = function (THREE, utils, settings) {
  var VK_LEFT = 37;
  var VK_UP = 38;
  var VK_RIGHT = 39;
  var VK_DOWN = 40;
  var STATE = {
    NONE: -1,
    ROTATE: 0,
    TRANSLATE: 1,
    SCALE_PAN: 2
  };
  // pausing for this amount of time before releasing mouse button prevents inertial rotation (seconds)
  var FULL_STOP_THRESHOLD = 0.1;
  var PAN_SPEED = 10;
  var PINCH_PAN_COEF = 0.1;
  // pivot -- local offset of the rotation pivot point
  function ObjectHandler(objects, camera, pivot, options) {
    this.objects = objects;
    this.object = objects[0];
    this.camera = camera;
    this.pivot = pivot;
    this.axis = new THREE.Vector3(0, 0, 1);
    this.options = options;
    this.lastRotation = {
      axis: new THREE.Vector3(),
      angle: 0
    };
  }
  ObjectHandler.prototype._rotate = function (quaternion) {
    var zeroPivot = this.pivot.x === 0 && this.pivot.y === 0 && this.pivot.z === 0;
    var m = this.object.matrix.clone();
    if (zeroPivot) {
      m.multiply(new THREE.Matrix4().makeRotationFromQuaternion(quaternion));
    } else {
      m.multiply(new THREE.Matrix4().makeTranslation(this.pivot.x, this.pivot.y, this.pivot.z));
      m.multiply(new THREE.Matrix4().makeRotationFromQuaternion(quaternion));
      m.multiply(new THREE.Matrix4().makeTranslation(-this.pivot.x, -this.pivot.y, -this.pivot.z));
    }
    var p = new THREE.Vector3();
    var q = new THREE.Quaternion();
    var s = new THREE.Vector3();
    m.decompose(p, q, s);
    // update objects
    if (!zeroPivot) {
      for (var i = 0; i < this.objects.length; ++i) {
        this.objects[i].position.copy(p);
      }
    }
    for (var j = 0; j < this.objects.length; ++j) {
      this.objects[j].quaternion.copy(q);
      this.objects[j].updateMatrix();
    }
  };
  ObjectHandler.prototype.setObjects = function (objects) {
    this.objects = objects;
    this.object = objects[0];
  };
  ObjectHandler.prototype.rotate = function (mousePrevPos, mouseCurPos, aboutAxis) {
    var rot = this.mouse2rotation(mousePrevPos, mouseCurPos, aboutAxis);
    if (rot.angle) {
      this._rotate(new THREE.Quaternion().setFromAxisAngle(rot.axis, rot.angle));
    }
    this.lastRotation = rot;
  };
  ObjectHandler.prototype.translate = function (delta) {
    // reverse-project viewport movement to view coords (compensate for screen aspect ratio)
    var d = new THREE.Vector3(delta.x / this.camera.projectionMatrix.elements[0], delta.y / this.camera.projectionMatrix.elements[5], 0);
    var dist = d.length();
    d.normalize();
    // transform movement direction to object local coords
    var invWorldMat = new THREE.Matrix4().getInverse(this.object.matrixWorld);
    d.transformDirection(invWorldMat);
    // visible translate distance shouldn't depend on camera-to-object distance
    var pivot = this.pivot.clone();
    this.object.localToWorld(pivot);
    dist *= Math.abs(pivot.z - this.camera.position.z);
    // visible translate distance shouldn't depend on object scale
    dist /= this.object.matrixWorld.getMaxScaleOnAxis();
    // all objects are translated similar to principal object
    // (we assume they all have identical pivot and scale)
    for (var i = 0; i < this.objects.length; ++i) {
      this.objects[i].translateOnAxis(d, dist);
    }
  };
  ObjectHandler.prototype.update = function (timeSinceLastUpdate, timeSinceMove) {
    if (settings.now.autoRotation !== 0) {
      // auto-rotation with constant speed
      var axis;
      // if rotation axis is fixed or hasn't been defined yet
      if (settings.now.autoRotationAxisFixed || this.lastRotation.axis.length() === 0) {
        // use Y-axis (transformed to local object coords)
        var invM = new THREE.Matrix4().getInverse(this.object.matrixWorld);
        axis = new THREE.Vector3(0, 1, 0).transformDirection(invM);
      } else {
        // use axis defined by last user rotation
        axis = this.lastRotation.axis;
      }
      this._rotate(new THREE.Quaternion().setFromAxisAngle(axis, settings.now.autoRotation * timeSinceLastUpdate));
      return true;
    }
    if (this.options.intertia && this.lastRotation.angle) {
      // inertial object rotation
      var angle = this.lastRotation.angle * Math.pow(1 - this.options.dynamicDampingFactor, 40 * timeSinceMove);
      if (Math.abs(angle) <= this.options.intertiaThreshold) {
        this.lastRotation.angle = 0;
      } else {
        this._rotate(new THREE.Quaternion().setFromAxisAngle(this.lastRotation.axis, angle));
        return true;
      }
    }
    return false;
  };
  ObjectHandler.prototype.stop = function () {
    this.lastRotation.angle = 0;
  };
  // calculate (axis, angle) pair from mouse/touch movement
  ObjectHandler.prototype.mouse2rotation = function (mousePrev, mouseCur, aboutAxis) {
    var res = {
      axis: new THREE.Vector3(),
      angle: 0
    };
    if (aboutAxis) {
      res.axis.copy(this.axis);
      res.angle = this.options.axisRotateFactor * (mouseCur.y - mousePrev.y);  /* cool method that allows rotation around Z axis to be "tied" to mouse cursor
                                                                               
                                                                                     res.axis.copy(this.axis);
                                                                               
                                                                                     var pivot = this.pivot.clone();
                                                                                     this.object.localToWorld(pivot);
                                                                                     pivot.project(this.camera);
                                                                               
                                                                                     var v1 = new THREE.Vector3(mousePrev.x, mousePrev.y, this.camera.position.z);
                                                                                     v1.sub(pivot);
                                                                                     var v2 = new THREE.Vector3(mouseCur.x, mouseCur.y, this.camera.position.z);
                                                                                     v2.sub(pivot);
                                                                               
                                                                                     v1.sub(res.axis.clone().multiplyScalar(v1.dot(res.axis)));
                                                                                     v2.sub(res.axis.clone().multiplyScalar(v2.dot(res.axis)));
                                                                               
                                                                                     var abs = v1.length() * v2.length();
                                                                                     if (abs > 0) {
                                                                                       res.angle = res.axis.dot(v1.cross(v2)) / abs;
                                                                                     }
                                                                                   */
    } else {
      var mouseDelta = mouseCur.clone().sub(mousePrev);
      var angle = mouseDelta.length();
      if (angle === 0) {
        return res;
      }
      var center = this.pivot.clone();
      this.object.localToWorld(center);
      var eye = new THREE.Vector3().subVectors(this.camera.position, center);
      var eyeDirection = eye.clone().normalize();
      var cameraUpDirection = this.camera.up.clone().normalize();
      var cameraSidewaysDirection = new THREE.Vector3().crossVectors(cameraUpDirection, eyeDirection).normalize();
      cameraUpDirection.setLength(mouseDelta.y);
      cameraSidewaysDirection.setLength(mouseDelta.x);
      var moveDirection = new THREE.Vector3().copy(cameraUpDirection.add(cameraSidewaysDirection));
      res.axis.crossVectors(moveDirection, eye);
      res.angle = -angle * this.options.rotateFactor;
    }
    var invWorldMat = new THREE.Matrix4().getInverse(this.object.matrixWorld);
    res.axis.transformDirection(invWorldMat);
    // make sure angle is always positive (thus 'axis' defines both axis and direction of rotation)
    if (res.angle < 0) {
      res.axis.negate();
      res.angle = -res.angle;
    }
    return res;
  };
  function ObjectControls(object, camera, domElement, getAltObj) {
    var self = this;
    this.object = object;
    this.camera = camera;
    this.domElement = typeof domElement !== 'undefined' ? domElement : document;
    this.getAltObj = getAltObj;
    // API
    this.enabled = true;
    this.screen = {
      left: 0,
      top: 0,
      width: 0,
      height: 0
    };
    this.options = {
      rotateFactor: Math.PI,
      // full screen slide (along short side) would roughly mean 180 deg. rotation
      axisRotateFactor: 4 * Math.PI,
      // full screen slide (along short side) would roughly mean 720 deg. rotation
      intertia: true,
      dynamicDampingFactor: 0.1,
      intertiaThreshold: 0.001
    };
    // internals
    this._state = STATE.NONE;
    this._mousePrevPos = new THREE.Vector2();
    this._mouseCurPos = new THREE.Vector2();
    this._originalCameraPos = new THREE.Vector3();
    this._mainObj = new ObjectHandler([this.object], this.camera, new THREE.Vector3(0, 0, 0), this.options);
    this._altObj = new ObjectHandler([this.object], this.camera, new THREE.Vector3(0, 0, 0), this.options);
    this._affectedObj = this._mainObj;
    this._isAltObjFreeRotationAllowed = true;
    this._isTranslationAllowed = true;
    this._isKeysTranslatingObj = false;
    this._pressedKeys = [];
    this._clock = new utils.Timer();
    this._clock.start();
    this._lastUpdateTime = this._clock.getElapsedTime();
    // events
    this._listeners = [
      {
        obj: self.domElement,
        type: 'mousedown',
        handler: function (e) {
          self.mousedown(e);
        }
      },
      {
        obj: self.domElement,
        type: 'mouseup',
        handler: function (e) {
          self.mouseup(e);
        }
      },
      {
        obj: self.domElement,
        type: 'mousemove',
        handler: function (e) {
          self.mousemove(e);
        }
      },
      {
        obj: self.domElement,
        type: 'mousewheel',
        handler: function (e) {
          self.mousewheel(e);
        }
      },
      {
        obj: self.domElement,
        type: 'DOMMouseScroll',
        handler: function (e) {
          self.mousewheel(e);
        }
      },
      {
        obj: self.domElement,
        type: 'mouseout',
        handler: function (e) {
          self.mouseup(e);
        }
      },
      {
        obj: self.domElement,
        type: 'touchstart',
        handler: function (e) {
          self.touchstartend(e);
        }
      },
      {
        obj: self.domElement,
        type: 'touchend',
        handler: function (e) {
          self.touchstartend(e);
        }
      },
      {
        obj: self.domElement,
        type: 'touchmove',
        handler: function (e) {
          self.touchmove(e);
        }
      },
      {
        obj: self.getKeyBindObject(),
        type: 'keydown',
        handler: function (e) {
          self.keydownup(e);
        }
      },
      {
        obj: self.getKeyBindObject(),
        type: 'keyup',
        handler: function (e) {
          self.keydownup(e);
        }
      },
      {
        obj: window,
        type: 'resize',
        handler: function () {
          self.handleResize();
        }
      },
      {
        obj: window,
        type: 'blur',
        handler: function () {
          self.resetKeys();
        }
      }
    ];
    for (var i = 0; i < this._listeners.length; i++) {
      var l = this._listeners[i];
      l.obj.addEventListener(l.type, l.handler);
    }
    this.handleResize();
    this.resetKeys();
    // force an update at start
    this.update();
  }
  // methods
  ObjectControls.prototype = Object.create(THREE.EventDispatcher.prototype);
  ObjectControls.prototype.constructor = ObjectControls;
  ObjectControls.prototype.resetKeys = function () {
    this._pressedKeys[VK_LEFT] = false;
    this._pressedKeys[VK_UP] = false;
    this._pressedKeys[VK_RIGHT] = false;
    this._pressedKeys[VK_DOWN] = false;
  };
  ObjectControls.prototype.handleResize = function () {
    if (this.domElement === document) {
      this.screen.left = 0;
      this.screen.top = 0;
      this.screen.width = window.innerWidth;
      this.screen.height = window.innerHeight;
    } else {
      var box = this.domElement.getBoundingClientRect();
      // adjustments come from similar code in the jquery offset() function
      var d = this.domElement.ownerDocument.documentElement;
      this.screen.left = box.left + window.pageXOffset - d.clientLeft;
      this.screen.top = box.top + window.pageYOffset - d.clientTop;
      this.screen.width = box.width;
      this.screen.height = box.height;
    }
  };
  ObjectControls.prototype.enable = function (enable) {
    this.enabled = enable;
  };
  ObjectControls.prototype.allowTranslation = function (allow) {
    this._isTranslationAllowed = allow;
  };
  ObjectControls.prototype.allowAltObjFreeRotation = function (allow) {
    this._isAltObjFreeRotationAllowed = allow;
  };
  ObjectControls.prototype.keysTranslateObj = function (on) {
    this._isKeysTranslatingObj = on;
  };
  ObjectControls.prototype.isEditingAltObj = function () {
    return (this._state === STATE.ROTATE || this._state === STATE.TRANSLATE) && this._affectedObj === this._altObj;
  };
  // convert page coords of mouse/touch to uniform coords with smaller side being [-0.5, 0.5]
  // (uniform coords keep direct proportion with screen distance travelled by mouse regardless of screen aspect ratio)
  ObjectControls.prototype.getMouseOnCircle = function (pageX, pageY) {
    var screenSize = Math.min(this.screen.width, this.screen.height);
    if (screenSize === 0) {
      return new THREE.Vector2(0, 0);
    }
    return new THREE.Vector2((pageX - this.screen.width * 0.5 - this.screen.left) / screenSize, (0.5 * this.screen.height + this.screen.top - pageY) / screenSize);
  };
  // convert page coords of mouse/touch to viewport coords with both sides being [-1, 1]
  // (those are non-uniform coords affected by screen aspect ratio)
  ObjectControls.prototype.getMouseViewport = function (pageX, pageY) {
    if (this.screen.width === 0 || this.screen.height === 0) {
      return new THREE.Vector2(0, 0);
    }
    return new THREE.Vector2(2 * (pageX - this.screen.width * 0.5 - this.screen.left) / this.screen.width, 2 * (0.5 * this.screen.height + this.screen.top - pageY) / this.screen.height);
  };
  ObjectControls.prototype.stop = function () {
    this._mainObj.stop();
    this._altObj.stop();
  };
  // rotate object based on latest mouse/touch movement
  ObjectControls.prototype.rotate = function (aboutZAxis) {
    this._affectedObj.rotate(this._mousePrevPos, this._mouseCurPos, aboutZAxis);
    this.dispatchEvent({ type: 'change' });
  };
  // translate object based on latest mouse/touch movement
  ObjectControls.prototype.translate = function () {
    var delta = this._mouseCurPos.clone();
    delta.sub(this._mousePrevPos);
    this._affectedObj.translate(delta);
    this.dispatchEvent({ type: 'change' });
  };
  // set uniform object scale
  ObjectControls.prototype.setScale = function (scale) {
    this.object.scale.set(scale, scale, scale);
  };
  // scale object by factor
  ObjectControls.prototype.scale = function (factor) {
    this.setScale(this.object.scale.x * factor);
  };
  ObjectControls.prototype.update = function () {
    var curTime = this._clock.getElapsedTime();
    var timeSinceLastUpdate = curTime - this._lastUpdateTime;
    // update object handler
    if (this._state === STATE.NONE) {
      var timeSinceMove = curTime - this._lastMouseMoveTime;
      if (this._mainObj.update(timeSinceLastUpdate, timeSinceMove) || this._altObj.update(timeSinceLastUpdate, timeSinceMove)) {
        this.dispatchEvent({ type: 'change' });
      }
    }
    // apply arrow keys
    if (settings.now.panning) {
      var speedX = Number(this._pressedKeys[VK_RIGHT]) - Number(this._pressedKeys[VK_LEFT]);
      var speedY = Number(this._pressedKeys[VK_UP]) - Number(this._pressedKeys[VK_DOWN]);
      if (speedX !== 0 || speedY !== 0) {
        var delta = timeSinceLastUpdate;
        if (this._isKeysTranslatingObj) {
          // update object translation
          var altObj = this.getAltObj();
          if (altObj.objects.length > 0) {
            this._altObj.setObjects(altObj.objects);
            this._altObj.pivot = altObj.pivot;
            if ('axis' in altObj) {
              this._altObj.axis = altObj.axis.clone();
            } else {
              this._altObj.axis.set(0, 0, 1);
            }
            this._altObj.translate(new THREE.Vector2(delta * speedX, delta * speedY));
            this.dispatchEvent({ type: 'change' });
          }
        } else {
          // update camera panning
          delta *= PAN_SPEED * (settings.now.inversePanning ? -1 : 1);
          this.camera.translateX(delta * speedX);
          this.camera.translateY(delta * speedY);
          this.dispatchEvent({ type: 'change' });
        }
      }
    }
    this._lastUpdateTime = curTime;
  };
  ObjectControls.prototype.reset = function () {
    this._state = STATE.NONE;
    this.object.quaternion.copy(new THREE.Quaternion(0, 0, 0, 1));
  };
  // listeners
  ObjectControls.prototype.mousedown = function (event) {
    if (this.enabled === false || this._state !== STATE.NONE) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    if (this._state === STATE.NONE) {
      if (event.button === 0) {
        this._affectedObj.stop();
        // can edit only one object at a time
        var workWithAltObj = false;
        if (event.altKey) {
          var altObj = this.getAltObj();
          workWithAltObj = altObj.objects.length > 0;
          if (workWithAltObj) {
            this._altObj.setObjects(altObj.objects);
            this._altObj.pivot = altObj.pivot;
            if ('axis' in altObj) {
              this._altObj.axis = altObj.axis.clone();
            } else {
              this._altObj.axis.set(0, 0, 1);
            }
          }
        }
        this._affectedObj = workWithAltObj ? this._altObj : this._mainObj;
        this._state = workWithAltObj && event.ctrlKey && this._isTranslationAllowed ? STATE.TRANSLATE : STATE.ROTATE;
      }
    }
    if (this._state === STATE.ROTATE) {
      this._mouseCurPos.copy(this.getMouseOnCircle(event.pageX, event.pageY));
      this._mousePrevPos.copy(this._mouseCurPos);
    }
    if (this._state === STATE.TRANSLATE) {
      this._mouseCurPos.copy(this.getMouseViewport(event.pageX, event.pageY));
      this._mousePrevPos.copy(this._mouseCurPos);
    }
  };
  ObjectControls.prototype.mousemove = function (event) {
    if (this.enabled === false || this._state === STATE.NONE) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    switch (this._state) {
    case STATE.ROTATE:
      this._mousePrevPos.copy(this._mouseCurPos);
      this._mouseCurPos.copy(this.getMouseOnCircle(event.pageX, event.pageY));
      this.rotate(event.altKey && !this._isAltObjFreeRotationAllowed || event.shiftKey);
      this._lastMouseMoveTime = this._clock.getElapsedTime();
      break;
    case STATE.TRANSLATE:
      this._mousePrevPos.copy(this._mouseCurPos);
      this._mouseCurPos.copy(this.getMouseViewport(event.pageX, event.pageY));
      this.translate();
      break;
    default:
      break;
    }
  };
  ObjectControls.prototype.mousewheel = function (event) {
    if (this.enabled === false || !settings.now.zooming || this._state !== STATE.NONE) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    var delta = 0;
    if (event.wheelDelta) {
      // WebKit / Opera / Explorer 9
      delta = event.wheelDelta / 40;
    } else if (event.detail) {
      // Firefox
      delta = -event.detail / 3;
    }
    this.scale(1 + delta * 0.05);
    this.dispatchEvent({ type: 'change' });
  };
  ObjectControls.prototype.mouseup = function (event) {
    if (this.enabled === false || this._state === STATE.NONE) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    this._state = STATE.NONE;
    if (this._clock.getElapsedTime() - this._lastMouseMoveTime > FULL_STOP_THRESHOLD) {
      this._affectedObj.stop();
    }
  };
  ObjectControls.prototype.touchstartend = function (event) {
    if (this.enabled === false) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    switch (event.touches.length) {
    case 1:
      this._state = STATE.ROTATE;
      this._mouseCurPos.copy(this.getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
      this._mousePrevPos.copy(this._mouseCurPos);
      break;
    case 2:
      // prevent inertial rotation
      this._mainObj.stop();
      this._altObj.stop();
      this._state = STATE.SCALE_PAN;
      var dx = event.touches[0].pageX - event.touches[1].pageX;
      var dy = event.touches[0].pageY - event.touches[1].pageY;
      this._touchDistanceCur = this._touchDistanceStart = Math.sqrt(dx * dx + dy * dy);
      this._scaleStart = this.object.scale.x;
      this._originalPinchCenter = new THREE.Vector2(0.5 * (event.touches[0].pageX + event.touches[1].pageX), 0.5 * (event.touches[0].pageY + event.touches[1].pageY));
      this._originalCameraPos.copy(this.camera.position);
      break;
    default:
      this._state = STATE.NONE;
    }
  };
  ObjectControls.prototype.touchmove = function (event) {
    if (this.enabled === false || this._state === STATE.NONE) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    switch (this._state) {
    case STATE.ROTATE:
      this._mousePrevPos.copy(this._mouseCurPos);
      this._mouseCurPos.copy(this.getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
      this.rotate(false);
      this._lastMouseMoveTime = this._clock.getElapsedTime();
      break;
    case STATE.SCALE_PAN:
      if (settings.now.zooming) {
        // update scale
        var dx = event.touches[0].pageX - event.touches[1].pageX;
        var dy = event.touches[0].pageY - event.touches[1].pageY;
        this._touchDistanceCur = Math.sqrt(dx * dx + dy * dy);
        this.setScale(this._scaleStart * this._touchDistanceCur / this._touchDistanceStart);
      }
      if (settings.now.panning) {
        // update camera panning
        var delta = new THREE.Vector2(0.5 * (event.touches[0].pageX + event.touches[1].pageX), 0.5 * (event.touches[0].pageY + event.touches[1].pageY));
        delta.sub(this._originalPinchCenter);
        this.camera.position.x = this._originalCameraPos.x - PINCH_PAN_COEF * delta.x;
        this.camera.position.y = this._originalCameraPos.y + PINCH_PAN_COEF * delta.y;
      }
      if (settings.now.zooming || settings.now.panning) {
        this.dispatchEvent({ type: 'change' });
      }
      break;
    default:
    }
  };
  ObjectControls.prototype.keydownup = function (event) {
    if (this.enabled === false) {
      return;
    }
    switch (event.keyCode) {
    case VK_LEFT:
    case VK_UP:
    case VK_RIGHT:
    case VK_DOWN:
      this._pressedKeys[event.keyCode] = event.type === 'keydown';
      event.preventDefault();
      event.stopPropagation();
      break;
    default:
    }
  };
  ObjectControls.prototype.getKeyBindObject = function () {
    return window.top;
  };
  ObjectControls.prototype.dispose = function () {
    for (var i = 0; i < this._listeners.length; i++) {
      var l = this._listeners[i];
      l.obj.removeEventListener(l.type, l.handler);
    }
  };
  return ObjectControls;
}(three, utils, settings);
ui_Picker = function (THREE, utils) {
  function Picker(gfxObj, camera, domElement) {
    var self = this;
    this.gfxObj = gfxObj;
    this.camera = camera;
    this.domElement = typeof domElement !== 'undefined' ? domElement : document;
    this.screen = {
      left: 0,
      top: 0,
      width: 0,
      height: 0
    };
    this._lastMousePos = new THREE.Vector2(0, 0);
    this._mouseTotalDist = 0;
    this._lastClickBeginTime = -1000;
    this._lastClickPos = new THREE.Vector2(0, 0);
    this._clickBeginTime = 0;
    this._clock = new utils.Timer();
    this._clock.start();
    this._listeners = [
      {
        obj: self.domElement,
        type: 'mousedown',
        handler: function (e) {
          self.mousedown(e);
        }
      },
      {
        obj: self.domElement,
        type: 'mouseup',
        handler: function (e) {
          self.mouseup(e);
        }
      },
      {
        obj: self.domElement,
        type: 'mousemove',
        handler: function (e) {
          self.mousemove(e);
        }
      },
      {
        obj: self.domElement,
        type: 'touchstart',
        handler: function (e) {
          self.touchstart(e);
        }
      },
      {
        obj: self.domElement,
        type: 'touchend',
        handler: function (e) {
          self.touchend(e);
        }
      },
      {
        obj: window,
        type: 'resize',
        handler: function () {
          self.handleResize();
        }
      }
    ];
    for (var i = 0; i < this._listeners.length; i++) {
      var l = this._listeners[i];
      l.obj.addEventListener(l.type, l.handler);
    }
    this.handleResize();
  }
  Picker.prototype = Object.create(THREE.EventDispatcher.prototype);
  Picker.prototype.constructor = Picker;
  Picker.prototype.reset = function () {
    this.picked = {};
    this.dispatchEvent({
      type: 'newpick',
      obj: {}
    });
  };
  Picker.prototype.handleResize = function () {
    if (this.domElement === document) {
      this.screen.left = 0;
      this.screen.top = 0;
      this.screen.width = window.innerWidth;
      this.screen.height = window.innerHeight;
    } else {
      var box = this.domElement.getBoundingClientRect();
      // adjustments come from similar code in the jquery offset() function
      var d = this.domElement.ownerDocument.documentElement;
      this.screen.left = box.left + window.pageXOffset - d.clientLeft;
      this.screen.top = box.top + window.pageYOffset - d.clientTop;
      this.screen.width = box.width;
      this.screen.height = box.height;
    }
  };
  Picker.prototype.pickObject = function (screenPos) {
    var picked = {};
    var gfxObj = this.gfxObj;
    var intersects;
    if (gfxObj) {
      var rayCaster = new THREE.Raycaster();
      rayCaster.setFromCamera(screenPos, this.camera);
      intersects = rayCaster.intersectObject(gfxObj, false);
      if (intersects.length > 0) {
        if (intersects[0].hasOwnProperty('residue')) {
          picked = { residue: intersects[0].residue };
        }
        if (intersects[0].hasOwnProperty('atom')) {
          picked = { atom: intersects[0].atom };
        }
      }
    }
    this.picked = picked;
    this.dispatchEvent({
      type: 'newpick',
      obj: picked
    });
  };
  Picker.prototype.getMouseInViewport = function (pageX, pageY) {
    return new THREE.Vector2((pageX - this.screen.left) / this.screen.width * 2 - 1, -(pageY - this.screen.top) / this.screen.height * 2 + 1);
  };
  Picker.prototype.mousedown = function (event) {
    event.preventDefault();
    event.stopPropagation();
    if (event.button === 0) {
      this._lastMousePos = this.getMouseInViewport(event.pageX, event.pageY);
      this._mouseTotalDist = 0;
      this._clickBeginTime = this._clock.getElapsedTime();
    }
  };
  Picker.prototype.mousemove = function (event) {
    event.preventDefault();
    event.stopPropagation();
    var pos = this.getMouseInViewport(event.pageX, event.pageY);
    this._mouseTotalDist += pos.sub(this._lastMousePos).length();
  };
  Picker.prototype.mouseup = function (event) {
    var self = this;
    event.preventDefault();
    event.stopPropagation();
    if (event.button === 0) {
      if (this._mouseTotalDist < 0.01) {
        var curTime = this._clock.getElapsedTime();
        var curPos = this.getMouseInViewport(event.pageX, event.pageY);
        var timeSinceLastClickBegin = curTime - this._lastClickBeginTime;
        if (timeSinceLastClickBegin < 0.7) {
          var clickDist = new THREE.Vector2().subVectors(curPos, this._lastClickPos);
          if (clickDist.length() < 0.01) {
            // it's a double click
            this.dispatchEvent({
              type: 'dblclick',
              obj: this.picked
            });
            this._lastClickPos = curPos;
            this._lastClickBeginTime = -1000;
            // this click cannot serve as first click in double-click
            return;
          }
        }
        setTimeout(function () {
          self.pickObject(curPos);
        }, 0);
        this._lastClickPos = curPos;
        this._lastClickBeginTime = this._clickBeginTime;
      }
    }
  };
  Picker.prototype.touchstart = function (event) {
    event.preventDefault();
    event.stopPropagation();
    if (event.touches.length === 1) {
      this._lastTouchdownPos = this.getMouseInViewport(event.touches[0].pageX, event.touches[0].pageY);
    }
  };
  Picker.prototype.touchend = function (event) {
    var self = this;
    event.preventDefault();
    event.stopPropagation();
    if (event.touches.length === 0 && event.changedTouches.length === 1) {
      var pos = this.getMouseInViewport(event.changedTouches[0].pageX, event.changedTouches[0].pageY);
      var dist = pos.sub(this._lastTouchdownPos).length();
      if (dist < 0.01) {
        setTimeout(function () {
          self.pickObject(self._lastTouchdownPos);
        }, 0);
      }
    }
  };
  Picker.prototype.dispose = function () {
    for (var i = 0; i < this._listeners.length; i++) {
      var l = this._listeners[i];
      l.obj.removeEventListener(l.type, l.handler);
    }
  };
  return Picker;
}(three, utils);
gfx_Axes = function (THREE, settings) {
  function Axes(target, targetCamera) {
    this._target = target;
    this._targetCamera = targetCamera;
    this._camera = new THREE.PerspectiveCamera(targetCamera.fov, targetCamera.aspect, 1, 100);
    this._object = new THREE.AxisHelper(1);
    this._scene = new THREE.Scene();
    this._scene.add(this._object);
    this.update();
  }
  Axes.prototype.update = function () {
    var fov = settings.now.camFov;
    var camera = this._camera;
    camera.aspect = this._targetCamera.aspect;
    camera.setMinimalFov(fov);
    camera.setDistanceToFit(1, fov);
    camera.updateProjectionMatrix();
    this._object.quaternion.copy(this._target.quaternion);
  };
  Axes.prototype.render = function (renderer) {
    var full = renderer.getSize();
    var width = full.width * 0.25;
    var height = full.height * 0.25;
    var autoClear = renderer.autoClear;
    renderer.autoClear = false;
    renderer.setViewport(0, 0, width, height);
    renderer.clear(false, true, false);
    renderer.render(this._scene, this._camera);
    renderer.setViewport(0, 0, full.width, full.height);
    renderer.autoClear = autoClear;
  };
  return Axes;
}(three, settings);
gfx_shaders_Outline = function (THREE) {
  var defaultUniforms = THREE.UniformsUtils.merge([{
      srcTex: {
        type: 't',
        value: null
      },
      srcTexSize: {
        type: 'v2',
        value: new THREE.Vector2(512, 512)
      },
      opacity: {
        type: 'f',
        value: 1
      }
    }]);
  var vertexShader = [
    'varying vec2 vUv;',
    'void main() {',
    '  vUv = uv;',
    '  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
    '}'
  ].join('\n');
  var fragmentShader = [
    'uniform sampler2D srcTex;',
    'uniform vec2 srcTexSize;',
    'varying vec2 vUv;',
    'void main() {',
    '  vec2 pixelSize = vec2(1, 1) / srcTexSize;',
    '  vec4 c00 = texture2D(srcTex, vUv + vec2(-pixelSize.x,-pixelSize.y));',
    '  vec4 c01 = texture2D(srcTex, vUv + vec2(0,-pixelSize.y));',
    '  vec4 c02 = texture2D(srcTex, vUv + vec2(pixelSize.x,-pixelSize.y));',
    '  vec4 c10 = texture2D(srcTex, vUv + vec2(-pixelSize.x,0));',
    '  vec4 c12 = texture2D(srcTex, vUv + vec2(pixelSize.x,0));',
    '  vec4 c20 = texture2D(srcTex, vUv + vec2(-pixelSize.x,pixelSize.y));',
    '  vec4 c21 = texture2D(srcTex, vUv + vec2(0,pixelSize.y));',
    '  vec4 c22 = texture2D(srcTex, vUv + vec2(pixelSize.x,pixelSize.y));',
    '  vec4 horizEdge = - c00 - 2.0 * c01 - c02 + c20 + 2.0 * c21 + c22;',
    '  vec4 vertEdge  = - c00 - 2.0 * c10 - c20 + c02 + 2.0 * c12 + c22;',
    '  vec4 grad = sqrt(horizEdge * horizEdge + vertEdge * vertEdge);',
    '  gl_FragColor = grad;',
    '}'
  ].join('\n');
  function overrideUniforms(params) {
    var uniforms = THREE.UniformsUtils.clone(defaultUniforms);
    for (var p in params) {
      if (uniforms.hasOwnProperty(p)) {
        uniforms[p].value = params[p];
      }
    }
    return uniforms;
  }
  function createOutlineMaterial(params) {
    var settings = {
      uniforms: overrideUniforms(params),
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      transparent: true,
      depthTest: false,
      depthWrite: false
    };
    return new THREE.ShaderMaterial(settings);
  }
  return createOutlineMaterial;
}(three);
gfx_shaders_FXAA = function (THREE) {
  var defaultUniforms = THREE.UniformsUtils.merge([{
      srcTex: {
        type: 't',
        value: null
      },
      srcTexelSize: {
        type: 'v2',
        value: new THREE.Vector2(1 / 512, 1 / 512)
      }
    }]);
  var vertexShader = [
    'varying vec2 vUv;',
    'void main() {',
    '  vUv = uv;',
    '  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
    '}'
  ].join('\n');
  var fragmentShader = [
    /*'#define FXAA_QUALITY_P0 1.0',
    '#define FXAA_QUALITY_P1 1.5',
    '#define FXAA_QUALITY_P2 2.0',
    '#define FXAA_QUALITY_P3 4.0',
    '#define FXAA_QUALITY_P4 12.0',
    '#define FXAA_QUALITY_PS 5',*/
    // edge end finding algorithm parameters
    '#define FXAA_QUALITY_PS 8',
    '#define FXAA_QUALITY_P0 1.0',
    '#define FXAA_QUALITY_P1 1.5',
    '#define FXAA_QUALITY_P2 2.0',
    '#define FXAA_QUALITY_P3 2.0',
    '#define FXAA_QUALITY_P4 2.0',
    '#define FXAA_QUALITY_P5 2.0',
    '#define FXAA_QUALITY_P6 4.0',
    '#define FXAA_QUALITY_P7 12.0',
    // constants
    'float fxaaQualityEdgeThreshold = 0.125;',
    'float fxaaQualityEdgeThresholdMin = 0.0625;',
    'float fxaaQualitySubpix = 0.7;',
    //0.65;',
    // global params
    'uniform sampler2D srcTex;',
    'uniform vec2 srcTexelSize;',
    // from vs
    'varying vec2 vUv;',
    //=====================================================================//
    // calc luminance from rgb
    //'float FxaaLuma(vec3 rgb) {return rgb.y * (0.587/0.299) + rgb.x; }', // Lotte's idea about game luminance
    'float FxaaLuma(vec3 rgb) {return dot(rgb, vec3(0.299, 0.587, 0.114)); }',
    // real luminance calculation
    // for non-real scene rendering
    // texture sampling by pixel position(coords) and offset(in pixels)
    'vec3 FxaaTex(sampler2D tex, vec2 pos, vec2 off,  vec2 res ) {return texture2D( tex, pos + off * res ).xyz;}',
    'vec3 FxaaTexTop(sampler2D tex, vec2 pos) {return texture2D( tex, pos).xyz;}',
    //=====================================================================//
    'void main() {',
    // renaming
    '  vec2 posM = vUv;',
    // get luminance for neighbours
    '  float lumaS = FxaaLuma(FxaaTex(srcTex, posM, vec2( 0.0, 1.0 ), srcTexelSize));',
    '  float lumaE = FxaaLuma(FxaaTex(srcTex, posM, vec2( 1.0, 0.0 ), srcTexelSize));',
    '  float lumaN = FxaaLuma(FxaaTex(srcTex, posM, vec2( 0.0, -1.0 ), srcTexelSize));',
    '  float lumaW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0, 0.0 ), srcTexelSize));',
    '  float lumaM = FxaaLuma(FxaaTexTop(srcTex, posM));',
    // find max and min luminance
    '  float rangeMax = max(max(lumaN, lumaW), max(lumaE, max(lumaS, lumaM)));',
    '  float rangeMin = min(min(lumaN, lumaW), min(lumaE, min(lumaS, lumaM)));',
    // calc maximum non-edge range
    '  float rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;',
    '  float range = rangeMax - rangeMin;',
    '  float rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);',
    // exit when luma contrast is small (is not edge)
    '  if(range < rangeMaxClamped){',
    '    gl_FragColor = vec4(FxaaTexTop(srcTex, posM).xyz, 1.0);',
    '    return;',
    '  }',
    '  float subpixRcpRange = 1.0/range;',
    // calc other neighbours luminance
    '  float lumaNE = FxaaLuma(FxaaTex(srcTex, posM, vec2(  1.0, -1.0 ), srcTexelSize));',
    '  float lumaSW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0,  1.0 ), srcTexelSize));',
    '  float lumaSE = FxaaLuma(FxaaTex(srcTex, posM, vec2(  1.0,  1.0 ), srcTexelSize));',
    '  float lumaNW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0, -1.0 ), srcTexelSize));',
    /*--------------span calculation and subpix amount calulation-----------------*/
    '  float lumaNS = lumaN + lumaS;',
    '  float lumaWE = lumaW + lumaE;',
    '  float subpixNSWE = lumaNS + lumaWE;',
    '  float edgeHorz1 = (-2.0 * lumaM) + lumaNS;',
    '  float edgeVert1 = (-2.0 * lumaM) + lumaWE;',
    /*--------------------------------------------------------------------------*/
    '  float lumaNESE = lumaNE + lumaSE;',
    '  float lumaNWNE = lumaNW + lumaNE;',
    '  float edgeHorz2 = (-2.0 * lumaE) + lumaNESE;',
    '  float edgeVert2 = (-2.0 * lumaN) + lumaNWNE;',
    /*--------------------------------------------------------------------------*/
    '  float lumaNWSW = lumaNW + lumaSW;',
    '  float lumaSWSE = lumaSW + lumaSE;',
    '  float edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);',
    '  float edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);',
    '  float edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;',
    '  float edgeVert3 = (-2.0 * lumaS) + lumaSWSE;',
    '  float edgeHorz = abs(edgeHorz3) + edgeHorz4;',
    '  float edgeVert = abs(edgeVert3) + edgeVert4;',
    /*--------------------subpix amount calulation------------------------------*/
    '  float subpixNWSWNESE = lumaNWSW + lumaNESE;',
    '  float lengthSign = srcTexelSize.x;',
    '  bool horzSpan = edgeHorz >= edgeVert;',
    // debug  code edge span visualization
    /*'  if (horzSpan)',
    '      gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);',
    '  else',
    '    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);',
    '  return;',*/
    '  float subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;',
    /*--------------------------------------------------------------------------*/
    '  if(!horzSpan) lumaN = lumaW;',
    '  if(!horzSpan) lumaS = lumaE;',
    '  if(horzSpan) lengthSign = srcTexelSize.y;',
    '  float subpixB = (subpixA * (1.0/12.0)) - lumaM;',
    /*--------------------------------------------------------------------------*/
    '  float gradientN = lumaN - lumaM;',
    '  float gradientS = lumaS - lumaM;',
    '  float lumaNN = lumaN + lumaM;',
    '  float lumaSS = lumaS + lumaM;',
    '  bool pairN = abs(gradientN) >= abs(gradientS);',
    '  float gradient = max(abs(gradientN), abs(gradientS));',
    '  if(pairN) lengthSign = -lengthSign;',
    '  float subpixC = clamp(abs(subpixB) * subpixRcpRange, 0.0, 1.0);',
    /*--------------------------------------------------------------------------*/
    '  vec2 posB;',
    '  posB = posM;',
    '  vec2 offNP;',
    '  offNP.x = (!horzSpan) ? 0.0 : srcTexelSize.x;',
    '  offNP.y = ( horzSpan) ? 0.0 : srcTexelSize.y;',
    '  if(!horzSpan) posB.x += lengthSign * 0.5;',
    '  if( horzSpan) posB.y += lengthSign * 0.5;',
    /*--------------------------------------------------------------------------*/
    '  vec2 posN;',
    '  posN = posB - offNP * FXAA_QUALITY_P0;',
    '  vec2 posP;',
    '  posP = posB + offNP * FXAA_QUALITY_P0;',
    '  float subpixD = ((-2.0)*subpixC) + 3.0;',
    '  float lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN));',
    '  float subpixE = subpixC * subpixC;',
    '  float lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP));',
    /*--------------------------------------------------------------------------*/
    '  if(!pairN) lumaNN = lumaSS;',
    '  float gradientScaled = gradient * 1.0/4.0;',
    '  float lumaMM = lumaM - lumaNN * 0.5;',
    '  float subpixF = subpixD * subpixE;',
    '  bool lumaMLTZero = lumaMM < 0.0;',
    /*---------------------looped edge-end search-------------------------------*/
    '  lumaEndN -= lumaNN * 0.5;',
    '  lumaEndP -= lumaNN * 0.5;',
    '  bool doneN = abs(lumaEndN) >= gradientScaled;',
    '  bool doneP = abs(lumaEndP) >= gradientScaled;',
    '  if(!doneN) posN -= offNP * FXAA_QUALITY_P1;',
    '  bool doneNP = (!doneN) || (!doneP);',
    '  if(!doneP) posP += offNP * FXAA_QUALITY_P1;',
    /*--------------------------------------------------------------------------*/
    '  if(doneNP) {',
    '    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));',
    '    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));',
    '    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;',
    '    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;',
    '    doneN = abs(lumaEndN) >= gradientScaled;',
    '    doneP = abs(lumaEndP) >= gradientScaled;',
    '    if(!doneN) posN -= offNP * FXAA_QUALITY_P2;',
    '    doneNP = (!doneN) || (!doneP);',
    '    if(!doneP) posP += offNP * FXAA_QUALITY_P2;',
    /*--------------------------------------------------------------------------*/
    '    #if (FXAA_QUALITY_PS > 3)',
    '      if(doneNP) {',
    '        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));',
    '        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));',
    '        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;',
    '        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;',
    '        doneN = abs(lumaEndN) >= gradientScaled;',
    '        doneP = abs(lumaEndP) >= gradientScaled;',
    '        if(!doneN) posN -= offNP * FXAA_QUALITY_P3;',
    '        doneNP = (!doneN) || (!doneP);',
    '        if(!doneP) posP += offNP * FXAA_QUALITY_P3;',
    /*--------------------------------------------------------------------------*/
    '        #if (FXAA_QUALITY_PS > 4)',
    '          if(doneNP) {',
    '            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));',
    '            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));',
    '            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;',
    '            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;',
    '            doneN = abs(lumaEndN) >= gradientScaled;',
    '            doneP = abs(lumaEndP) >= gradientScaled;',
    '            if(!doneN) posN -= offNP * FXAA_QUALITY_P4;',
    '            doneNP = (!doneN) || (!doneP);',
    '            if(!doneP) posP += offNP * FXAA_QUALITY_P4;',
    /*--------------------------------------------------------------------------*/
    '            #if (FXAA_QUALITY_PS > 5)',
    '               if(doneNP) {',
    '                 if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));',
    '                 if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));',
    '                 if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;',
    '                 if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;',
    '                 doneN = abs(lumaEndN) >= gradientScaled;',
    '                 doneP = abs(lumaEndP) >= gradientScaled;',
    '                 if(!doneN) posN -= offNP * FXAA_QUALITY_P5;',
    '                 doneNP = (!doneN) || (!doneP);',
    '                 if(!doneP) posP += offNP * FXAA_QUALITY_P5;',
    /*--------------------------------------------------------------------------*/
    '                 #if (FXAA_QUALITY_PS > 6)',
    '                   if(doneNP) {',
    '                     if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));',
    '                     if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));',
    '                     if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;',
    '                     if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;',
    '                     doneN = abs(lumaEndN) >= gradientScaled;',
    '                     doneP = abs(lumaEndP) >= gradientScaled;',
    '                     if(!doneN) posN -= offNP * FXAA_QUALITY_P6;',
    '                     doneNP = (!doneN) || (!doneP);',
    '                     if(!doneP) posP += offNP * FXAA_QUALITY_P6;',
    /*--------------------------------------------------------------------------*/
    '                     #if (FXAA_QUALITY_PS > 7)',
    '                       if(doneNP) {',
    '                         if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));',
    '                         if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));',
    '                         if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;',
    '                         if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;',
    '                         doneN = abs(lumaEndN) >= gradientScaled;',
    '                         doneP = abs(lumaEndP) >= gradientScaled;',
    '                         if(!doneN) posN -= offNP * FXAA_QUALITY_P7;',
    '                         doneNP = (!doneN) || (!doneP);',
    '                         if(!doneP) posP += offNP * FXAA_QUALITY_P7;',
    /*--------------------------------------------------------------------------*/
    '                       }',
    '                     #endif',
    '                   }',
    '                 #endif',
    '               }',
    '             #endif',
    '           }',
    '         #endif',
    '      }',
    '    #endif',
    '  }',
    /*----------------calculate subpix offset due to edge ends-------------------*/
    '  float dstN = posM.x - posN.x;',
    '  float dstP = posP.x - posM.x;',
    '  if(!horzSpan) dstN = posM.y - posN.y;',
    '  if(!horzSpan) dstP = posP.y - posM.y;',
    /*--------------------------------------------------------------------------*/
    '  bool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;',
    '  float spanLength = (dstP + dstN);',
    '  bool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;',
    '  float spanLengthRcp = 1.0/spanLength;',
    /*--------------------------------------------------------------------------*/
    '  bool directionN = dstN < dstP;',
    '  float dst = min(dstN, dstP);',
    '  bool goodSpan = directionN ? goodSpanN : goodSpanP;',
    '  float subpixG = subpixF * subpixF;',
    '  float pixelOffset = (dst * (-spanLengthRcp)) + 0.5;',
    '  float subpixH = subpixG * fxaaQualitySubpix;',
    /*-----------------calc texture offest using subpix-------------------------*/
    '  float pixelOffsetGood = goodSpan ? pixelOffset : 0.0;',
    '  float pixelOffsetSubpix = max(pixelOffsetGood, subpixH);',
    '  if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;',
    '  if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;',
    '  gl_FragColor = vec4(FxaaTexTop(srcTex, posM).xyz, 1.0);',
    '  return;',
    '}'
  ].join('\n');
  function overrideUniforms(params) {
    var uniforms = THREE.UniformsUtils.clone(defaultUniforms);
    for (var p in params) {
      if (uniforms.hasOwnProperty(p)) {
        uniforms[p].value = params[p];
      }
    }
    return uniforms;
  }
  function createFXAAMaterial(params) {
    var settings = {
      uniforms: overrideUniforms(params),
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      transparent: true,
      depthTest: false,
      depthWrite: false
    };
    return new THREE.ShaderMaterial(settings);
  }
  return createFXAAMaterial;
}(three);
Miew = function ($, THREE, dat, Spinner, Stats, utils, options, settings, selectors, Complex, GfxProfiler, io, modes, colorers, palettes, materials, Representation, CSS2DRenderer, Menu, ObjectControls, Picker, Axes, gfxutils, UberMaterial, OutlineMaterial, FXAAMaterial) {
  //////////////////////////////////////////////////////////////////////////////
  var NUM_REPRESENTATION_BITS = 32;
  var EDIT_MODE = {
    COMPLEX: 0,
    COMPONENT: 1,
    FRAGMENT: 2
  };
  var createElement = utils.createElement;
  function updateFogRange(fog, center, radius) {
    fog.near = Math.max(center - radius * settings.now.fogNearFactor, settings.now.camNear);
    fog.far = Math.min(center + radius * settings.now.fogFarFactor, settings.now.camFar);
  }
  function removeExtension(fileName) {
    var dot = fileName.lastIndexOf('.');
    if (dot >= 0) {
      fileName = fileName.substr(0, dot);
    }
    return fileName;
  }
  function removePresetStr(settingsString) {
    var presetPos = settingsString.indexOf('preset=');
    if (presetPos >= 0) {
      var endPos = settingsString.substr(presetPos).search(/[&#]/);
      endPos = endPos === -1 ? settingsString.length : endPos + presetPos + 1;
      var toDelStr = settingsString.substring(presetPos, endPos);
      settingsString = settingsString.replace(toDelStr, '');
    }
    return settingsString;
  }
  /** @param {THREE.Object3D} object - Parent object. */
  function removeChildren(object) {
    var children = object.children;
    for (var i = 0, n = children.length; i < n; ++i) {
      var child = children[i];
      child.parent = null;
      child.dispatchEvent({ type: 'removed' });
    }
    object.children = [];
  }
  function clearTree(object) {
    object.traverse(function (obj) {
      if (obj instanceof THREE.Mesh) {
        obj.geometry.dispose();
      }
    });
    removeChildren(object);
  }
  function repToString(repList, startIdx) {
    startIdx = startIdx === undefined ? 0 : startIdx;
    var repString = [];
    var nDef = repList.length;
    var i = startIdx;
    for (; i < nDef; ++i) {
      var currPr = repList[i];
      repString.push('s=' + String(currPr.selector).replace(/ /g, '+'));
      repString.push('m=' + currPr.mode.shortId);
      repString.push('c=' + currPr.colorer.shortId);
      repString.push('mt=' + currPr.materialPreset.shortId);
    }
    return repString;
  }
  function comparePresetWithDefaults(preset, repList) {
    var repString = [];
    // ensure that preset length is less or equal to the repList length
    var i = 0;
    var n = preset.length;
    for (; i < n; i++) {
      var defPres = preset[i];
      var currPres = repList[i];
      var currStr = [];
      var selStr = String(currPres.selector);
      if (selStr.valueOf() !== String(defPres.selector).valueOf()) {
        currStr.push('s=' + selStr.replace(/ /g, '+'));
      }
      if (currPres.mode.id !== defPres.mode) {
        currStr.push('m=' + currPres.mode.shortId);
      }
      if (currPres.colorer.id !== defPres.colorer) {
        currStr.push('c=' + currPres.colorer.shortId);
      }
      if (currPres.materialPreset.id !== defPres.material) {
        currStr.push('mt=' + currPres.materialPreset.shortId);
      }
      if (currStr.length === 0) {
        continue;
      }
      repString.push('r=' + i);
      repString = repString.concat(currStr);
    }
    var nDef = repList.length;
    if (i === nDef) {
      return repString;
    }
    // 'close' previous representations
    repString.push('r=' + i);
    return repString.concat(repToString(repList, i));
  }
  function generatePresetString(repList) {
    var currPreset = settings.defaults.presets[settings.now.preset];
    if (currPreset !== undefined && currPreset.length <= repList.length) {
      var str = ['preset=' + settings.now.preset];
      return str.concat(comparePresetWithDefaults(currPreset, repList));
    }
    return repToString(repList, 0);
  }
  function hasValidResidues(complex) {
    var hasValidRes = false;
    complex.forEachComponent(function (component) {
      component.forEachResidue(function (residue) {
        if (residue._isValid) {
          hasValidRes = true;
        }
      });
    });
    return hasValidRes;
  }
  //////////////////////////////////////////////////////////////////////////////
  /**
   * Main 3D Molecular Viewer class.
   *
   * @param {object} opts - Viewer options.
   * @param {HTMLElement=} opts.container - DOM element that serves as a viewer container.
   * @param {HTMLElement=} opts.iframe - parent IFRAME element if any.
   * @param {object=} opts.settings - An object with properties to override default settings.
   *
   * @exports Miew
   * @constructor
   */
  function Miew(opts) {
    this._opts = $.extend(true, {}, opts);
    /** @type {?object} */
    this._gfx = null;
    /** @type {HTMLElement} */
    this._container = opts && opts.container || document.body;
    /** @type {HTMLElement} */
    this._containerRoot = this._container;
    /** @type {?Menu} */
    this._menu = null;
    this._menuDisabled = opts && opts.menu === false;
    // FIXME: temporary for 2016/05/13
    /** @type {boolean} */
    this._running = false;
    /** @type {boolean} */
    this._halting = false;
    /** @type {boolean} */
    this._building = false;
    /** @type {boolean} */
    this._needRender = true;
    if (opts && opts.settings) {
      settings.override(opts.settings);
    }
    /** @type {?Spinner} */
    this._spinner = null;
    /** @type {?Loader} */
    this._loader = null;
    /** @type {?Parser} */
    this._parser = null;
    /** @type {?Complex} */
    this._complex = null;
    /** @type {Representation[]} */
    this._reprList = [];
    /** @type {?Representation} */
    this._repr = null;
    /** @type {object} */
    this._iframe = opts.iframe;
    /** @type {object} */
    this._sourceWindow = null;
    this.reset();
    if (window.addEventListener) {
      window.addEventListener('message', Miew.prototype.messageListener.bind(this), false);
    } else {
      window.attachEvent('onmessage', Miew.prototype.messageListener.bind(this));
    }
    if (DEBUG) {
      console.log('DEBUG: Selected ' + this._repr.mode.name + ' mode with ' + this._repr.colorer.name + ' colorer.');
    }
    // notify parent IFRAME
    if (this._iframe) {
      var doc = this._iframe.ownerDocument;
      var win = doc.defaultView || doc.parentWindow;
      win.postMessage('miewLoadComplete', doc.location.origin);
    }
  }
  Miew.prototype = Object.create(THREE.EventDispatcher.prototype);
  Miew.prototype.constructor = Miew;
  Miew.prototype.getMaxRepresentationCount = function () {
    return NUM_REPRESENTATION_BITS - 1;
  };
  /**
   * Initialize the viewer.
   * @returns {boolean} true on success.
   * @throws Forwards exception raised during initialization.
   * @see Miew#term
   */
  Miew.prototype.init = function () {
    var container = this._container;
    var elem = utils.createElement('div', { 'class': 'miew-canvas' });
    this._setContainerContents(elem);
    this._container = elem;
    var frag = document.createDocumentFragment();
    frag.appendChild(this._msgBottom = createElement('div', { 'class': 'bottom-message overlay' }, createElement('div', null, createElement('p'))));
    frag.appendChild(this._msgMode = createElement('div', { 'class': 'mode-message overlay' }, createElement('p', {}, 'COMPONENT EDIT MODE')));
    frag.appendChild(this._msgAtomInfo = createElement('div', { 'class': 'atom-info overlay' }, createElement('p', {}, '')));
    container.appendChild(frag);
    if (this._gfx !== null) {
      //block double init
      return true;
    }
    var self = this;
    this._showMessage('Viewer is being initialized...');
    try {
      this._initGfx();
      if (!this._menuDisabled) {
        this._menu = new Menu(this);
        this._menu.showOverlay();
      }
      this._initListeners();
      this._spinner = new Spinner({
        lines: 13,
        length: 28,
        width: 14,
        radius: 42,
        color: '#fff'
      });
      // this._initGui();
      window.top.addEventListener('keydown', function (event) {
        self._onKeyDown(event);
      });
      window.top.addEventListener('keyup', function (event) {
        self._onKeyUp(event);
      });
      this._objectControls = new ObjectControls(this._gfx.root, this._gfx.camera, this._gfx.renderer.domElement, function () {
        return self.getAltObj();
      });
      this._objectControls.addEventListener('change', function () {
        self._needRender = true;
      });
      var gfx = this._gfx;
      this._picker = new Picker(gfx.root, gfx.camera, gfx.renderer.domElement);
      this._picker.addEventListener('newpick', function (event) {
        self._onPick(event);
      });
      this._picker.addEventListener('dblclick', function (event) {
        self._onDblClick(event);
      });
      this._onThemeChanged();
    } catch (error) {
      // FIXME: THREE.WebGLRenderer throws error AND catches it, so we receive different one. Some random crash.
      if (error.name === 'TypeError' && error.message === 'Cannot read property \'getExtension\' of null') {
        this._showMessage('Could not create WebGL context.');
      } else {
        this._showMessage('Viewer initialization failed.');
        throw error;
      }
      return false;
    }
    // automatically load default file
    var file = this._opts && this._opts.load;
    if (file) {
      var type = this._opts && this._opts.type;
      this.load(file, { fileType: type });
    }
    return true;
  };
  /**
   * Terminate the viewer completely.
   * @see Miew#init
   */
  Miew.prototype.term = function () {
    this._showMessage('Viewer has been terminated.');
    if (this._loader) {
      this._loader.abort();
      this._loader = null;
    }
    if (this._parser) {
      this._parser.abort();
      this._parser = null;
    }
    this.halt();
    this._menu = null;
    this._gfx = null;
  };
  /**
   * Replace viewer container contents with a DOM element.
   * @param {HTMLElement} element - DOM element to show.
   * @private
   */
  Miew.prototype._setContainerContents = function (element) {
    var parent = this._container;
    while (parent.firstChild) {
      parent.removeChild(parent.firstChild);
    }
    parent.appendChild(element);
  };
  /**
   * Display message inside the viewer container, hiding WebGL canvas.
   * @param {string} msg - Message to show.
   * @private
   */
  Miew.prototype._showMessage = function (msg) {
    var element = document.createElement('div');
    element.setAttribute('class', 'miew-message');
    element.appendChild(document.createElement('p')).appendChild(document.createTextNode(msg));
    this._setContainerContents(element);
  };
  /**
   * Display WebGL canvas inside the viewer container, hiding any message shown.
   * @private
   */
  Miew.prototype._showCanvas = function () {
    this._setContainerContents(this._gfx.renderer.domElement);
  };
  Miew.prototype._initGui = function () {
    dat.GUI.TEXT_OPEN = 'Open debug controls';
    var gui = this._gui = new dat.GUI({});
    gui.closed = true;
    // note: add your debug params to settings.js (e.g. 'debug' object fields)
    // example field
    gui.add(settings.now.debug, 'example', 0, 5);
    gui.add(settings.now.debug, 'text');
    gui.add(settings.now.debug, 'good');
  };
  /**
   * Initialize WebGL and set 3D scene up.
   * @private
   */
  Miew.prototype._initGfx = function () {
    var gfx = {
      width: this._container.clientWidth,
      height: this._container.clientHeight
    };
    var webGLOptions = { preserveDrawingBuffer: true };
    if (settings.now.antialias) {
      webGLOptions.antialias = true;
    }
    gfx.renderer2d = new CSS2DRenderer();
    gfx.renderer = new THREE.WebGLRenderer(webGLOptions);
    // z-sprites
    if (!gfx.renderer.getContext().getExtension('EXT_frag_depth')) {
      settings.now.zSprites = false;
    }
    gfx.renderer.autoClear = false;
    gfx.renderer.setPixelRatio(window.devicePixelRatio);
    gfx.renderer.setSize(gfx.width, gfx.height);
    gfx.renderer.setClearColor(settings.now.themes[settings.now.theme]);
    gfx.renderer.clearColor();
    gfx.renderer2d.setSize(gfx.width, gfx.height);
    gfx.camera = new THREE.PerspectiveCamera(settings.now.camFov, gfx.width / gfx.height, settings.now.camNear, settings.now.camFar);
    gfx.camera.setMinimalFov(settings.now.camFov);
    gfx.camera.setDistanceToFit(1, settings.now.camFov);
    gfx.camera.updateProjectionMatrix();
    gfx.scene = new THREE.Scene();
    gfx.scene.fog = new THREE.Fog(settings.now.themes[settings.now.theme], settings.now.camNear, settings.now.camFar);
    gfx.root = new gfxutils.RCGroup();
    gfx.scene.add(gfx.root);
    gfx.pivot = new gfxutils.RCGroup();
    gfx.root.add(gfx.pivot);
    gfx.selectionScene = new THREE.Scene();
    gfx.selectionRoot = new THREE.Group();
    gfx.selectionRoot.matrixAutoUpdate = false;
    gfx.selectionScene.add(gfx.selectionRoot);
    gfx.selectionPivot = new THREE.Group();
    gfx.selectionPivot.matrixAutoUpdate = false;
    gfx.selectionRoot.add(gfx.selectionPivot);
    // TODO move this wonderful code
    var light1 = new THREE.DirectionalLight(16777215, 0.25);
    light1.position.set(0, 1, 1);
    gfx.scene.add(light1);
    var light2 = new THREE.DirectionalLight(16777215, 0.3);
    light2.position.set(0, 0, 1);
    gfx.scene.add(light2);
    var light3 = new THREE.AmbientLight(6710886);
    gfx.scene.add(light3);
    // add axes
    gfx.axes = new Axes(gfx.root, gfx.camera);
    gfx.offscreenBuf = new THREE.WebGLRenderTarget(gfx.width * window.devicePixelRatio, gfx.height * window.devicePixelRatio, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.NearestFilter,
      format: THREE.RGBAFormat
    });
    // N: needed for storing backbuffer before fxaa
    gfx.offscreenBuf2 = new THREE.WebGLRenderTarget(gfx.width * window.devicePixelRatio, gfx.height * window.devicePixelRatio, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat
    });
    this._gfx = gfx;
    this._showCanvas();
    // add FPS counter
    var stats = new Stats();
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.right = '0';
    stats.domElement.style.bottom = '0';
    this._container.appendChild(stats.domElement);
    this._fps = stats;
    this._fps.show(settings.now.fps);
    this._container.appendChild(gfx.renderer2d.getElement());
  };
  /**
   * Setup event listeners.
   * @private
   */
  Miew.prototype._initListeners = function () {
    var self = this;
    window.addEventListener('resize', function _onResize() {
      self._onResize();
    });
  };
  /**
   * Run the viewer, start processing update/render frames periodically.
   * Has no effect if already running.
   * @see Miew#halt
   */
  Miew.prototype.run = function () {
    if (!this._running) {
      this._running = true;
      if (this._halting) {
        this._halting = false;
        return;
      }
      this._objectControls.enable(true);
      var self = this;
      requestAnimationFrame(function _onAnimationFrame() {
        self._onTick();
      });
    }
  };
  /**
   * Request the viewer to stop.
   * Will be processed during the next frame.
   * @see Miew#run
   */
  Miew.prototype.halt = function () {
    if (this._running) {
      this._discardComponentEdit();
      this._discardFragmentEdit();
      this._objectControls.enable(false);
      this._halting = true;
    }
  };
  /**
   * Callback which processes window resize.
   * @private
   */
  Miew.prototype._onResize = function () {
    this._needRender = true;
    var gfx = this._gfx;
    gfx.width = this._container.clientWidth;
    gfx.height = this._container.clientHeight;
    gfx.camera.aspect = gfx.width / gfx.height;
    gfx.camera.setMinimalFov(settings.now.camFov);
    gfx.camera.updateProjectionMatrix();
    gfx.renderer.setSize(gfx.width, gfx.height);
    gfx.offscreenBuf.setSize(gfx.width * window.devicePixelRatio, gfx.height * window.devicePixelRatio);
    gfx.offscreenBuf2.setSize(gfx.width * window.devicePixelRatio, gfx.height * window.devicePixelRatio);
    gfx.renderer2d.setSize(gfx.width, gfx.height);
    if (this._menu) {
      this._menu._onResize();
    }
  };
  /**
   * Callback which processes update/render frames.
   * @private
   */
  Miew.prototype._onTick = function () {
    if (this._halting) {
      this._running = false;
      this._halting = false;
      return;
    }
    this._fps.update();
    var self = this;
    requestAnimationFrame(function _onAnimationFrame() {
      self._onTick();
    });
    this._onUpdate();
    if (this._needRender) {
      this._onRender();
      this._needRender = !settings.now.suspendRender;
    }
  };
  Miew.prototype._onUpdate = function () {
    this.updateBottomMessage();
    this._objectControls.update();
    var gfx = this._gfx;
    var radius = this._complex && this._complex.boundingSphere ? this._complex.boundingSphere.radius : 1;
    radius *= this._objectControls.object.scale.x;
    updateFogRange(gfx.scene.fog, gfx.camera.position.z, radius);
    if (!settings.now.fog) {
      gfx.scene.fog.near = gfx.scene.fog.far;
    }
    if (settings.now.axes && gfx.axes) {
      gfx.axes.update();
    }
    if (!this._loader && !this._parser && !this._building && this._needRebuild()) {
      this.rebuild();
    }
  };
  Miew.prototype._onRender = function () {
    var gfx = this._gfx;
    // update all matrices
    gfx.scene.updateMatrixWorld();
    // notify renderables
    for (var i = 0; i < gfx.pivot.children.length; ++i) {
      var g = gfx.pivot.children[i];
      if ('onBeforeRender' in g) {
        g.onBeforeRender(gfx.camera);
      }
    }
    // force-write UberMaterial option values to uniforms
    this.updateUniforms();
    // render to offscreen buffer
    gfx.renderer.setClearColor(settings.now.themes[settings.now.theme], 1);
    gfx.renderer.clearTarget(gfx.offscreenBuf2);
    gfx.renderer.clearTarget(gfx.offscreenBuf);
    gfx.renderer.render(gfx.scene, gfx.camera, gfx.offscreenBuf);
    // when fxaa we should get resulting image in temp off-screen buff2 for further postprocessing with fxaa filter
    // otherwise we render to canvas
    var renderTarget = settings.now.fxaa ? gfx.offscreenBuf2 : null;
    // copy offscreen buffer to screen
    gfx.renderer.renderScreenQuadFromTex(gfx.offscreenBuf, 1, renderTarget);
    // render selected part with outline material
    this.renderSelection(renderTarget);
    // process resulting image with fxaa if neeeded
    if (settings.now.fxaa) {
      this.performFXAA(gfx.offscreenBuf2, null);
    }
    gfx.renderer2d.render(gfx.scene, gfx.camera);
    if (settings.now.axes && gfx.axes) {
      gfx.axes.render(gfx.renderer);
    }
  };
  Miew.prototype._onThemeChanged = function () {
    var themeRE = /\s*theme-\w+\b/g;
    return function () {
      var theme = settings.now.theme;
      var div = this._containerRoot;
      div.className = div.className.replace(themeRE, '') + ' theme-' + theme;
      var gfx = this._gfx;
      if (gfx) {
        var color = settings.now.themes[theme];
        gfx.scene.fog.color.set(color);
        gfx.renderer.setClearColor(color);
      }
      if (this._spinner) {
        this._spinner.opts.color = theme === 'light' ? '#000' : '#fff';  // FIXME: move colors to the settings object
      }
    };
  }();
  Miew.prototype.updateUniforms = function () {
    this._gfx.root.traverse(function (obj) {
      if (obj instanceof THREE.Mesh && obj.material instanceof UberMaterial) {
        obj.material.updateUniforms();
      }
    });
  };
  Miew.prototype.renderSelection = function () {
    var _outlineMaterial = new OutlineMaterial();
    return function (renderTarget) {
      if (!this._complex) {
        return;
      }
      var self = this;
      var gfx = self._gfx;
      // clear offscreen buffer (leave z-buffer intact)
      gfx.renderer.setClearColor(THREE.black, 0);
      gfx.renderer.clearTarget(gfx.offscreenBuf, true, false, false);
      // render selection to offscreen buffer
      if (gfx.selectionPivot.children.length > 0) {
        gfx.selectionRoot.matrix = gfx.root.matrix;
        gfx.selectionPivot.matrix = gfx.pivot.matrix;
        gfx.renderer.render(gfx.selectionScene, gfx.camera, gfx.offscreenBuf);
      } else {
        // just render something to force "target clear" operation to finish
        gfx.renderer.renderDummyQuad(gfx.offscreenBuf);
      }
      // overlay to screen
      gfx.renderer.renderScreenQuadFromTex(gfx.offscreenBuf, 0.6, renderTarget);
      // apply Sobel filter -- draw outline
      _outlineMaterial.uniforms.srcTex.value = gfx.offscreenBuf;
      _outlineMaterial.uniforms.srcTexSize.value.set(gfx.offscreenBuf.width, gfx.offscreenBuf.height);
      gfx.renderer.renderScreenQuad(_outlineMaterial, renderTarget);
    };
  }();
  Miew.prototype.performFXAA = function () {
    var _fxaaMaterial = new FXAAMaterial();
    return function (srcBuffer, targetBuffer) {
      if (!this._complex) {
        return;
      }
      if (srcBuffer === 'undefined' || targetBuffer === 'undefined') {
        return;
      }
      var self = this;
      var gfx = self._gfx;
      // clear canvas
      gfx.renderer.setClearColor(settings.now.themes[settings.now.theme], 1);
      gfx.renderer.clearTarget(targetBuffer);
      // do fxaa processing of offscreen buff2
      _fxaaMaterial.uniforms.srcTex.value = srcBuffer;
      _fxaaMaterial.uniforms.srcTexelSize.value.set(1 / srcBuffer.width, 1 / srcBuffer.height);
      _fxaaMaterial.transparent = true;
      gfx.renderer.renderScreenQuad(_fxaaMaterial);
    };
  }();
  /**
   * Reset the viewer, unload molecules.
   * @param {boolean=} keepReps - Keep representations while resetting viewer state.
   */
  Miew.prototype.reset = function (keepReps) {
    if (this._picker) {
      this._picker.reset();
    }
    this._complex = null;
    this._setEditMode(EDIT_MODE.COMPLEX);
    if (!keepReps) {
      this.resetReps();
    }
    this._bottomMessageShowTime = 0;
    if (this._gfx) {
      clearTree(this._gfx.pivot);
      this._gfx.renderer2d.reset();
    }
  };
  Miew.prototype.resetView = function () {
    // reset controls
    if (this._picker) {
      this._picker.reset();
    }
    this._setEditMode(EDIT_MODE.COMPLEX);
    this._objectControls.reset();
    this._objectControls.allowTranslation(true);
    this._objectControls.allowAltObjFreeRotation(true);
    // reset transform
    this.resetPivot();
    this.resetPan();
    // reset visual
    if (this._complex) {
      this._complex.resetAtomMask(0);
    }
    this.resetReps();
    // this.rebuildAll(); // TODO: implicit rebuild is enough
    // reset selection
    this.updateSelectionMask({});
    this.rebuildSelectionGeometry();
  };
  /**
   * Load molecule asynchronously.
   * @param {string|File} file - Molecule file to load (e.g. PDB ID, URL or File object).
   * @param {object=} opts - Options.
   * @param {string=} opts.sourceType - Data source type (e.g. 'url', 'file').
   * @param {string=} opts.fileType - Data contents type (e.g. 'pdb', 'cml').
   */
  Miew.prototype.load = function (file, opts) {
    var self = this;
    self.dispatchEvent({ type: 'load' });
    if (this._loader) {
      this._loader.abort();
      this._loader = null;
    }
    if (this._parser) {
      this._parser.abort();
      this._parser = null;
    }
    opts = opts || {};
    // TODO: clone
    // convert PDB ID to URL
    if (!opts.fileType && typeof file === 'string' && file.match(/^[0-9A-Z]{4}$/i)) {
      file = 'http://files.rcsb.org/view/' + file + '.pdb';
      opts.sourceType = 'url';
      opts.fileType = 'pdb';
    }
    if (this._menu) {
      this._menu.setTitle('Loading\u2026');
    }
    this.reset(true);
    this._loader = new io.Loader(file, opts);
    this._spinner.spin(this._container);
    console.time('load');
    this._loader.load({
      ready: function (data) {
        console.timeEnd('load');
        self.dispatchEvent({ type: 'loadingFinished' });
        self._spinner.stop();
        self._onLoad(data, opts);
        self._loader = null;
      },
      error: function (err) {
        // TODO: Show error message
        console.timeEnd('load');
        self.dispatchEvent({
          type: 'loadingFinished',
          error: err
        });
        self._spinner.stop();
        self._loader = null;
      },
      progress: function (percent) {
        // TODO: Update progress bar
        if (DEBUG) {
          var TOTAL_PERCENT = 100;
          if (percent) {
            console.log('DEBUG: Loading... ' + Math.floor(percent * TOTAL_PERCENT) + '%');
          } else {
            console.log('DEBUG: Loading...');
          }
        }
      }
    });
  };
  /**
   * Callback which fires when data are arrived and ready to parse.
   * @param {string} data - File contents.
   * @param {object} opts - TODO: Options.
   * @private
   */
  Miew.prototype._onLoad = function (data, opts) {
    var PREVIEW_LENGTH = 5;
    console.log('MIEW: Loaded ' + opts.fileName + ', contents = "' + data.substr(0, PREVIEW_LENGTH) + '..."');
    opts.loaded = true;
    this.parse(data, opts);
  };
  /**
   * Parse molecule asynchronously.
   * @param {string} data - File contents.
   * @param {object=} opts - Options.
   * @param {string=} opts.fileType - Data contents type (e.g. 'pdb', 'cml').
   */
  Miew.prototype.parse = function (data, opts) {
    var self = this;
    self.dispatchEvent({ type: 'parse' });
    opts = opts || {};
    // TODO: clone
    if (this._menu) {
      this._menu.setTitle('Parsing\u2026');
    }
    if (!opts.loaded) {
      this.reset(true);
    }
    this._parser = new io.Parser(data, opts);
    if (this._parser.constructor === io.Parser) {
      self._onParse(new Complex(), opts);
      self._parser = null;
      return;
    }
    this._spinner.spin(this._container);
    console.time('parse');
    this._parser.parse({
      ready: function (complex) {
        console.timeEnd('parse');
        self._spinner.stop();
        self._onParse(complex, opts);
        self._parser = null;
        self.dispatchEvent({ type: 'parsingFinished' });
      },
      error: function (err) {
        console.timeEnd('parse');
        self._spinner.stop();
        self._onParse(new Complex(), opts);
        self._parser = null;
        self.dispatchEvent({
          type: 'parsingFinished',
          error: err
        });
        self.showBottomMessage(err.message);
      },
      progress: function (percent) {
        // TODO: Update progress bar
        if (DEBUG) {
          var TOTAL_PERCENT = 100;
          if (percent) {
            console.log('DEBUG: Parsing... ' + Math.floor(percent * TOTAL_PERCENT) + '%');
          } else {
            console.log('DEBUG: Parsing...');
          }
        }
      }
    });
  };
  /**
   * Callback which fires when data are parsed and ready to use.
   * @param {Complex} complex - Molecular complex.
   * @param {object} opts - TODO: Options.
   * @private
   */
  Miew.prototype._onParse = function (complex, opts) {
    this._complex = complex;
    var desc = this.info();
    console.log('MIEW: Parsed ' + opts.fileName + ' (' + desc.atoms + ' atoms, ' + desc.bonds + ' bonds, ' + desc.residues + ' residues, ' + desc.chains + ' chains).');
    // update title
    if (opts.fileName) {
      complex.name = complex.name || removeExtension(opts.fileName).toUpperCase();
    } else {
      complex.name = 'Dynamic ' + opts.fileType + ' molecule';
    }
    if (this._menu) {
      this._menu.updateInfo(complex);
    }
    if (settings.now.autoPreset) {
      switch (opts.fileType) {
      case 'cml':
        this.resetReps('small');
        break;
      case 'pdb':
        if (hasValidResidues(complex)) {
          this.resetReps('macro');
        } else {
          this.resetReps('small');
        }
        break;
      default:
        this.resetReps('default');
        break;
      }
    }
    // update representation bits
    var reprList = this._reprList;
    var i, n;
    this._repr = null;
    for (i = 0, n = reprList.length; i < n; ++i) {
      var repr = reprList[i];
      if (repr.markAtoms(complex) && !this._repr) {
        this._repr = repr;
      }
    }
    if (!this._repr) {
      this._repr = reprList[0];
    }
    var gfx = this._gfx;
    var radius = complex.boundingSphere.radius;
    var atomRadius = 0;
    complex.forEachAtom(function (a) {
      atomRadius = Math.max(atomRadius, a.getType().radius);
    });
    radius += atomRadius * settings.now.modes.BS.atom;
    var sgrpRadius = 0;
    var radius2 = radius * radius;
    complex.forEachSGroup(function (grp) {
      var center = complex.boundingSphere.center;
      var p = grp.getPosition();
      var d = p.distanceToSquared(center);
      sgrpRadius = Math.max(d, sgrpRadius);
    });
    if (radius2 < sgrpRadius) {
      radius = Math.sqrt(sgrpRadius);
    }
    gfx.camera.setDistanceToFit(radius, settings.now.camFov);
    gfx.camera.updateProjectionMatrix();
    updateFogRange(gfx.scene.fog, gfx.camera.position.z, radius);
    // reset component matrices
    this._componentTransforms = [];
    for (i = 0; i < complex._components.length; ++i) {
      var component = complex._components[i];
      this._componentTransforms[component._index] = new THREE.Object3D();
    }
    // reset object transform
    gfx.root.resetTransform();
    this.resetPivot();
    this.resetPan();
    if (settings.now.autoResolution) {
      this._tweakResolution();
    }  // this.rebuild(opts);
  };
  Miew.prototype._needRebuild = function () {
    var reprList = this._reprList;
    for (var i = 0, n = reprList.length; i < n; ++i) {
      var repr = reprList[i];
      if (repr.needsRebuild) {
        return true;
      }
    }
    return false;
  };
  /**
   * Rebuild molecule geometry asynchronously.
   */
  Miew.prototype.rebuild = function () {
    if (this._building) {
      console.warn('Miew.rebuild(): already building!');
      return;
    }
    this._building = true;
    this.dispatchEvent({ type: 'rebuild' });
    if (this._menu) {
      this._menu.setTitle('Building geometry\u2026');
    }
    // Destroy current geometry
    clearTree(this._gfx.pivot);
    // Nothing to do?
    var complex = this._complex;
    if (!complex) {
      this._onRebuild();
      return;
    }
    // Start asynchronous rebuild
    console.time('rebuild');
    this._spinner.spin(this._container);
    var self = this;
    var errorOccured = false;
    setTimeout(function _rebuild() {
      var gfx = self._gfx;
      gfx.renderer2d.reset();
      var reprList = self._reprList;
      var palette = palettes.get(settings.now.palette);
      var hasGeometry = false;
      for (var i = 0, n = reprList.length; i < n; ++i) {
        var repr = reprList[i];
        repr.colorer.palette = palette;
        if (repr.needsRebuild) {
          repr.reset();
          try {
            repr.buildGeometry(complex);
          } catch (e) {
            if (e instanceof utils.OutOfMemoryError) {
              repr.needsRebuild = false;
              repr.reset();
              self.showBottomMessage('Not enough memory to build<br> geometry for representation ' + (repr.index + 1));
              errorOccured = true;
            } else {
              throw e;
            }
          }
          if (DEBUG && !errorOccured) {
            console.log('DEBUG: Triangles count: ' + gfxutils.countTriangles(repr.geo));
          }
        }
        hasGeometry = errorOccured || hasGeometry || gfxutils.groupHasGeometryToRender(repr.geo);
        if (repr.geo) {
          gfx.pivot.add(repr.geo);
        }
      }
      console.timeEnd('rebuild');
      self._spinner.stop();
      if (!errorOccured && !hasGeometry) {
        self.showBottomMessage('There is nothing to<br>show for selected representations.');
      }
      self._onRebuild();
    }, 10);
  };
  Miew.prototype.rebuildAll = function () {
    // invalidate all representations
    var reprList = this._reprList;
    for (var i = 0, n = reprList.length; i < n; ++i) {
      reprList[i].needsRebuild = true;
    }
    this.rebuild();  // TODO: isn't implicit rebuild enough?
  };
  /**
   * Callback which fires when geometry is rebuilt.
   * @private
   */
  Miew.prototype._onRebuild = function () {
    this.rebuildSelectionGeometry();
    this._needRender = true;
    // TODO: Gather geometry stats?
    var title = ' \u2013 ' + this._repr.mode.name + ' Mode';
    if (this._complex) {
      title = this._complex.name + title;
    } else {
      title = 'Unknown' + title;
    }
    if (this._menu) {
      this._menu.setTitle(title);
    }
    this._building = false;
  };
  Miew.prototype._extractRepresentation = function () {
    if (this._selectionCount === 0) {
      return;
    }
    var selector = this.buildSelectorFromMask(1 << this._selectionBit);
    var idx = this.repAdd({
      selector: selector,
      mode: this._repr.mode.id,
      colorer: this._repr.colorer.id
    });
    if (idx < 0) {
      this.showBottomMessage('Number of representations<br>is limited to ' + this.getMaxRepresentationCount());
      return;
    }
    var repr = this._reprList[idx];
    repr.setMaterialPreset(this._repr.materialPreset);
    this._repr = repr;
    this.showBottomMessage('New representation<br>created from the selection.');
  };
  /**
   * Set display mode.
   * @param {string} id - Mode ID.
   */
  Miew.prototype.setMode = function (id) {
    // FIXME: remove
    this.rep({ mode: id });
  };
  /**
   * Set coloring mode.
   * @param {string} id - Colorer ID.
   */
  Miew.prototype.setColorer = function (id) {
    // FIXME: remove
    this.rep({ colorer: id });
  };
  Miew.prototype.resetReps = function (preset, force) {
    var reps = this._opts && this._opts.reps;
    if (!reps || force) {
      if (preset) {
        settings.now.preset = preset;
      }
      var presets = settings.now.presets;
      reps = presets[settings.now.preset];
      if (!reps) {
        console.warn('MIEW: Unknown preset "' + settings.now.preset + '"');
        reps = presets[settings.defaults.preset];  // fall back to default preset
      }
      if (!reps) {
        console.warn('MIEW: Unknown preset "' + settings.defaults.preset + '"');
        reps = presets[Object.keys(presets)[0]];  // fall back to any preset
      }
    }
    // Create all necessary representations
    this._reprUsedBits = 0;
    this._reprList.length = reps.length;
    for (var i = 0, n = reps.length; i < n; ++i) {
      var rep = reps[i];
      var selector = selectors.parse(rep.selector || settings.now.presets.default.selector).selector;
      var mode = modes.create(rep.mode);
      var colorer = colorers.create(rep.colorer);
      var material = materials.get(rep.material) || materials.any;
      this._reprList[i] = new Representation(i, mode, colorer, selector);
      this._reprList[i].setMaterialPreset(material);
      this._reprList[i].selectorString = rep.selector;
      // FIXME
      if (this._complex) {
        this._complex.markAtoms(selector, 1 << i);
      }
      this._reprUsedBits |= 1 << i;
    }
    this._repr = this._reprList[0];
    this._selectionBit = reps.length;
    this._reprUsedBits |= 1 << this._selectionBit;
    // selection uses one bit
    this._selectionCount = 0;
  };
  /**
   * Get number of representations created so far.
   * @returns {number} Number of reps.
   */
  Miew.prototype.repCount = function () {
    return this._reprList.length;
  };
  /**
   * Get or set the current representation index.
   * @param {number=} index - Zero-based index, up to {@link Miew#repCount()}. Defaults to the current one.
   * @returns {number} The current index.
   */
  Miew.prototype.repCurrent = function (index) {
    if (index === undefined) {
      index = this._reprList.indexOf(this._repr);
    } else {
      this._repr = this._reprList[index];
    }
    return index;
  };
  function maybeArrayItem(value) {
    if (value instanceof Array) {
      return value[0];
    }
    return value;
  }
  /**
   * Get or set representation by index.
   * @param {number=} index - Zero-based index, up to {@link Miew#repCount()}. Defaults to the current one.
   * @param {object=} rep - Optional representation description.
   * @param {string=} rep.selector - Selector string.
   * @param {string=} rep.mode - Mode id.
   * @param {string=} rep.colorer - Colorer id.
   * @param {string=} rep.material - Material id.
   * @returns {?object} Representation description.
   */
  Miew.prototype.rep = function (index, rep) {
    // if index is missing then it is the current
    if (!rep && (index === undefined || index instanceof Object)) {
      rep = index;
      index = this.repCurrent();
    }
    // fail if out of bounds
    if (index < 0 || index >= this._reprList.length) {
      return null;
    }
    // gather description
    var target = this._reprList[index];
    var desc = {
      selector: target.selectorString,
      // FIXME: Hope it equals String(target.selector)
      mode: target.mode.id,
      colorer: target.colorer.id,
      material: target.materialPreset.id
    };
    // if modification is requested
    if (rep) {
      var changed = false;
      // modify selector
      if (rep.selector) {
        var newSelectorObject = selectors.parse(rep.selector).selector;
        var newSelector = String(newSelectorObject);
        if (desc.selector !== newSelector) {
          target.selectorString = desc.selector = newSelector;
          target.selector = newSelectorObject;
          target.markAtoms(this._complex);
          changed = true;
          if (DEBUG) {
            console.log('DEBUG: rep[' + index + '].selector changed to "' + newSelector + '"');
          }
        }
      }
      // modify mode
      if (rep.mode) {
        var newMode = modes.normalize(maybeArrayItem(rep.mode));
        if (desc.mode !== newMode) {
          desc.mode = newMode;
          target.setMode(modes.create(rep.mode));
          changed = true;
          if (DEBUG) {
            console.log('DEBUG: rep[' + index + '].mode changed to "' + newMode + '"');
          }
          // safety hack: lower resolution for surface modes
          if (newMode.indexOf('SURF') !== -1 && (settings.now.resolution === 'ultra' || settings.now.resolution === 'high')) {
            this._autoChangeResolution('medium');
          }
        }
      }
      // modify colorer
      if (rep.colorer) {
        var newColorer = colorers.normalize(maybeArrayItem(rep.colorer));
        if (desc.colorer !== newColorer) {
          desc.colorer = newColorer;
          target.colorer = colorers.create(rep.colorer);
          changed = true;
          if (DEBUG) {
            console.log('DEBUG: rep[' + index + '].colorer changed to "' + newColorer + '"');
          }
        }
      }
      // modify material
      if (rep.material) {
        var newMaterial = materials.normalize(maybeArrayItem(rep.material));
        if (desc.material !== newMaterial) {
          desc.material = newMaterial;
          target.setMaterialPreset(materials.get(rep.material));
          changed = true;
          if (DEBUG) {
            console.log('DEBUG: rep[' + index + '].material changed to "' + newMaterial + '"');
          }
        }
      }
      // finalize
      if (changed) {
        target.needsRebuild = true;
      }
    }
    return desc;
  };
  Miew.prototype.setRepresentation = function (modeId, colorerId, selector, materialId) {
    // FIXME: remove
    this.rep({
      selector: selector,
      mode: modeId,
      colorer: colorerId,
      material: materialId
    });
  };
  Miew.prototype._getFreeReprIdx = function () {
    var bits = this._reprUsedBits;
    for (var i = 0; i < NUM_REPRESENTATION_BITS; ++i, bits >>= 1) {
      if ((bits & 1) === 0) {
        return i;
      }
    }
    return -1;
  };
  /**
   * Add new representation.
   * @param {object=} rep - Representation description.
   * @returns {number} Index of the new representation.
   */
  Miew.prototype.repAdd = function (rep) {
    if (this._reprList.length >= this.getMaxRepresentationCount()) {
      return -1;
    }
    var newSelectionBit = this._getFreeReprIdx();
    if (newSelectionBit < 0) {
      return -1;  // no more slots for representations
    }
    var originalSelection = this.buildSelectorFromMask(1 << this._selectionBit);
    // Fill in default values
    var def = settings.now.presets.default[0];
    var desc = $.extend({
      selector: def.selector,
      mode: def.mode,
      colorer: def.colorer,
      material: def.material
    }, rep);
    var selector = typeof desc.selector === 'string' ? selectors.parse(desc.selector).selector : desc.selector;
    var target = new Representation(this._selectionBit, modes.create(desc.mode), colorers.create(desc.colorer), selector);
    target.selectorString = selector.toString();
    target.setMaterialPreset(materials.get(desc.material));
    target.markAtoms(this._complex);
    this._reprList.push(target);
    // change selection bit
    this._selectionBit = newSelectionBit;
    this._reprUsedBits |= 1 << this._selectionBit;
    // restore selection using new selection bit
    this._complex.markAtoms(originalSelection, 1 << this._selectionBit);
    // update residue & chain masks
    this._complex.updateResidueMask();
    this._complex.updateChainMask();
    return this._reprList.length - 1;
  };
  /**
   * Remove representation.
   * @param {number=} index - Zero-based representation index.
   */
  Miew.prototype.repRemove = function (index) {
    if (index === undefined) {
      index = this.repCurrent();
    }
    // catch out of bounds case
    var count = this._reprList.length;
    if (index < 0 || index >= count || count <= 1) {
      // do not allow to remove the single rep
      return;
    }
    var target = this._reprList[index];
    target.unmarkAtoms(this._complex);
    this._reprUsedBits &= ~(1 << target.index);
    this._reprList.splice(index, 1);
    // update current rep
    if (target === this._repr) {
      --count;
      index = index < count ? index : count - 1;
      this._repr = this._reprList[index];
    }
  };
  /**
   * Hide representation.
   * @param {number} index - Zero-based representation index.
   * @param {boolean=} hide - Specify false to make rep visible, true to hide (by default).
   */
  Miew.prototype.repHide = function (index, hide) {
    if (hide === undefined) {
      hide = true;
    }
    // fail if out of bounds
    if (index < 0 || index >= this._reprList.length) {
      return;
    }
    var target = this._reprList[index];
    target.show(!hide);
    this._needRender = true;
  };
  Miew.prototype._setEditMode = function (mode) {
    this._editMode = mode;
    var elem = this._msgMode;
    if (elem) {
      elem.style.opacity = mode === EDIT_MODE.COMPLEX ? 0 : 1;
      if (mode !== EDIT_MODE.COMPLEX) {
        var t = elem.getElementsByTagName('p')[0];
        t.innerHTML = mode === EDIT_MODE.COMPONENT ? 'COMPONENT EDIT MODE' : 'FRAGMENT EDIT MODE';
      }
    }
    if (this._menu) {
      this._menu.enableToolbar(mode === EDIT_MODE.COMPLEX);
    }
  };
  Miew.prototype._enterComponentEditMode = function () {
    if (this._editMode !== EDIT_MODE.COMPLEX) {
      return;
    }
    this._setEditMode(EDIT_MODE.COMPONENT);
    this._objectControls.keysTranslateObj(true);
  };
  Miew.prototype._applyComponentEdit = function () {
    if (this._editMode !== EDIT_MODE.COMPONENT) {
      return;
    }
    this._objectControls.stop();
    this._objectControls.keysTranslateObj(false);
    var i;
    for (i = 0; i < this._complex._components.length; ++i) {
      this._bakeComponentTransform(this._complex._components[i]);
    }
    this._complex.onAtomPositionChanged();
    this._resetComponentTransform();
    console.log('COMPONENT EDIT MODE -- OFF (applied)');
    this._setEditMode(EDIT_MODE.COMPLEX);
    this.rebuildAll();
  };
  Miew.prototype._discardComponentEdit = function () {
    if (this._editMode !== EDIT_MODE.COMPONENT) {
      return;
    }
    this._objectControls.stop();
    this._objectControls.keysTranslateObj(false);
    this._resetComponentTransform();
    console.log('COMPONENT EDIT MODE -- OFF (discarded)');
    this._setEditMode(EDIT_MODE.COMPLEX);
    this._needRender = true;
  };
  Miew.prototype._bakeComponentTransform = function (component) {
    var t = this._componentTransforms[component._index];
    if (t && (!(t.position.x === 0 && t.position.y === 0 && t.position.z === 0) || !(t.quaternion.x === 0 && t.quaternion.y === 0 && t.quaternion.z === 0 && t.quaternion.w === 1))) {
      t.updateMatrix();
      for (var i = 0; i < component._residues.length; ++i) {
        var residue = component._residues[i];
        for (var j = 0; j < residue._atoms.length; ++j) {
          var atom = residue._atoms[j];
          atom._position.applyMatrix4(t.matrix);
        }
      }
    }
  };
  Miew.prototype._bakeAtomTransform = function (matrix, mask) {
    this._complex.forEachAtom(function (atom) {
      if (atom._mask & mask) {
        atom._position.applyMatrix4(matrix);
      }
    });
  };
  Miew.prototype._resetComponentTransform = function () {
    var i, j, reprNode, geo;
    for (i = 0; i < this._componentTransforms.length; ++i) {
      geo = this._componentTransforms[i];
      geo.position.set(0, 0, 0);
      geo.quaternion.set(0, 0, 0, 1);
    }
    // reset all geo nodes
    for (i = 0; i < this._gfx.pivot.children.length; ++i) {
      reprNode = this._gfx.pivot.children[i];
      for (j = 0; j < reprNode.children.length; ++j) {
        geo = reprNode.children[j];
        if (geo.hasOwnProperty('_component')) {
          geo.position.set(0, 0, 0);
          geo.quaternion.set(0, 0, 0, 1);
        }
      }
    }
    // reset all selection nodes
    for (i = 0; i < this._gfx.selectionPivot.children.length; ++i) {
      reprNode = this._gfx.selectionPivot.children[i];
      for (j = 0; j < reprNode.children.length; ++j) {
        geo = reprNode.children[j];
        if (geo.hasOwnProperty('_component')) {
          geo.position.set(0, 0, 0);
          geo.quaternion.set(0, 0, 0, 1);
        }
      }
    }
  };
  Miew.prototype._getSelectionBorderAtoms = function () {
    var selectionMask = 1 << this._selectionBit;
    var atomHash = {};
    this._complex.forEachBond(function (bond) {
      if (bond._left._mask & selectionMask) {
        if ((bond._right._mask & selectionMask) === 0) {
          atomHash[bond._left._index] = 1;
        }
      } else if (bond._right._mask & selectionMask) {
        atomHash[bond._right._index] = 1;
      }
    });
    var atoms = [];
    var keys = Object.keys(atomHash);
    for (var i = 0, n = keys.length; i < n; ++i) {
      var idx = keys[i];
      atoms.push(this._complex._atoms[idx]);
    }
    return atoms;
  };
  Miew.prototype._enterFragmentEditMode = function () {
    if (this._editMode !== EDIT_MODE.COMPLEX) {
      return;
    }
    var atoms = this._getSelectionBorderAtoms();
    if (atoms.length < 1 || atoms.length > 2) {
      this.showBottomMessage('Can only edit fragments<br>' + 'with one or two bound atoms.');
      return;
    }
    this._fragmentBoundAtoms = atoms;
    var selectionMask = 1 << this._selectionBit;
    // hide selected fragment in main model
    this._gfx.root.disableSubset(selectionMask, true);
    // hide selection geo in main model
    for (var k = 0; k < this._gfx.selectionPivot.children.length; ++k) {
      this._gfx.selectionPivot.children[k].visible = false;
    }
    // create visible fragment representation to rotate
    var pivotPos = atoms[0]._position.clone();
    if (atoms.length === 2) {
      pivotPos.lerp(atoms[1]._position, 0.5);
    }
    this._fragmentGeo = new THREE.Group();
    this._gfx.pivot.add(this._fragmentGeo);
    this._fragmentGeo.position.copy(pivotPos);
    this._fragmentSelectionGeo = new THREE.Group();
    this._gfx.selectionPivot.add(this._fragmentSelectionGeo);
    this._fragmentSelectionGeo.position.copy(pivotPos);
    var offset = pivotPos.clone();
    offset.negate();
    for (var i = 0; i < this._gfx.pivot.children.length; ++i) {
      var g = this._gfx.pivot.children[i];
      if (!('getSubset' in g)) {
        continue;
      }
      var vg = new THREE.Group();
      this._fragmentGeo.add(vg);
      var sg = new THREE.Group();
      this._fragmentSelectionGeo.add(sg);
      var meshes = g.getSubset(selectionMask, true);
      for (var j = 0; j < meshes.length; j++) {
        var m = meshes[j];
        vg.add(m);
        m.position.copy(offset);
      }
      var smeshes = g.getSubset(selectionMask, true);
      for (var h = 0; h < smeshes.length; h++) {
        var sm = smeshes[h];
        sg.add(sm);
        sm.position.copy(offset);
      }
    }
    this._applySelectionMaterial(this._fragmentSelectionGeo);
    console.log('FRAGMENT EDIT MODE -- ON (single bond)');
    this._setEditMode(EDIT_MODE.FRAGMENT);
    this._objectControls.allowTranslation(false);
    if (atoms.length === 2) {
      this._objectControls.allowAltObjFreeRotation(false);
    }
    this._needRender = true;
  };
  Miew.prototype._applyFragmentEdit = function () {
    if (this._editMode !== EDIT_MODE.FRAGMENT) {
      return;
    }
    this._objectControls.stop();
    var p = this._fragmentGeo.position;
    var m = this._fragmentGeo.matrix.clone();
    m.multiply(new THREE.Matrix4().makeTranslation(-p.x, -p.y, -p.z));
    this._bakeAtomTransform(m, 1 << this._selectionBit);
    // show selected fragment in main model
    this._gfx.root.enableSubset(1 << this._selectionBit, true);
    this._complex.onAtomPositionChanged();
    console.log('FRAGMENT EDIT MODE -- OFF (applied)');
    this._setEditMode(EDIT_MODE.COMPLEX);
    this._objectControls.allowTranslation(true);
    this._objectControls.allowAltObjFreeRotation(true);
    this.rebuildAll();
  };
  Miew.prototype._discardFragmentEdit = function () {
    if (this._editMode !== EDIT_MODE.FRAGMENT) {
      return;
    }
    this._objectControls.stop();
    this._fragmentGeo.parent.remove(this._fragmentGeo);
    // show selected fragment in main model
    this._gfx.root.enableSubset(1 << this._selectionBit, true);
    // show selection geo in main model (+ remove fragment selection geo)
    for (var i = 0; i < this._gfx.selectionPivot.children.length; ++i) {
      var node = this._gfx.selectionPivot.children[i];
      if (node.visible) {
        this._gfx.selectionPivot.remove(node);
      } else {
        node.visible = true;
      }
    }
    console.log('FRAGMENT EDIT MODE -- OFF (discarded)');
    this._setEditMode(EDIT_MODE.COMPLEX);
    this._objectControls.allowTranslation(true);
    this._objectControls.allowAltObjFreeRotation(true);
    this._needRender = true;
  };
  Miew.prototype.resetPan = function () {
    this._gfx.camera.position.x = 0;
    this._gfx.camera.position.y = 0;
  };
  Miew.prototype._onPick = function (event) {
    if (!settings.now.picking) {
      // picking is disabled
      return;
    }
    if (this._editMode === EDIT_MODE.FRAGMENT) {
      // prevent picking in fragment edit mode
      return;
    }
    if (this._objectControls.isEditingAltObj()) {
      // prevent picking during component rotation
      return;
    }
    this.updateSelectionMask(event.obj);
    this.rebuildSelectionGeometry();
  };
  Miew.prototype._onDblClick = function (event) {
    if ('atom' in event.obj) {
      this.setPivotAtom(event.obj.atom);
      this.resetPan();
      this._needRender = true;
    } else if (!('residue' in event.obj)) {
      this.resetPivot();
      this.resetPan();
      this._needRender = true;
    }
  };
  Miew.prototype._onKeyDown = function (event) {
    if (!this._running) {
      return;
    }
    switch (event.keyCode) {
    case 'C'.charCodeAt(0):
      if (settings.now.editing) {
        this._enterComponentEditMode();
      }
      break;
    case 'F'.charCodeAt(0):
      if (settings.now.editing) {
        this._enterFragmentEditMode();
      }
      break;
    case 'A'.charCodeAt(0):
      switch (this._editMode) {
      case EDIT_MODE.COMPONENT:
        this._applyComponentEdit();
        break;
      case EDIT_MODE.FRAGMENT:
        this._applyFragmentEdit();
        break;
      default:
        break;
      }
      break;
    case 'D'.charCodeAt(0):
      switch (this._editMode) {
      case EDIT_MODE.COMPONENT:
        this._discardComponentEdit();
        break;
      case EDIT_MODE.FRAGMENT:
        this._discardFragmentEdit();
        break;
      default:
        break;
      }
      break;
    case 107:
      event.preventDefault();
      event.stopPropagation();
      this.expandSelection();
      this.rebuildSelectionGeometry();
      break;
    case 109:
      event.preventDefault();
      event.stopPropagation();
      this.shrinkSelection();
      this.rebuildSelectionGeometry();
      break;
    default:
    }
  };
  Miew.prototype._onKeyUp = function (event) {
    if (!this._running) {
      return;
    }
    switch (event.keyCode) {
    case 'X'.charCodeAt(0):
      this._extractRepresentation();
      break;
    default:
    }
  };
  Miew.prototype.updateSelectionMask = function (pickedObj) {
    var self = this;
    var atom = pickedObj.atom;
    var residue = pickedObj.residue;
    var chain = null;
    var info = this._msgAtomInfo.getElementsByTagName('p')[0];
    var setMask = 1 << this._selectionBit;
    var clearMask = ~setMask;
    var count = 0;
    function setHTML(aName) {
      var newNode = null;
      var firstLine = String(count) + ' atom' + (count !== 1 ? 's' : '') + ' selected, the last pick:';
      var secondLine = atom._type.fullName + ' #' + atom._serial + ': ' + chain._name + '.' + residue._type._name + residue._sequence + residue._icode.trim() + '.';
      if (typeof aName === 'string') {
        secondLine += aName.trim();
      }
      var thirdLine = 'Coord: (' + atom._position.x.toFixed(2).toString() + ', ' + atom._position.y.toFixed(2).toString() + ', ' + atom._position.z.toFixed(2).toString() + ')';
      info.appendChild(document.createTextNode(firstLine));
      info.appendChild(document.createElement('br'));
      info.appendChild(document.createTextNode(secondLine));
      if (typeof aName !== 'string') {
        newNode = aName.cloneNode(true);
        newNode.style.fontSize = '85%';
        info.appendChild(newNode);
      }
      info.appendChild(document.createElement('br'));
      info.appendChild(document.createTextNode(thirdLine));
    }
    if (atom) {
      residue = atom._residue;
      chain = residue._chain;
      if (atom._mask & setMask) {
        atom._mask &= clearMask;
        residue._mask &= clearMask;
        chain._mask &= clearMask;
        this._selectionCount--;
      } else {
        atom._mask |= setMask;
        this._selectionCount++;
        // select residue if all atoms in it are selected
        residue.collectMask();
        // select chain if all residues in it are selected
        chain.collectMask();
      }
      count = this._selectionCount;
      while (info.firstChild) {
        info.removeChild(info.firstChild);
      }
      var an = atom.getName();
      if (an.getNode() !== null) {
        setHTML(an.getNode());
      } else {
        setHTML(an.getString());
      }
      this._msgAtomInfo.style.opacity = 1;
    } else if (residue) {
      chain = residue._chain;
      if (residue._mask & setMask) {
        residue._mask &= clearMask;
        chain._mask &= clearMask;
        residue.forEachAtom(function (a) {
          if (a._mask & setMask) {
            a._mask &= clearMask;
            self._selectionCount--;
          }
        });
      } else {
        residue._mask |= setMask;
        residue.forEachAtom(function (a) {
          if (!(a._mask & setMask)) {
            a._mask |= setMask;
            self._selectionCount++;
          }
        });
        // select chain if all residues in it are selected
        chain.collectMask();
      }
      count = this._selectionCount;
      info.innerHTML = String(count) + ' atom' + (count !== 1 ? 's' : '') + ' selected, the last pick:<br>' + residue._type._fullName + ': ' + residue._chain._name + '.' + residue._type._name + residue._sequence + residue._icode.trim();
      this._msgAtomInfo.style.opacity = 1;
    } else {
      this._msgAtomInfo.style.opacity = 0;
      if (this._selectionCount !== 0) {
        this._selectionCount = 0;
        if (this._complex) {
          this._complex.forEachAtom(function (a) {
            a._mask &= clearMask;
          });
          this._complex.forEachResidue(function (a) {
            a._mask &= clearMask;
          });
          this._complex.forEachChain(function (a) {
            a._mask &= clearMask;
          });
        }
      }
    }
  };
  Miew.prototype.buildSelectorFromMask = function (mask) {
    var complex = this._complex;
    var chains = [];
    var residues = {};
    var atoms = [];
    complex.forEachChain(function (chain) {
      if (chain._mask & mask) {
        chains.push(chain._name);
      }
    });
    complex.forEachResidue(function (residue) {
      if (residue._mask & mask && !(residue._chain._mask & mask)) {
        var c = residue._chain._name;
        if (!(c in residues)) {
          residues[c] = [residue._sequence];
        } else {
          residues[c].push(residue._sequence);
        }
      }
    });
    complex.forEachAtom(function (atom) {
      if (atom._mask & mask && !(atom._residue._mask & mask)) {
        atoms.push(atom._serial);
      }
    });
    function optimizeList(list) {
      var result = [], k = 0;
      var first = NaN, last = NaN;
      for (var i = 0, n = list.length; i < n; ++i) {
        var value = list[i];
        if (value === last + 1) {
          last = value;
        } else {
          if (!isNaN(first)) {
            result[k++] = new selectors.Range(first, last);
          }
          first = last = value;
        }
      }
      if (!isNaN(first)) {
        result[k] = new selectors.Range(first, last);
      }
      return result;
    }
    var expression = null;
    var selector = null;
    if (chains.length === complex._chains.length) {
      expression = selectors.all();
    } else {
      if (chains.length > 0) {
        selector = selectors.chain(chains);
        expression = expression ? selectors.or(expression, selector) : selector;
      }
      if (Object.keys(residues).length > 0) {
        for (var ch in residues) {
          if (residues.hasOwnProperty(ch)) {
            selector = selectors.and(selectors.chain(ch), selectors.sequence(optimizeList(residues[ch])));
            expression = expression ? selectors.or(expression, selector) : selector;
          }
        }
      }
      if (atoms.length > 0) {
        selector = selectors.serial(optimizeList(atoms));
        expression = expression ? selectors.or(expression, selector) : selector;
      }
      if (!expression) {
        expression = selectors.none();
      }
    }
    return expression;
  };
  Miew.prototype._applySelectionMaterial = function (geo) {
    geo.traverse(function (node) {
      if ('material' in node) {
        node.material = node.material.clone();
        // HACK: using z-offset to magically fix selection rendering artifact (on z-sprites)
        node.material.setValues({
          depthFunc: THREE.LessEqualDepth,
          overrideColor: true
        });
        node.material.setUberOptions({
          fixedColor: new THREE.Color(16776960),
          zOffset: -0.000001
        });
        if (node.material instanceof UberMaterial) {
          node.material.updateUniforms();
        }
      }
    });
  };
  Miew.prototype.rebuildSelectionGeometry = function () {
    this._needRender = true;
    var gfx = this._gfx;
    var mask = 1 << this._selectionBit;
    clearTree(gfx.selectionPivot);
    for (var i = 0, n = this._reprList.length; i < n; ++i) {
      var repr = this._reprList[i];
      var sg = repr.buildSelectionGeometry(mask);
      if (!sg) {
        continue;
      }
      gfx.selectionPivot.add(sg);
      for (var j = 0; j < sg.children.length; j++) {
        var m = sg.children[j];
        // copy component transform (that's not applied yet)
        var t = this._componentTransforms[m._component._index];
        if (t) {
          m.position.copy(t.position);
          m.quaternion.copy(t.quaternion);
        }
      }
      this._applySelectionMaterial(sg);
    }
  };
  Miew.prototype.expandSelection = function () {
    var self = this;
    var selectionMask = 1 << this._selectionBit;
    var tmpMask = 1 << 31;
    // mark atoms to add
    this._complex.forEachBond(function (bond) {
      if (bond._left._mask & selectionMask) {
        if ((bond._right._mask & selectionMask) === 0) {
          bond._right._mask |= tmpMask;
        }
      } else if (bond._right._mask & selectionMask) {
        bond._left._mask |= tmpMask;
      }
    });
    // select marked atoms
    var deselectionMask = ~tmpMask;
    this._complex.forEachAtom(function (atom) {
      if (atom._mask & tmpMask) {
        atom._mask = atom._mask & deselectionMask | selectionMask;
        ++self._selectionCount;
      }
    });
    this._complex.updateResidueMask();
    this._complex.updateChainMask();
  };
  Miew.prototype.shrinkSelection = function () {
    var self = this;
    var selectionMask = 1 << this._selectionBit;
    var tmpMask = 1 << 31;
    // mark atoms neighbouring to unselected ones
    this._complex.forEachBond(function (bond) {
      if (bond._left._mask & selectionMask) {
        if ((bond._right._mask & selectionMask) === 0) {
          bond._left._mask |= tmpMask;
        }
      } else if (bond._right._mask & selectionMask) {
        bond._right._mask |= tmpMask;
      }
    });
    // mark hanging atoms
    this._complex.forEachAtom(function (atom) {
      if (atom._mask & selectionMask && atom._bonds.length === 1) {
        atom._mask |= tmpMask;
      }
    });
    // deselect marked atoms
    var deselectionMask = ~(selectionMask | tmpMask);
    this._complex.forEachAtom(function (atom) {
      if (atom._mask & tmpMask) {
        atom._mask &= deselectionMask;
        --self._selectionCount;
      }
    });
    this._complex.updateResidueMask();
    this._complex.updateChainMask();
  };
  Miew.prototype.getSelectedComponent = function () {
    var selectionMask = 1 << this._selectionBit;
    var component = null;
    var multiple = false;
    // find which component is selected (exclusively)
    this._complex.forEachAtom(function (atom) {
      if (atom._mask & selectionMask) {
        if (component === null) {
          component = atom._residue._component;
        } else if (component !== atom._residue._component) {
          multiple = true;
        }
      }
    });
    return multiple ? null : component;
  };
  Miew.prototype.getAltObj = function () {
    var res = {
      objects: [],
      pivot: new THREE.Vector3(0, 0, 0)
    };
    var selectionMask = 1 << this._selectionBit;
    switch (this._editMode) {
    case EDIT_MODE.COMPONENT:
      var component = this.getSelectedComponent();
      if (component) {
        var i, j, reprNode, geo;
        // find all geo nodes for this component
        for (i = 0; i < this._gfx.pivot.children.length; ++i) {
          reprNode = this._gfx.pivot.children[i];
          for (j = 0; j < reprNode.children.length; ++j) {
            geo = reprNode.children[j];
            if (geo.hasOwnProperty('_component') && geo._component === component) {
              res.objects.push(geo);
            }
          }
        }
        // find all selection nodes for this component
        for (i = 0; i < this._gfx.selectionPivot.children.length; ++i) {
          reprNode = this._gfx.selectionPivot.children[i];
          for (j = 0; j < reprNode.children.length; ++j) {
            geo = reprNode.children[j];
            if (geo.hasOwnProperty('_component') && geo._component === component) {
              res.objects.push(geo);
            }
          }
        }
        // add dummy object that stores component transformation
        res.objects.push(this._componentTransforms[component._index]);
        var bbmin = new THREE.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        var bbmax = new THREE.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        for (i = 0; i < component._residues.length; ++i) {
          var atoms = component._residues[i]._atoms;
          for (j = 0; j < atoms.length; ++j) {
            if (atoms[j]._mask & selectionMask) {
              bbmin.min(atoms[j]._position);
              bbmax.max(atoms[j]._position);
            }
          }
        }
        res.pivot.lerpVectors(bbmin, bbmax, 0.5);
      }
      break;
    case EDIT_MODE.FRAGMENT:
      res.objects.push(this._fragmentGeo, this._fragmentSelectionGeo);
      var boundAtoms = this._fragmentBoundAtoms;
      if (boundAtoms.length === 1) {
        if (boundAtoms[0]._bonds.length === 1) {
          // single external bond allows rotation about bond axis
          var bond = boundAtoms[0]._bonds[0];
          res.axis = new THREE.Vector3().subVectors(bond._right._position, bond._left._position);
          res.axis.normalize();
          res.axis.transformDirection(this._gfx.pivot.matrixWorld);
        }
      } else if (boundAtoms.length === 2) {
        // two bound atoms allow rotation only about axis running through their centers
        res.axis = new THREE.Vector3().subVectors(boundAtoms[1]._position, boundAtoms[0]._position);
        res.axis.normalize();
        res.axis.transformDirection(this._gfx.pivot.matrixWorld);
      }
      break;
    default:
      break;
    }
    return res;
  };
  Miew.prototype.resetPivot = function () {
    this._gfx.pivot.position.copy(this._complex.boundingSphere.center);
    this._gfx.pivot.position.negate();
  };
  Miew.prototype.setPivotAtom = function (atom) {
    this._gfx.pivot.position.copy(atom._position);
    this._gfx.pivot.position.negate();
  };
  Miew.prototype.profileGfx = function () {
    var self = this;
    var p = new GfxProfiler(this._gfx.renderer);
    p.runOnTicks(100, 1000, 10000).then(function () {
      self._showMessage('GFX profile: ' + (1000 / p.mean()).toPrecision(2));
    });
  };
  Miew.prototype.benchmarkGfx = function (force) {
    var self = this;
    var prof = new GfxProfiler(this._gfx.renderer);
    var deferred = new $.Deferred();
    setTimeout(function () {
      if (!force && !settings.now.autoResolution) {
        deferred.resolve();
        return;
      }
      if (self._menu) {
        self._menu.setTitle('Profiling\u2026');
      }
      self._spinner.spin(self._container);
      prof.runOnTicks(50, 1000, 2000).then(function (numResults) {
        self._gfxScore = 0;
        if (numResults >= 5) {
          self._gfxScore = 1000 / prof.mean();
        }
        if (numResults > 0) {
          self._gfxScore = 0.5 * numResults;
        }
        // document.getElementById('atom-info').innerHTML = 'GFX score: ' + self._gfxScore.toPrecision(2);
        self._spinner.stop();
        deferred.resolve();
      });
    }, 0);
    return deferred.promise();
  };
  /**
   * Makes a screenshot.
   * @returns {string} Data URL representing the image contents.
   */
  Miew.prototype.screenshot = function () {
    return this._gfx.renderer.domElement.toDataURL('image/png');
  };
  Miew.profile = function (file, count, element) {
    var now = utils.Timer.now;
    var opts = {};
    var data = '';
    var times = [];
    function robustMean(values) {
      var n = values.length - Math.round(values.length * 0.1);
      values.sort();
      var mean = 0;
      for (var i = 0; i < n; ++i) {
        mean += values[i];
      }
      return mean / n;
    }
    function robustDeviation(values, mean) {
      var n = values.length;
      var deltas = new Array(n);
      for (var i = 0; i < n; ++i) {
        deltas[i] = (values[i] - mean) * (values[i] - mean);
      }
      deltas.sort();
      return Math.sqrt(robustMean(deltas));
    }
    var parseCallbacks = {
      ready: function () {
        var t = now();
        var iLast = times.length - 1;
        times[iLast] = t - times[iLast];
        if (iLast < count - 1) {
          parseWithTiming();
        } else {
          var mean = robustMean(times);
          var sd = robustDeviation(times, mean);
          var output = mean.toFixed(1) + ' \xB1 ' + (2 * sd).toFixed(1) + ' (95%)';
          console.log(times);
          console.log(output);
          element.textContent = output;
        }
      },
      error: function () {
        console.error('Parse error: ' + opts.fileName);
      }
    };
    function parseWithTiming() {
      var parser = new io.Parser(data, opts);
      times.push(now());
      parser.parse(parseCallbacks);
    }
    var loader = new io.Loader(file, opts);
    loader.load({
      ready: function (data_) {
        data = data_;
        parseWithTiming();
      },
      error: function () {
        console.error('Load error: ' + opts.fileName);
      }
    });
  };
  Miew.prototype._tweakResolution = function () {
    var maxPerf = [
      [
        'poor',
        100
      ],
      [
        'low',
        500
      ],
      [
        'medium',
        1000
      ],
      [
        'high',
        5000
      ],
      [
        'ultra',
        Number.MAX_VALUE
      ]
    ];
    var performance = 0;
    if (this._complex && this._complex.getAtomCount() > 0) {
      performance = this._gfxScore * 1000000 / this._complex.getAtomCount();
      // set resolution based on estimated performance
      for (var i = 0; i < maxPerf.length; ++i) {
        if (performance < maxPerf[i][1]) {
          this._autoChangeResolution(maxPerf[i][0]);
          break;
        }
      }
    }
  };
  Miew.prototype._autoChangeResolution = function (resolution) {
    if (resolution !== settings.now.resolution) {
      this.showBottomMessage('Your rendering resolution was changed<br>' + 'to <em>' + resolution + '</em> for best performance.');
    }
    settings.now.resolution = resolution;
  };
  Miew.prototype.showBottomMessage = function (html) {
    this._bottomMessageShowTime = Date.now();
    var t = this._msgBottom.getElementsByTagName('p')[0];
    t.innerHTML = html;
  };
  Miew.prototype.updateBottomMessage = function () {
    var elapsedTimeMs = Date.now() - this._bottomMessageShowTime;
    var msg = this._msgBottom;
    var a = 1 - (elapsedTimeMs - 5000) / 1000;
    var opacity = Math.max(0, Math.min(1, a));
    if (msg.style.opacity !== opacity.toString()) {
      msg.style.opacity = opacity;
    }
  };
  /**
   * DANGEROUS and TEMPORARY. The method should change or disappear in future versions.
   * @param {string|object} opts - See {@link Miew} constructor.
   * @see {@link Miew#set}, {@link Miew#repAdd}, {@link Miew#rep}.
   */
  Miew.prototype.setOptions = function (opts) {
    if (typeof opts === 'string') {
      opts = Miew.optionsAttr(opts);
    }
    if (opts.reps) {
      this._opts.reps = null;
    }
    $.extend(true, this._opts, opts);
    if (opts.settings) {
      this.set(opts.settings);
    }
    if (opts.load) {
      this.load(opts.load, { fileType: opts.type });
    }
    if (opts.reps) {
      this.resetReps();
    }
  };
  Miew.prototype._processMessageData = function (data) {
    var self = this;
    var idx = 0 - 1;
    idx = data.indexOf(':', 0);
    if (idx > 0) {
      switch (data.substring(0, idx)) {
      case 'load': {
          if (self._gfx === null) {
            if (self.init()) {
              self.benchmarkGfx().then(function () {
                self.run();
                self.load(data.substring(idx + 1), { sourceType: 'message' });
              });
            }
          } else {
            self.load(data.substring(idx + 1), { sourceType: 'message' });
          }
          break;
        }
      case 'setOptions': {
          if (self._gfx === null || !self._complex) {
            setTimeout(function () {
              self._processMessageData(data);
            }, 10);
            return;
          }
          this.setOptions(data.substring(idx + 1));
          break;
        }
      default: {
          console.log('Unknown message: ' + data);
        }
      }
      console.log(data.substring(0, idx) + ' message received.');
    }
  };
  Miew.prototype._serializeData = function (complex) {
    var oSerializer = null;
    var sXML = null;
    if (complex !== null) {
      oSerializer = new XMLSerializer();
      sXML = oSerializer.serializeToString(complex.originalCML);
      return window.btoa(sXML);
    }
    return null;
  };
  Miew.prototype._getMasterWindow = function () {
    var dstWindow = this._sourceWindow;
    if (!dstWindow || dstWindow === null) {
      if (typeof window.parent !== 'undefined' && window.parent !== null) {
        dstWindow = window.parent;
      }
    }
    if (!dstWindow) {
      dstWindow = null;
    }
    return dstWindow;
  };
  Miew.prototype.saveData = function () {
    function extractRotation(m) {
      var xAxis = new THREE.Vector3();
      var yAxis = new THREE.Vector3();
      var zAxis = new THREE.Vector3();
      m.extractBasis(xAxis, yAxis, zAxis);
      xAxis.normalize();
      yAxis.normalize();
      zAxis.normalize();
      var retMat = new THREE.Matrix4();
      retMat.identity();
      retMat.makeBasis(xAxis, yAxis, zAxis);
      return retMat;
    }
    //saves data
    var root = this._gfx.root;
    var mat = extractRotation(root.matrixWorld);
    var v4 = new THREE.Vector4(0, 0, 0, 0);
    var vCenter = new THREE.Vector4(0, 0, 0, 0);
    var xml = null;
    var ap = null;
    var cp = null;
    var dstWindow = this._getMasterWindow();
    //prepare matrix
    var fi = this._complex;
    if (fi && fi.originalCML) {
      fi.forEachAtom(function (atom) {
        if (atom.xmlNodeRef && atom.xmlNodeRef.xmlNode) {
          xml = atom.xmlNodeRef.xmlNode;
          ap = atom.getPosition();
          v4.set(ap.x, ap.y, ap.z, 1);
          v4.applyMatrix4(mat);
          xml.setAttribute('x3', v4.x.toString());
          xml.setAttribute('y3', v4.y.toString());
          xml.setAttribute('z3', v4.z.toString());
          xml.removeAttribute('x2');
          xml.removeAttribute('y2');
        }
      });
      fi.forEachSGroup(function (sGroup) {
        if (sGroup.xmlNodeRef && sGroup.xmlNodeRef.xmlNode) {
          xml = sGroup.xmlNodeRef.xmlNode;
          ap = sGroup.getPosition();
          v4.set(ap.x, ap.y, ap.z, 1);
          cp = sGroup.getCentralPoint();
          if (cp === null) {
            v4.applyMatrix4(mat);
          } else {
            vCenter.set(cp.x, cp.y, cp.z, 0);
            v4.add(vCenter);
            v4.applyMatrix4(mat);
            // pos in global space
            vCenter.set(cp.x, cp.y, cp.z, 1);
            vCenter.applyMatrix4(mat);
            v4.sub(vCenter);
          }
          xml.setAttribute('x', v4.x.toString());
          xml.setAttribute('y', v4.y.toString());
          xml.setAttribute('z', v4.z.toString());
        }
      });
    }
    if (fi !== null) {
      if (dstWindow !== null) {
        dstWindow.postMessage('CML:' + this._serializeData(fi), dstWindow.location.origin);
      }
    }
  };
  Miew.prototype.resetData = function () {
    var com = this._complex;
    if (com === null) {
      return;
    }
    if (Array.isArray(com)) {
      com = com[0];
    }
    var s = 'load:CML:' + this._serializeData(com);
    this._processMessageData(s);
  };
  Miew.prototype.canSaveData = function () {
    var com = this._complex;
    if (com === null) {
      return false;
    }
    if (Array.isArray(com)) {
      com = com[0];
    }
    if (!com.originalCML) {
      return false;
    }
    return this._getMasterWindow() !== null;
  };
  Miew.prototype.messageListener = function (event) {
    var self = this;
    var origin = event.origin || event.originalEvent.origin;
    var data = null;
    var callF = null;
    if (origin === document.location.origin) {
      data = event.data;
      callF = self._processMessageData.bind(self);
      this._sourceWindow = event.source;
      callF(data);
    }
  };
  Miew.prototype.info = function () {
    var complex = this._complex;
    var metadata = complex.metadata;
    return {
      id: metadata.id || complex.name || 'UNKNOWN',
      title: metadata.title && metadata.title.join(' ') || 'UNKNOWN DATA',
      atoms: complex.getAtomCount(),
      bonds: complex.getBondCount(),
      residues: complex.getResidueCount(),
      chains: complex.getChainCount()
    };
  };
  /**
   * Get string with representation description for URL
   * @param {bool} includeSettings - true when URL should include non-default settings, false otherwise
   * @returns {*} URL part with representation description .
   */
  Miew.prototype.getURL = function (includeSettings) {
    function addParameter(path, value, valueDefault, str) {
      if (value !== valueDefault) {
        str.push(path.join('.') + '=' + value);
      }
    }
    function compareSettings(obj, objDefault, name, str) {
      if (obj === undefined || objDefault === undefined) {
        return;
      }
      var path = name;
      var i = 0;
      if (obj instanceof Object) {
        var keys = Object.keys(obj);
        for (var n = keys.length; i < n; ++i) {
          var key = keys[i];
          var value = obj[key];
          var valueDefault = objDefault.hasOwnProperty(key) ? objDefault[key] : null;
          var newPath = path.concat(key);
          compareSettings(value, valueDefault, newPath, str);
        }
      } else {
        addParameter(path, obj, objDefault, str);
      }
    }
    // generate representation string
    var reprString = generatePresetString(this._reprList);
    reprString = reprString.join('&');
    // generate settings diff string if needed
    if (includeSettings) {
      var settString = [];
      var name = [];
      compareSettings(settings.now, settings.defaults, name, settString);
      // remove preset setting before the concatenation
      settString = settString.join('&');
      settString = removePresetStr(settString);
      if (settString.length > 0) {
        reprString = reprString.concat('&' + settString);
      }
    }
    if (this._complex !== null && this._complex.metadata.id) {
      if (reprString.length > 0) {
        reprString = '&' + reprString;
      }
      reprString = 'load=' + this._complex.metadata.id + reprString;
    }
    var location = window.location;
    var start = location.protocol + '//' + location.host + location.pathname;
    var url = start + '?' + reprString;
    console.log(url);
    return url;
  };
  /**
   * Get parameter value.
   * @param {string} param - Parameter name or path (e.g. 'modes.BS.atom').
   * @param {*=} value - Default value.
   * @returns {*} Parameter value.
   */
  Miew.prototype.get = function (param, value) {
    return settings.get(param, value);
  };
  /**
   * Set parameter value.
   * @param {string|object} params - Parameter name or path (e.g. 'modes.BS.atom') or even settings object.
   * @param {*=} value - Value.
   */
  Miew.prototype.set = function (params, value) {
    if (typeof params === 'string' && value !== undefined) {
      // slow but avoids code duplication
      var key = params;
      params = {};
      params[key] = value;
    }
    if (params instanceof Object) {
      settings.override(params);
      // TODO: think about 'change' events
      if (params.theme !== undefined) {
        this._onThemeChanged();
      }
      if (params.fps !== undefined) {
        this._fps.show(settings.now.fps);
      }
    }
  };
  ////////////////////////////////////////////////////////////////////////////
  // Additional exports
  Miew.optionsURL = options.fromURL;
  Miew.optionsAttr = options.fromAttr;
  // Miew.prototype.debugTracer = new utils.DebugTracer(Miew.prototype);
  return Miew;
}(jquery, three, dat, Spinner, Stats, utils, options, settings, chem_selectors, chem_Complex, gfx_GfxProfiler, io_io, gfx_modes, gfx_colorers, gfx_palettes, gfx_materials, gfx_Representation, gfx_CSS2DRenderer, ui_Menu, ui_ObjectControls, ui_Picker, gfx_Axes, gfx_gfxutils, gfx_shaders_UberMaterial, gfx_shaders_Outline, gfx_shaders_FXAA);
return Miew;
}));
